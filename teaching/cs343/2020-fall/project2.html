<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Project 2: Return-oriented Programming</title><meta name=description content="Project 2: Return-oriented Programming"> <link rel=canonical href=https://checkoway.net/teaching/cs343/2020-fall/project2.html> <link rel=stylesheet href=/css/main.css><main><h1 id=project-2-return-oriented-programming>Project 2: Return-oriented Programming</h1><p><strong>Due:</strong> 2020-11-06 23:59<h2 id=goal>Goal</h2><p>The goal of this project is to practice writing return-oriented programs and implement several different types of shell code.<p>Specifically, there is one <code class="language-plaintext highlighter-rouge">target</code> binary which is a statically-linked, 32-bit x86 Linux binary. You will write five different Python programs which will exploit the binary in different ways. Unlike Project 1, this target is a server program which you will treat as if it were running on a remote machine. (In reality, both the <code class="language-plaintext highlighter-rouge">target</code> and the exploits will run on the same machine, but they will communicate over TCP.)<p>Skeleton code for each Python program has been provided, but each will need substantial modification.<h2 id=collaboration>Collaboration</h2><p>You may work on this project in collaboration with a single partner as described on the main page.<p>You must not discuss the project with anyone other than your partner and course staff. You may use online resources for general reference, but not to search for solutions to specific questions posed in this project.<h2 id=the-environment>The Environment</h2><p>You should be able to work in any 32- or 64-bit Linux environment that has Python 3 (and netcat is helpful). In particular, you may use <code class="language-plaintext highlighter-rouge">hacker.cs.oberlin.edu</code>. If you are in Oberlin, you can use<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>ssh csusername@hacker.cs.oberlin.edu
</code></pre></div></div><p>whereas if you are not in Oberlin, you can use<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>ssh <span class=nt>-J</span> csusername@occs.cs.oberlin.edu csusername@hacker.cs.oberlin.edu
</code></pre></div></div><p>You may want to put the following lines in your <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> on your local machine (sorry Windows users, I don’t know the equivalent for Windows ssh programs).<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>Host = occs
HostName = occs.cs.oberlin.edu
User = csusername

Host = hacker
HostName = hacker.cs.oberlin.edu
User = csusername

Host = hacker-external
HostName = hacker.cs.oberlin.edu
User = csusername
ProxyJump = occs
</code></pre></div></div><p>You should replace <code class="language-plaintext highlighter-rouge">csusername</code> with your CS username. This lets you ssh to <code class="language-plaintext highlighter-rouge">hacker</code> using just<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>ssh hacker <span class=c># if you're on campus</span>
<span class=nv>$ </span>ssh hacker-external <span class=c># if you're not</span>
</code></pre></div></div><p>I also recommend generating an ssh key pair and installing the public key in <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> on <code class="language-plaintext highlighter-rouge">occs</code> as described <a href=https://www.ssh.com/ssh/keygen/>here</a>. The steps are something like<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>ssh-keygen <span class=nt>-t</span> ed25519
<span class=nv>$ </span>ssh-copy-id <span class=nt>-i</span> ~/.ssh/id_ed25519.pub occs
</code></pre></div></div><p>This assumes you’ve added the lines above to <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> already.<p>You’re also welcome to use the VirtualBox virtual machine from project 1.<p>When exploiting the target (see below), you should not assume anything about stack addresses (in particular, you should not assume anything about environment variables).<h2 id=the-target>The Target</h2><p>The <code class="language-plaintext highlighter-rouge">target</code> binary has been compiled from <code class="language-plaintext highlighter-rouge">target.c</code> and statically linked with <a href=http://www.pcre.org/>PCRE2</a>. You must not change <code class="language-plaintext highlighter-rouge">target</code> or attempt to recompile it from <code class="language-plaintext highlighter-rouge">target.c</code>. If you do so, your exploits will almost certainly not work against the unmodified <code class="language-plaintext highlighter-rouge">target</code>.<p>The <code class="language-plaintext highlighter-rouge">target</code> is a simple server program that listens on the specified port for a connection. Once connected, a client can send one of two commands:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>PUT SECRET &lt;password&gt; &lt;secret&gt;\r\n
</code></pre></div></div><p>and<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>GET SECRET &lt;password&gt;\r\n
</code></pre></div></div><p>The first command directs the server to remember a secret and its associated password. (The password may not contain white space.) The second command directs the server to reply with the secret, if the password matches. See <code class="language-plaintext highlighter-rouge">target.c</code> for the precise workings.<h2 id=the-assignment>The Assignment</h2><p>There are five tasks to be completed. Each task involves modifying a Python exploit program to construct a return-oriented exploit to exploit <code class="language-plaintext highlighter-rouge">target</code> in the manner specified.<p><strong>WARNING: Although care has been taken to limit connections to localhost, as part of this project, you will be connecting sockets to shells. You <em>must</em> ensure that all sockets you create, either in the Python exploit programs or in <code class="language-plaintext highlighter-rouge">target</code> are bound to <code class="language-plaintext highlighter-rouge">127.0.0.1</code>.</strong><p><strong>FURTHER WARNING: Any attempt to connect to other students’ open ports is strictly prohibited. Violations will result in a 0 for the project and academic integrity hearings. So please, just don’t do it.</strong><p>Unlike Project 1, code injection will not be possible due to standard DEP protections. Instead, you will need to implement return-oriented programs. This will be tricky, but it is how modern software exploitation actually works.<p>To find gadgets in <code class="language-plaintext highlighter-rouge">target</code>, you may use Jonathan Salwan’s <a href=https://github.com/JonathanSalwan/ROPgadget><code class="language-plaintext highlighter-rouge">ROPgadget</code></a> tool. <code class="language-plaintext highlighter-rouge">ROPgadget</code> requires the <code class="language-plaintext highlighter-rouge">capstone</code> disassembler to run. This is not installed on the departmental servers, but you should be able to install it on your own machines. We have included a <code class="language-plaintext highlighter-rouge">gadgets.txt</code> file that is the result of running:<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./ROPgadget.py <span class=nt>--binary</span> target <span class=nt>--ropchain</span> <span class=o>&gt;</span> gadgets.txt
</code></pre></div></div><p>You may still find it helpful to run it yourself with other options.<p>Each task description below contains an example which consists of running <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> in one shell (with <code class="language-plaintext highlighter-rouge">&lt;port&gt;</code> replaced by a real port number) and running the Python program for the task. In addition, each task description includes the partial output of running the target using <a href=http://man7.org/linux/man-pages/man1/strace.1.html title="strace(1) man page">strace(1)</a>. Your code should induce the same behavior in <code class="language-plaintext highlighter-rouge">target</code>. That is, replacing <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> with <code class="language-plaintext highlighter-rouge">./strace ./target &lt;port&gt;</code> and following the provided example should produce the same system calls, with the same arguments, in the same order as shown. (File descriptor numbers may be different from those shown, but should be self-consistent.)<p><strong>You may not use any of the system calls that allocate writable and executable memory nor any system calls that change memory page permissions. In particular, all of the exploits you write must be entirely in the return-oriented style; you should not inject any x86 code.</strong><h2 id=the-assignment-repository>The Assignment Repository</h2><p>Go to the <a href=https://classroom.github.com/g/U1GqpT7U>GitHub Classroom page</a> and accept the assignment.<ul><li>If you are working by yourself, create a new team (you can name it whatever you like).<li>If you are working with a partner (which I recommend), one of you should create a new team and the other should join the team.</ul><p><strong>Warning: Do not join any team other than your partner’s. There’s no way to change teams for the assignment so just don’t do it! (If you do join the wrong team by mistake, let me know immediately.)</strong><p>You should now be able to clone the assignment repository on <code class="language-plaintext highlighter-rouge">hacker</code>.<h2 id=the-tasks>The Tasks</h2><h3 id=task-1-local-shell-localpy>Task 1 Local shell (<code class="language-plaintext highlighter-rouge">local.py</code>)</h3><p>The first task is to exploit <code class="language-plaintext highlighter-rouge">target</code> and have it exec a shell. Conveniently, <code class="language-plaintext highlighter-rouge">ROPgadget</code> has constructed such an exploit for us! Look at the bottom of <code class="language-plaintext highlighter-rouge">gadgets.txt</code> (or run <code class="language-plaintext highlighter-rouge">ROPgadget.py</code> with the <code class="language-plaintext highlighter-rouge">--ropchain</code> option).<p>The constructed exploit uses <code class="language-plaintext highlighter-rouge">struct.pack</code> to build a binary string. See the <a href=https://docs.python.org/3/library/struct.html>documentation</a> for details. You’re going to be using this function extensively.<p>Let’s take a look at the first few calls.<div class="language-python highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x0808522a</span><span class=p>)</span> <span class=c1># pop edx ; ret
</span><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x08139060</span><span class=p>)</span> <span class=c1># @ .data
</span><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x080f1016</span><span class=p>)</span> <span class=c1># pop eax ; ret
</span><span class=n>p</span> <span class=o>+=</span> <span class=s>'/bin'</span>
<span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x080c219d</span><span class=p>)</span> <span class=c1># mov dword ptr [edx], eax ; ret
</span></code></pre></div></div><p>Each 4-byte word in the <code class="language-plaintext highlighter-rouge">p</code> string is either the address of code to return to or some data. The first word, <code class="language-plaintext highlighter-rouge">0x0808522a</code> is the address of the instructions <code class="language-plaintext highlighter-rouge">pop edx ; ret</code>, as noted in the comment. When <code class="language-plaintext highlighter-rouge">target</code> returns to this address, it will pop <code class="language-plaintext highlighter-rouge">0x08139060</code> into <code class="language-plaintext highlighter-rouge">edx</code>.<p>But what is that value and what does <code class="language-plaintext highlighter-rouge">@ .data</code> mean? If you run <code class="language-plaintext highlighter-rouge">readelf -S target</code>, you’ll see that the <code class="language-plaintext highlighter-rouge">.data</code> section starts at address <code class="language-plaintext highlighter-rouge">0x08139060</code>. <code class="language-plaintext highlighter-rouge">ROPgadget</code>’s shell code has decided to use <code class="language-plaintext highlighter-rouge">target</code>’s writable data section as a place to write some data. In particular, this will write <code class="language-plaintext highlighter-rouge">/bin</code> at <code class="language-plaintext highlighter-rouge">0x08139060</code>. You’ll want to keep this in mind for some of the other parts.<p>At this point, you should try to figure out what the rest of the code is doing. You can probably get away with not understanding this, but it’ll make the whole rest of the project easier if you figure this out now.<p>One final point about the generated shell code: The final 13 words clear <code class="language-plaintext highlighter-rouge">eax</code>, increment <code class="language-plaintext highlighter-rouge">eax</code> 11 times, and then run <code class="language-plaintext highlighter-rouge">int 0x80</code>. <code class="language-plaintext highlighter-rouge">ROPgadget</code> is avoiding zero-bytes. Since you are using sockets which can handle binary data, this isn’t a concern. Go ahead and replace the <code class="language-plaintext highlighter-rouge">xor</code> and the <code class="language-plaintext highlighter-rouge">inc</code>s with a <code class="language-plaintext highlighter-rouge">pop eax</code>.<p><strong>The code produced by <code class="language-plaintext highlighter-rouge">ROPgadget</code> is designed to work with Python 2. Python 2 has reached its end-of-life. You will be writing Python 3 code. The place where this makes the biggest difference is the difference between <code class="language-plaintext highlighter-rouge">str</code> and <code class="language-plaintext highlighter-rouge">bytes</code>. All of the socket functions expect <code class="language-plaintext highlighter-rouge">bytes</code>. If you write <code class="language-plaintext highlighter-rouge">'/bin'</code>, then you get a string. If you write <code class="language-plaintext highlighter-rouge">b'/bin'</code> then you get <code class="language-plaintext highlighter-rouge">bytes</code>.</strong><p>To complete this task, modify <code class="language-plaintext highlighter-rouge">local.py</code> to:<ol><li>Exploit <code class="language-plaintext highlighter-rouge">target</code> and make it exec <code class="language-plaintext highlighter-rouge">/bin/sh</code> by overwriting the saved <code class="language-plaintext highlighter-rouge">eip</code> and the subsequent words on the stack with this return-oriented program. (Disassembling <code class="language-plaintext highlighter-rouge">target</code> using <code class="language-plaintext highlighter-rouge">objdump -d target</code> can help you figure out where the saved <code class="language-plaintext highlighter-rouge">eip</code> is relative to the start of the array.)</ol><p>To test that everything works, run <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> in one shell and in another shell, run <code class="language-plaintext highlighter-rouge">./local.py &lt;port&gt;</code> (replace <code class="language-plaintext highlighter-rouge">&lt;port&gt;</code> which an actual port number). You should see something like the following.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./target &lt;port&gt;
<span class=nv>$ </span>
</code></pre></div></div><p>Running <code class="language-plaintext highlighter-rouge">strace ./target &lt;port&gt;</code>, with the example above prints out (in part)<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace ./target &lt;port&gt;
...
send(4, "INVALID COMMAND\r\n", 17, 0)   = 17
execve("/bin//sh", [], [/* 0 vars */])  = 0
...
</code></pre></div></div><p><strong>Hint:</strong> You’re going to want to remove essentially all of the skeleton code that is in <code class="language-plaintext highlighter-rouge">local.py</code> (and similarly for the other files). It just exists to show you how to use the socket <code class="language-plaintext highlighter-rouge">api</code>. In particular, you’re not going to want the <code class="language-plaintext highlighter-rouge">send_cmd</code> function, however, the loop for printing results may be useful in <code class="language-plaintext highlighter-rouge">local.py</code> and <code class="language-plaintext highlighter-rouge">secret.py</code>.<h3 id=task-2-dup-shell-duppy>Task 2 Dup shell (<code class="language-plaintext highlighter-rouge">dup.py</code>)</h3><p>The first exploit was fun to do (I hope), but not terribly useful. After all, it opened a shell on the “remote” machine with no way to communicate with it! You’re going to fix that right now.<p>You need to connect <code class="language-plaintext highlighter-rouge">target</code>’s <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, and <code class="language-plaintext highlighter-rouge">stderr</code> to the socket before you exec <code class="language-plaintext highlighter-rouge">/bin/sh</code>. Fortunately, that’s easy to do with the <a href=http://man7.org/linux/man-pages/man2/dup2.2.html title="dup2(2) man page">dup2(2)</a> system call.<p>To make a system call, you need to know what to put in each register. Fortunately, <a href=https://web.archive.org/web/20200620014648/http://syscalls.kernelgrok.com/>kernelgrok</a> is a great resource (the current version of the page appeared to serve malware, so this is an archive.org link to it). Search for <code class="language-plaintext highlighter-rouge">dup2</code> to see what goes in each register.<p>One tricky aspect is you need to put the socket file descriptor in register <code class="language-plaintext highlighter-rouge">ebx</code>, but you can’t know what value to use until the exploit connects. Looking at the disassembly for <code class="language-plaintext highlighter-rouge">target</code>, you’ll see that the return value from <a href=http://man7.org/linux/man-pages/man2/accept.2.html title="accept(2) man page">accept(2)</a> is stored in <code class="language-plaintext highlighter-rouge">ebx</code> in <code class="language-plaintext highlighter-rouge">main</code> and also on the stack just above the saved <code class="language-plaintext highlighter-rouge">eip</code> as the first argument to <code class="language-plaintext highlighter-rouge">handle_connection</code>. Unfortunately, you’re going to trash the saved <code class="language-plaintext highlighter-rouge">ebx</code> as well as the argument. All hope is not lost, run <code class="language-plaintext highlighter-rouge">target</code> in <code class="language-plaintext highlighter-rouge">gdb</code> and break near the end of <code class="language-plaintext highlighter-rouge">handle_connection</code>. Luckily, the socket file descriptor is available! (<strong>Hint: Look at the values in the registers using <code class="language-plaintext highlighter-rouge">(gdb) info reg</code>.</strong>)<p>In essence, you want to get the socket file descriptor that was returned from <a href=http://man7.org/linux/man-pages/man2/accept.2.html title="accept(2) man page">accept(2)</a> in <code class="language-plaintext highlighter-rouge">target</code>—call it <code class="language-plaintext highlighter-rouge">sock</code>—and make the three system calls that correspond to<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>dup2</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=n>dup2</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
<span class=n>dup2</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</code></pre></div></div><p>and then exec <code class="language-plaintext highlighter-rouge">/bin/sh</code> as you did in <code class="language-plaintext highlighter-rouge">local.py</code>.<p>To complete this task, modify <code class="language-plaintext highlighter-rouge">dup.py</code> to:<ol><li>Exploit <code class="language-plaintext highlighter-rouge">target</code> and have it perform the <a href=http://man7.org/linux/man-pages/man2/dup2.2.html title="dup2(2) man page">dup2(2)</a> system calls and exec the shell as described above;<li>Read from <code class="language-plaintext highlighter-rouge">stdin</code> and write to the socket and read from the socket and write to <code class="language-plaintext highlighter-rouge">stdout</code>. You may find the <code class="language-plaintext highlighter-rouge">console</code> function in <code class="language-plaintext highlighter-rouge">console.py</code> useful for this task. Simply import the function using <code class="language-plaintext highlighter-rouge">from console import console</code>, pass the socket to <code class="language-plaintext highlighter-rouge">console</code>, and it should take care of everything. The prompt will not appear, but you can still enter commands and see the result.</ol><p>To test that everything works, run <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> in one shell and in another shell, run<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./dup.py &lt;port&gt;.
INVALID COMMAND
<span class=nb>date
</span>Sun Oct 16 03:28:26 CDT 2016
<span class=nb>exit</span>
</code></pre></div></div><p>Running <code class="language-plaintext highlighter-rouge">strace ./target</code> as described in the hints, with the example above prints out (in part).<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace ./target &lt;port&gt;
...
send(4, "INVALID COMMAND\r\n", 17, 0)   = 17
dup2(4, 0)                              = 0
dup2(4, 1)                              = 1
dup2(4, 2)                              = 2
execve("/bin//sh", [], [/* 3 vars */])  = 0
...
read(0, "date\n", 8192)                 = 5
...
read(0, "exit\n", 8192)                 = 5
...
</code></pre></div></div><h3 id=task-3-reverse-shell-reversepy>Task 3 Reverse shell (<code class="language-plaintext highlighter-rouge">reverse.py</code>)</h3><p>The exploit used in <code class="language-plaintext highlighter-rouge">dup.py</code> connected the shell to the socket we used to connect to <code class="language-plaintext highlighter-rouge">target</code> initially. For this task, the exploit will cause <code class="language-plaintext highlighter-rouge">target</code> to make a connection to remote server, connect the resultant socket to <code class="language-plaintext highlighter-rouge">stdin</code>/<code class="language-plaintext highlighter-rouge">stdout</code>/<code class="language-plaintext highlighter-rouge">stderr</code> (as was done in <code class="language-plaintext highlighter-rouge">dup.py</code>), and exec a shell.<p>Creating a new socket and making a connection involves making several system calls.<ul><li><a href=http://man7.org/linux/man-pages/man2/socket.2.html title="socket(2) man page">socket(2)</a><li><a href=http://man7.org/linux/man-pages/man2/connect.2.html title="connect(2) man page">connect(2)</a></ul><p>There are several ways to call these functions. Since they appear in <code class="language-plaintext highlighter-rouge">target</code>, it’s possible to return to them with the arguments on the stack. However, the first argument to <a href=http://man7.org/linux/man-pages/man2/connect.2.html title="connect(2) man page">connect(2)</a> is the return value from the <a href=http://man7.org/linux/man-pages/man2/socket.2.html title="socket(2) man page">socket(2)</a> which makes making returning to the libc implementations difficult. Instead, you should make the corresponding system calls directly; just as you did with <a href=http://man7.org/linux/man-pages/man2/dup2.2.html title="dup2(2) man page">dup2(2)</a>.<p>See the associated manual pages for example usage and see the hints below for suggestions on making these system calls. And see the example below for the arguments to the system calls.<p>The connection should be to <code class="language-plaintext highlighter-rouge">127.0.0.1</code> and the port should be specified as an argument to <code class="language-plaintext highlighter-rouge">reverse.py</code> (see example below).<p>To complete this task, modify <code class="language-plaintext highlighter-rouge">reverse.py</code> to:<ol><li>Open a socket to listen on <code class="language-plaintext highlighter-rouge">127.0.0.1</code> with the port specified as a command line parameter to <code class="language-plaintext highlighter-rouge">reverse.py</code> (see example below).<li>Exploit <code class="language-plaintext highlighter-rouge">target</code> and have it make a new connection to <code class="language-plaintext highlighter-rouge">127.0.0.1</code> with the same port used in step 1. Once connected, <code class="language-plaintext highlighter-rouge">target</code> should exec a shell with <code class="language-plaintext highlighter-rouge">stdin</code>/<code class="language-plaintext highlighter-rouge">stdout</code>/<code class="language-plaintext highlighter-rouge">stderr</code> connected to the new socket.<li>Read from <code class="language-plaintext highlighter-rouge">stdin</code> and write to the newly opened socket and read from the socket and write to <code class="language-plaintext highlighter-rouge">stdout</code>. Again, the <code class="language-plaintext highlighter-rouge">console</code> function may be helpful.</ol><p>To test that everything works, run <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> in one shell and in another shell, run<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./reverse.py &lt;port&gt; &lt;connect_port&gt;.
INVALID COMMAND
<span class=nb>date
</span>Sun Oct 16 03:47:33 CDT 2016
<span class=nb>exit</span>
</code></pre></div></div><p>Running <code class="language-plaintext highlighter-rouge">strace ./target &lt;port&gt;</code>, with the example above prints out (in part)<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace ./target &lt;port&gt;
...
send(4, "INVALID COMMAND\r\n", 17, 0)   = 17
socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 5
connect(5, {sa_family=AF_INET, sin_port=htons(&lt;connect_port&gt;), sin_addr=inet_addr("127.0.0.1")}, 16) = 0
dup2(5, 0)                              = 0
dup2(5, 1)                              = 1
dup2(5, 2)                              = 2
execve("/bin//sh", [], [/* 6 vars */])  = 0
...
read(0, "date\n", 8192)                 = 5
...
read(0, "exit\n", 8192)                 = 5
...
</code></pre></div></div><h3 id=task-4-bind-shell-bindpy>Task 4 Bind shell (<code class="language-plaintext highlighter-rouge">bind.py</code>)</h3><p>The exploit used in <code class="language-plaintext highlighter-rouge">dup.py</code> connected the shell to the socket we used to connect to <code class="language-plaintext highlighter-rouge">target</code> initially; the exploit used in <code class="language-plaintext highlighter-rouge">reverse.py</code> made a connection back to the attacker. For this task, the exploit will cause <code class="language-plaintext highlighter-rouge">target</code> to start listening on a specified port and when a connection happens, connect <code class="language-plaintext highlighter-rouge">stdin</code>/<code class="language-plaintext highlighter-rouge">stdout</code>/<code class="language-plaintext highlighter-rouge">stderr</code> to the newly connected socket and exec a shell. This is called a <em>bind shell</em>.<p>Listening on a port and accepting new connections involves making several system calls.<ul><li><a href=http://man7.org/linux/man-pages/man2/socket.2.html title="socket(2) man page">socket(2)</a><li><a href=http://man7.org/linux/man-pages/man2/bind.2.html title="bind(2) man page">bind(2)</a><li><a href=http://man7.org/linux/man-pages/man2/listen.2.html title="listen(2) man page">listen(2)</a><li><a href=http://man7.org/linux/man-pages/man2/accept.2.html title="accept(2) man page">accept(2)</a></ul><p>As was the case for <code class="language-plaintext highlighter-rouge">reverse.py</code>, there are several ways to call these functions. Since they’re used in <code class="language-plaintext highlighter-rouge">target</code>, it’s possible to return to them with the arguments on the stack. However, the first argument to each of the last three require system calls requires the return value from the first which makes making returning to the libc implementations more difficult. Instead, you should make the corresponding system calls directly.<p>See <code class="language-plaintext highlighter-rouge">target.c</code> and the associated manual pages for example usage and see the hints below for suggestions on making these system calls. And see the example below for the arguments to the system calls.<p><strong>Note that the <a href=http://man7.org/linux/man-pages/man2/bind.2.html title="bind(2) man page">bind(2)</a> call <em>must</em> bind the socket to address <code class="language-plaintext highlighter-rouge">127.0.0.1</code> as mentioned in the warning above.</strong><p>To complete this task, modify <code class="language-plaintext highlighter-rouge">bind.py</code> to:<ol><li>Exploit <code class="language-plaintext highlighter-rouge">target</code> and have it listen for a new connection on a different port (specified as a command line parameter to <code class="language-plaintext highlighter-rouge">bind.py</code>—see example below). Once a connection happens, <code class="language-plaintext highlighter-rouge">target</code> should exec a shell with <code class="language-plaintext highlighter-rouge">stdin</code>/<code class="language-plaintext highlighter-rouge">stdout</code>/<code class="language-plaintext highlighter-rouge">stderr</code> connected to the socket.<li>Make a new connection to <code class="language-plaintext highlighter-rouge">127.0.0.1:&lt;listen_port&gt;</code> where <code class="language-plaintext highlighter-rouge">&lt;listen_port&gt;</code> is the port specified as the second command line parameter (see example).<li>Read from <code class="language-plaintext highlighter-rouge">stdin</code> and write to the newly opened socket and read from the socket and write to <code class="language-plaintext highlighter-rouge">stdout</code>. Again, the <code class="language-plaintext highlighter-rouge">console</code> function may be helpful.</ol><p>To test that everything works, run <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> in one shell and in another shell, run<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./bind.py &lt;port&gt; &lt;listen_port&gt;.
INVALID COMMAND
<span class=nb>date
</span>Sun Oct 16 03:47:33 CDT 2016
<span class=nb>exit</span>
</code></pre></div></div><p>Running <code class="language-plaintext highlighter-rouge">strace ./target &lt;port&gt;</code>, with the example above prints out (in part)<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace ./target &lt;port&gt;
...
send(4, "INVALID COMMAND\r\n", 17, 0)   = 17
socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 5
bind(5, {sa_family=AF_INET, sin_port=htons(&lt;listen_port&gt;), sin_addr=inet_addr("127.0.0.1")}, 16) = 0
listen(5, 135499884)                    = 0
accept(5, 0, NULL)                      = 6
dup2(6, 0)                              = 0
dup2(6, 1)                              = 1
dup2(6, 2)                              = 2
execve("/bin//sh", [], [/* 3 vars */])  = 0
...
read(0, "date\n", 8192)                 = 5
...
read(0, "exit\n", 8192)                 = 5
...
</code></pre></div></div><h3 id=task-5-data-exfiltration-secretpy>Task 5 Data exfiltration (<code class="language-plaintext highlighter-rouge">secret.py</code>)</h3><p>The final task is to convince <code class="language-plaintext highlighter-rouge">target</code> to write its secret to the socket without knowing the password. No need to get a shell this time.<p>It’s possible to write to a socket using <a href=http://man7.org/linux/man-pages/man2/send.2.html title="send(2) man page">send(2)</a> or <a href=http://man7.org/linux/man-pages/man2/write.2.html title="write(2) man page">write(2)</a>. As such, there are several possible approaches that one could take: (1) return to the <code class="language-plaintext highlighter-rouge">__libc_send</code> function, (2) return to the <code class="language-plaintext highlighter-rouge">__libc_write</code> function, (3) make a <a href=http://man7.org/linux/man-pages/man2/send.2.html title="send(2) man page">send(2)</a> system call, or (4) make a <a href=http://man7.org/linux/man-pages/man2/write.2.html title="write(2) man page">write(2)</a> system call. Each approach requires passing the socket file descriptor. Since the file descriptor is not constant, returning to the <code class="language-plaintext highlighter-rouge">__libc_send</code> or <code class="language-plaintext highlighter-rouge">__libc_write</code> functions is actually more difficult than making a system call. As you’ve seen, making socket system calls is more complicated than other system calls, so go with approach (4).<p>You also need to know how much data to write. To do this, you’re going to need to implement a return-oriented loop. This is easily the most complicated part of writing a return-oriented program. There are many ways that one could implement it. The method I used was to implement the following <code class="language-plaintext highlighter-rouge">StringLength</code> gadget:<ol><li>Set <code class="language-plaintext highlighter-rouge">edi</code> to <code class="language-plaintext highlighter-rouge">0xffffffff</code>.<li>Set <code class="language-plaintext highlighter-rouge">esi</code> to point to a <code class="language-plaintext highlighter-rouge">0</code> byte. (I set <code class="language-plaintext highlighter-rouge">esi</code> to point to <code class="language-plaintext highlighter-rouge">.data</code> and wrote a <code class="language-plaintext highlighter-rouge">0</code> there.)<li>Set <code class="language-plaintext highlighter-rouge">ecx</code> to point to the start of the <code class="language-plaintext highlighter-rouge">secret</code> array.<li>Set <code class="language-plaintext highlighter-rouge">edx</code> to the number of bytes to conditionally move the stack pointer to start the next iteration of the loop (this should be a negative number).<li>Use <code class="language-plaintext highlighter-rouge">edi</code> as the length counter and <code class="language-plaintext highlighter-rouge">ecx</code> as a pointer to the next byte to test.<li>Use <code class="language-plaintext highlighter-rouge">eax</code> and <code class="language-plaintext highlighter-rouge">ebp</code> as scratch registers to perform the conditional update of <code class="language-plaintext highlighter-rouge">esp</code>.<li>After a short setup, the body of the loop increments the <code class="language-plaintext highlighter-rouge">ecx</code> pointer and <code class="language-plaintext highlighter-rouge">edi</code> length, compares the byte pointed to by <code class="language-plaintext highlighter-rouge">ecx</code> to 0, and if it is nonzero, branch back to the top of the loop by updating <code class="language-plaintext highlighter-rouge">esp</code>.<li>After the loop exits, <code class="language-plaintext highlighter-rouge">edi</code> holds the length of the string.</ol><p>The sequences of code I used to implement step 6 of the <code class="language-plaintext highlighter-rouge">StringLength</code> gadget (organized by functionality, not order in which I used them) were<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code># Increment/decrement pointer and length.
0x080545a1 # dec ecx ; ret
0x0807703f # inc ecx ; mov ebp, 0xa0b80810 ; ret
0x0808d7c5 # inc edi ; ret

# Compare to 0.
0x08048ac1 # xor eax, eax ; ret
0x08127ded # cmp byte ptr [ecx], al ; ret

# Conditional update of esp.
0x0808522a # pop edx ; ret
0x0809c909 # cmovne eax, edx ; ret
0x080485f4 # pop ebp ; ret
0x0807c05f # add ebp, eax ; retf
0x0812c918 # add esp, ebp ; add cl, byte ptr [esi] ; adc al, 0x43 ; ret
</code></pre></div></div><p>There a few things to notice about these code sequences.<ul><li><code class="language-plaintext highlighter-rouge">cmovene eax, edx</code> is a conditional move from <code class="language-plaintext highlighter-rouge">edx</code> to <code class="language-plaintext highlighter-rouge">eax</code>. See the <a href=http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf title="Intel 64 and IA-32 architectures software developer's manual">Intel manual</a> for details.<li><p><code class="language-plaintext highlighter-rouge">retf</code> is a far return. The <a href=http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf title="Intel 64 and IA-32 architectures software developer's manual">Intel manual</a> has the complete details, but in short, it will pop two words off the stack. The first will go into <code class="language-plaintext highlighter-rouge">eip</code> and the second into the <code class="language-plaintext highlighter-rouge">cs</code> segment register. You should use <code class="language-plaintext highlighter-rouge">0x00000023</code> as the value for <code class="language-plaintext highlighter-rouge">cs</code>. In other words, if you want to use <code class="language-plaintext highlighter-rouge">add ebp, eax ; retf</code> followed by, for example, <code class="language-plaintext highlighter-rouge">pop edx ; ret</code>, you should use<div class="language-python highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x0807c05f</span><span class=p>)</span> <span class=c1># add ebp, eax ; retf
</span><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x0808522a</span><span class=p>)</span> <span class=c1># pop edx ; ret
</span><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0x00000023</span><span class=p>)</span> <span class=c1># cs
</span><span class=n>p</span> <span class=o>+=</span> <span class=n>pack</span><span class=p>(</span><span class=s>'&lt;I'</span><span class=p>,</span> <span class=mh>0xdeadbeef</span><span class=p>)</span> <span class=c1># edx = 0xdeadbeef
</span></code></pre></div></div><li><code class="language-plaintext highlighter-rouge">add esp, ebp ; add cl, byte ptr [esi] ; adc al, 0x43 ; ret</code> modifies <code class="language-plaintext highlighter-rouge">ecx</code> unless you set <code class="language-plaintext highlighter-rouge">esi</code> to point to a <code class="language-plaintext highlighter-rouge">0</code> byte as mentioned in step 2, above.<li>None of those code sequences use <code class="language-plaintext highlighter-rouge">ebx</code>. Conveniently, <code class="language-plaintext highlighter-rouge">ebx</code> is the file descriptor argument for <a href=http://man7.org/linux/man-pages/man2/write.2.html title="write(2) man page">write(2)</a>. So if you first move the socket file descriptor into <code class="language-plaintext highlighter-rouge">ebx</code>, you can compute the length without disturbing it.</ul><p>To complete this task, modify <code class="language-plaintext highlighter-rouge">secret.py</code> to:<ol><li>Exploit <code class="language-plaintext highlighter-rouge">target</code> and have it write the secret value to the socket by making a <a href=http://man7.org/linux/man-pages/man2/write.2.html title="write(2) man page">write(2)</a> system call. Afterward, exit cleanly by making an <code class="language-plaintext highlighter-rouge">exit</code> system call with return value 0. (See the hints below for suggestions on making multiple system calls.)<li>Read the secret from the socket and print it out. (The secret won’t have a newline, so you’ll probably want to add that yourself.)</ol><p>You may assume that a secret has been set.<p>To test that everything works, run <code class="language-plaintext highlighter-rouge">./target &lt;port&gt;</code> in one shell and in another shell, run<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span><span class=nb>echo</span> <span class=s1>'PUT SECRET password1 Secret value!'</span> | nc <span class=nt>-C</span> 127.0.0.1 &lt;port&gt;
SECRET STORED
<span class=nv>$ </span>./secret.py &lt;port&gt;.
INVALID COMMAND
Secret value!
</code></pre></div></div><p>Running <code class="language-plaintext highlighter-rouge">strace ./target &lt;port&gt;</code>, with the example above prints out (in part)<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace ./target &lt;port&gt;
...
accept(3, 0, NULL)                      = 4
recv(4, "PUT SECRET password1 Secret valu"..., 1024, 0) = 36
send(4, "SECRET STORED\r\n", 15, 0)     = 15
close(4)                                = 0
accept(3, 0, NULL)                      = 4
...
send(4, "INVALID COMMAND\r\n", 17, 0)   = 17
write(4, "Secret value!", 13)           = 13
_exit(0)                                = ?
</code></pre></div></div><h2 id=hints>Hints</h2><ul><li>To disassemble <code class="language-plaintext highlighter-rouge">target</code>, use <code class="language-plaintext highlighter-rouge">objdump -d target</code>.<li><code class="language-plaintext highlighter-rouge">ROPgadget</code> is handy, but a little limited. In particular, starting with the second task, you’ll need to make multiple system calls. The <code class="language-plaintext highlighter-rouge">int 0x80</code> gadget <code class="language-plaintext highlighter-rouge">ROPgadget</code> finds probably won’t work for you.<li><a href=http://man7.org/linux/man-pages/man1/strace.1.html title="strace(1) man page">strace(1)</a> is an invaluable tool. Use it to run <code class="language-plaintext highlighter-rouge">target</code> to see what system call arguments you’re passing.<li>The socket-related system calls all use the same system call number <code class="language-plaintext highlighter-rouge">sys_socketcall</code>. As described on <a href=http://syscalls.kernelgrok.com/>kernelgrok</a>, <code class="language-plaintext highlighter-rouge">eax</code> is set to <code class="language-plaintext highlighter-rouge">0x66</code>. <code class="language-plaintext highlighter-rouge">ebx</code> is set to the actual socket call you want to make. See the <del>kernel source</del> for the possible values. Lastly, <code class="language-plaintext highlighter-rouge">ecx</code> points to an array of the arguments to pass.<li>Multiple calls to <a href=http://man7.org/linux/man-pages/man2/send.2.html title="send(2) man page">send(2)</a> can be received by a single call to <a href=http://man7.org/linux/man-pages/man2/recv.2.html title="recv(2) man page">recv(2)</a>. If that’s not what you want, put a small delay between send calls.<li>Start early!</ul><h2 id=deliverables>Deliverables</h2><ul><li>You must include a file called <code class="language-plaintext highlighter-rouge">ID</code> which contains the names of all partners (or just your own if you worked by yourself).</ul></main>