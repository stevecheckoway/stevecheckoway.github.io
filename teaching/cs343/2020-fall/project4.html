<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Project 4: Crypto Fun</title><meta name=description content="Project 4: Crypto Fun"> <link rel=canonical href=https://checkoway.net/teaching/cs343/2020-fall/project4.html> <link rel=stylesheet href=/css/main.css><main><h1 id=project-4-crypto-fun>Project 4: Crypto Fun</h1><p><strong>Due:</strong> 2020-12-07 23:59<h2 id=goal>Goal</h2><p>The goal of this project is to learn about some crypto basics.<h2 id=collaboration>Collaboration</h2><p>You may work on this project in collaboration with a single partner as described on the main page.<p>You must not discuss the project with anyone other than your partner and course staff. You may use online resources for general reference, but not to search for solutions to specific questions posed in this project.<h2 id=the-assignment-repository>The Assignment Repository</h2><p>Go to the <a href=https://classroom.github.com/g/xm3Es7wT>GitHub Classroom page</a> and accept the assignment.<ul><li>If you are working by yourself, create a new team (you can name it whatever you like).<li>If you are working with a partner (which I recommend), one of you should create a new team and the other should join the team.</ul><p><strong>Warning: Do not join any team other than your partner’s. There’s no way to change teams for the assignment so just don’t do it! (If you do join the wrong team by mistake, let me know immediately.)</strong><p>You should now be able to clone the assignment repository on <code class="language-plaintext highlighter-rouge">hacker</code>.<h2 id=the-environment>The Environment</h2><p>Your Python 3 code should run on hacker.cs.oberlin.edu.<h2 id=the-assignment>The Assignment</h2><p>There are three parts for this assignment.<ol><li><p>SHA-256. Implement SHA-256 in <code class="language-plaintext highlighter-rouge">sha256.py</code>. You should look at the <a href=https://en.wikipedia.org/wiki/SHA-2#Pseudocode>pseudocode on Wikipedia</a> for the algorithm. Your program should take a single string as an argument and print the SHA-256 hash of the string as a sequence of hex characters followed by a newline and nothing else.<p>You must implement the algorithm itself. You may <em>not</em> use a library (e.g., Python’s standard <code class="language-plaintext highlighter-rouge">hashlib</code>) or an external program to perform the computation for you. To check your answer, you can <code class="language-plaintext highlighter-rouge">echo -n</code> a string and pipe it to <code class="language-plaintext highlighter-rouge">sha256sum</code>.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./sha256.py <span class=s1>'Crypto is complicated'</span>
b13ec1838eada3f2908c144f54ead46cf76277b6e0afa847763f7f5cdd610222
<span class=nv>$ </span><span class=nb>echo</span> <span class=nt>-n</span> <span class=s1>'Crypto is complicated'</span> | <span class=nb>sha256sum
</span>b13ec1838eada3f2908c144f54ead46cf76277b6e0afa847763f7f5cdd610222  -
</code></pre></div></div><p>To make part 2 of the assignment easier, I recommend implementing SHA-256 by making use of several helper functions <code class="language-plaintext highlighter-rouge">pad_message</code> which takes a <a href=https://docs.python.org/3/glossary.html#term-bytes-like-object>bytes-like object</a> and returns a properly padded copy of it and <code class="language-plaintext highlighter-rouge">process_chunk</code> which updates the internal state after processing a 512-bit chunk. (See the pseudocode for the chunk processing.)<p>In my implementation, I implemented functions <code class="language-plaintext highlighter-rouge">rotate_right</code>, <code class="language-plaintext highlighter-rouge">round_sum</code>, <code class="language-plaintext highlighter-rouge">extend_sum</code>, <code class="language-plaintext highlighter-rouge">choose</code>, <code class="language-plaintext highlighter-rouge">majority</code>, <code class="language-plaintext highlighter-rouge">pad_message</code>, <code class="language-plaintext highlighter-rouge">process_chunk</code>, <code class="language-plaintext highlighter-rouge">hexdigest</code>, and <code class="language-plaintext highlighter-rouge">sha256</code>. The first seven of those implement various parts of the psuedocode. <code class="language-plaintext highlighter-rouge">hexdigest</code>, given in the starter code, takes a list of 8 integers and formats them as a hex string. You’ll likely want to use this in part 2 as well. <code class="language-plaintext highlighter-rouge">sha256</code> takes a bytes-like object and produces the full hash.<li><p>MAC forgery. In this part, you are going to produce a MAC forgery. The provided <code class="language-plaintext highlighter-rouge">badmac.py</code> file implements a simple (and bad) message authentication code, <code class="language-plaintext highlighter-rouge">BADMAC(key, msg) = SHA-256(key || msg)</code>.<p>Your task is to write a function <code class="language-plaintext highlighter-rouge">create_forgery(oracle)</code> in <code class="language-plaintext highlighter-rouge">forger.py</code>. The one argument, <code class="language-plaintext highlighter-rouge">oracle</code>, can be called as <code class="language-plaintext highlighter-rouge">oracle(msg)</code> to create a MAC for the <code class="language-plaintext highlighter-rouge">msg</code> argument. You may query the oracle as many times as you wish, passing whatever messages you want and getting their corresponding MACs. Afterward, you need to return a pair <code class="language-plaintext highlighter-rouge">(msg, mac)</code> where <code class="language-plaintext highlighter-rouge">msg</code> has <em>not</em> been used as a parameter to <code class="language-plaintext highlighter-rouge">oracle</code> and <code class="language-plaintext highlighter-rouge">mac</code> is a valid MAC (represented as a lowercase hex string) for <code class="language-plaintext highlighter-rouge">msg</code>. That is, <code class="language-plaintext highlighter-rouge">oracle(msg) == mac</code> must be <code class="language-plaintext highlighter-rouge">True</code>.<p>Running <code class="language-plaintext highlighter-rouge">./badmac.py</code> will call your <code class="language-plaintext highlighter-rouge">create_forgery</code> function and pass it an oracle containing a random 16-byte key. After the function returns, it will print out some information. Here is an example (with the forged string redacted).<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ ./badmac.py
Made 10 distinct oracle call(s)
Key:        5ac68d18f108467317aa7b2e220e2467
Forgery:    '&lt;redacted&gt;'
Forged MAC: dc6f61981bba914df332f8225e18a415cd668812208cd2baa8be0c304cd9d070
MAC:        dc6f61981bba914df332f8225e18a415cd668812208cd2baa8be0c304cd9d070
Success
</code></pre></div></div><p>You can produce a successful forgery using fewer than 10 calls to the oracle, but you’re unlikely to be successful if you make zero calls.<p>The <code class="language-plaintext highlighter-rouge">create_forgery</code> function must not write anything to the terminal or to a file, nor read any files, nor make any attempt to extract the key from the <code class="language-plaintext highlighter-rouge">oracle</code> or in any other object.<p>Hint: Think about the way SHA-256 works by processing one chunk at a time. <code class="language-plaintext highlighter-rouge">BADMAC(key, msg)</code> is going to concatenate the 16-byte key with the message and hash that. SHA-256 is going to pad that out until the whole thing is a multiple of 64-bytes (512-bits). Starting with the <code class="language-plaintext highlighter-rouge">md</code> list set to the initialization vector, SHA-256 is going to process each 64-byte chunk in order, updating <code class="language-plaintext highlighter-rouge">md</code> after each one. The final hash value is what you get from concatenating the 8 elements of <code class="language-plaintext highlighter-rouge">md</code>. If we view the output of the oracle call as <code class="language-plaintext highlighter-rouge">md</code> (that is, convert from a hex string to a list of 8 integers), you can process additional chunks.<li><p>MD5 collision. Creating an MD5 collision is now a fast process. Your task is to create a pair of Python files, <code class="language-plaintext highlighter-rouge">hello.py</code> and <code class="language-plaintext highlighter-rouge">goodbye.py</code>, that have the same MD5 hash but when run produce different output. <code class="language-plaintext highlighter-rouge">hello.py</code> should print <code class="language-plaintext highlighter-rouge">Hello!</code> and <code class="language-plaintext highlighter-rouge">goodbye.py</code> should print <code class="language-plaintext highlighter-rouge">Goodbye!</code>. The two programs must not rely on their names or any aspect of their environment (including the presence or absence of files) to have different behavior.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ md5sum hello.py goodbye.py
1721ab6cb96d9e43ce0e96486f898754  hello.py
1721ab6cb96d9e43ce0e96486f898754  goodbye.py
$ sha256sum hello.py goodbye.py
b48f689c3a79f64c0924be53117bc074a4c1987fb7705de4c0b4c895b6c495af  hello.py
cc5169383251dafc9319ce73d161854a2d79379db24a900b3ede95d7d25d1460  goodbye.py
$ ./hello.py
Hello!
$ ./goodbye.py
Goodbye!
</code></pre></div></div><p>Your MD5 and SHA-256 hashes will be different from mine.<p>To produce these files, clone the <a href=https://github.com/oberlin-security/clone-fastcoll>oberlin-security/clone-fastcoll</a> repository and build the code by typing <code class="language-plaintext highlighter-rouge">make</code>. You should not check this code in to your repository. The resulting <code class="language-plaintext highlighter-rouge">fastcoll</code> program takes the path of a file as an argument and produces two files <code class="language-plaintext highlighter-rouge">md5_data1</code> and <code class="language-plaintext highlighter-rouge">md5_data2</code> that have the same MD5 hash and both have the contents of the file as a prefix.<p>For example, given a file <code class="language-plaintext highlighter-rouge">prefix</code> containing the single line “CS 343”, running <code class="language-plaintext highlighter-rouge">fastcoll prefix</code> will produce two different files with the same MD5 hash.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ echo 'CS 343' &gt; prefix
$ ./fastcoll prefix
Generating first block: ..........
Generating second block: S01.......
use 'md5sum md5_data*' check MD5
$ md5sum md5_data?
adb00d1dfed84f8aba5304fb51d5e8c7  md5_data1
adb00d1dfed84f8aba5304fb51d5e8c7  md5_data2
$ xxd md5_data1
00000000: 4353 2033 3433 0a00 0000 0000 0000 0000  CS 343..........
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: ffe0 4306 16f9 0e44 f2bc 03fb 92c8 2ad4  ..C....D......*.
00000050: 5974 8677 09ee e705 1b4e 8279 1654 bdf2  Yt.w.....N.y.T..
00000060: 0dad b8c0 6e0a 0a48 eb5b 57d9 2d74 640c  ....n..H.[W.-td.
00000070: 536b 1d04 a507 165d 6a20 92a7 0148 75e0  Sk.....]j ...Hu.
00000080: ad16 4013 e889 0bc3 185b c595 7b69 bf4e  ..@......[..{i.N
00000090: 2c0c 0053 17e6 0e5e cb1a f63d ec46 fe65  ,..S...^...=.F.e
000000a0: d85b a656 02cb 0200 ba2b 4057 78ec 6ae6  .[.V.....+@Wx.j.
000000b0: ff7e e6bd c438 ef96 571d 4927 757f fc03  .~...8..W.I'u...
$ xxd md5_data2
00000000: 4353 2033 3433 0a00 0000 0000 0000 0000  CS 343..........
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: ffe0 4306 16f9 0e44 f2bc 03fb 92c8 2ad4  ..C....D......*.
00000050: 5974 86f7 09ee e705 1b4e 8279 1654 bdf2  Yt.......N.y.T..
00000060: 0dad b8c0 6e0a 0a48 eb5b 57d9 2df4 640c  ....n..H.[W.-.d.
00000070: 536b 1d04 a507 165d 6a20 9227 0148 75e0  Sk.....]j .'.Hu.
00000080: ad16 4013 e889 0bc3 185b c595 7b69 bf4e  ..@......[..{i.N
00000090: 2c0c 00d3 17e6 0e5e cb1a f63d ec46 fe65  ,......^...=.F.e
000000a0: d85b a656 02cb 0200 ba2b 4057 786c 6ae6  .[.V.....+@Wxlj.
000000b0: ff7e e6bd c438 ef96 571d 49a7 757f fc03  .~...8..W.I.u...
</code></pre></div></div><p>If you look closely at the contents of the two files, you can see that they are different but both start with <code class="language-plaintext highlighter-rouge">4353 2033 3433 0a</code> which is <code class="language-plaintext highlighter-rouge">CS 343</code> followed by a new line.<p>One thing that stands out is that there’s a bunch of binary data which is going to be a little hard to incorporate into a Python program. Fortunately, you can tell Python that a source file has a particular character encoding by including a magic comment at the top of the file. Then you can constrain all of this binary data in a Python string.<p>Start by creating a file named <code class="language-plaintext highlighter-rouge">prefix</code> containing the following four lines.<div class="language-python highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>#!/usr/bin/env python3
# coding: iso-8859-1
</span>   
<span class=n>MSG</span> <span class=o>=</span> <span class=nb>bytes</span><span class=p>(</span><span class=sa>r</span><span class=s>"""
</span></code></pre></div></div><p>Next, run <code class="language-plaintext highlighter-rouge">fastcoll</code> on this file producing <code class="language-plaintext highlighter-rouge">md5_data1</code> and <code class="language-plaintext highlighter-rouge">md5_data2</code>.<p>Next, create a file named <code class="language-plaintext highlighter-rouge">suffix</code> that starts with the following two lines. (The first line is blank.)<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>   
""", 'iso-8859-1')
</code></pre></div></div><p>Finally, if you run the two commands<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span><span class=nb>cat </span>md5_data1 suffix <span class=o>&gt;</span> hello.py
<span class=nv>$ </span><span class=nb>cat </span>md5_data2 suffix <span class=o>&gt;</span> goodbye.py
</code></pre></div></div><p>this will create two files <code class="language-plaintext highlighter-rouge">hello.py</code> and <code class="language-plaintext highlighter-rouge">goodbye.py</code> that start with the contents of <code class="language-plaintext highlighter-rouge">prefix</code> and end with the context of <code class="language-plaintext highlighter-rouge">suffix</code>. In between, the two files will differ. The last line of <code class="language-plaintext highlighter-rouge">prefix</code> is creating a <code class="language-plaintext highlighter-rouge">bytes</code> object from the bytes generated by <code class="language-plaintext highlighter-rouge">fastcoll</code>. The two lines at the beginning of <code class="language-plaintext highlighter-rouge">suffix</code> are ending the creating of that object and telling Python create the <code class="language-plaintext highlighter-rouge">bytes</code> by encoding its argument using <a href=https://en.wikipedia.org/wiki/ISO/IEC_8859-1>ISO 8859-1</a>.<p>Now, you can change the contents of <code class="language-plaintext highlighter-rouge">suffix</code> and re-run the <code class="language-plaintext highlighter-rouge">cat</code> commands such that you get the required behavior of printing the two strings.<p>You’ll want to make the two python files executable.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span><span class=nb>chmod</span> +x hello.py goodbye.py
</code></pre></div></div><p>Make sure you add and commit <code class="language-plaintext highlighter-rouge">prefix</code>, <code class="language-plaintext highlighter-rouge">suffix</code>, <code class="language-plaintext highlighter-rouge">hello.py</code>, and <code class="language-plaintext highlighter-rouge">goodbye.py</code> to your repository.<p>You should not include <code class="language-plaintext highlighter-rouge">md5_data1</code> or <code class="language-plaintext highlighter-rouge">md5_data2</code> in your repository.</ol><h2 id=deliverables>Deliverables</h2><ul><li>You must include a file called <code class="language-plaintext highlighter-rouge">ID</code> which contains the names of all partners (or just your own if you worked by yourself).</ul></main>