<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Project 1: Memory Safety</title><meta name=description content="Project 1: Memory Safety"> <link rel=canonical href=https://checkoway.net/teaching/cs487/2017-fall/project1.html> <link rel=stylesheet href=/css/main.css> <script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-34500030-2","auto"),ga("send","pageview");</script><main><h1 id=project-1-memory-safety>Project 1: Memory Safety</h1><p><strong>Due:</strong> Friday, September 29, 2017, 23:59<h2 id=goal>Goal</h2><p>The goal of this assignment is to gain hands-on experience with the effect of buffer overflows and other memory-safety bugs.<p>All work in this project must be done in the QEMU virtual machine provided on the course website; see below for information about this environment.<p>You are given, in the <code class=highlighter-rouge>targets</code> directory, the source code for six exploitable programs, <code class=highlighter-rouge>target1</code>, …, <code class=highlighter-rouge>target6</code>. These programs are to be compiled and installed, setuid root, in the <code class=highlighter-rouge>/tmp</code> directory of your VM. Your goal is to write six exploit programs <code class=highlighter-rouge>sploit1</code>, …, <code class=highlighter-rouge>sploit6</code>, each of which will execute the corresponding target with input that exploits that target’s bug, giving a root shell on the VM.<p>In fact, you are not given a fixed set of targets. Instead, the targets will be generated from an <code class=highlighter-rouge>ID</code> file that you must first fill out (see below).<p>We have provided skeletons for these exploits programs in the <code class=highlighter-rouge>sploits</code> directory, as <code class=highlighter-rouge>sploit1.c</code>, …, <code class=highlighter-rouge>sploit6.c</code>. Our own solutions, incidentally, are very short: fewer than 50 lines each. So while understanding and exploiting the bugs will not be easy, you will not need to write a lot of code.<h2 id=collaboration>Collaboration</h2><p>You may work on this project in collaboration with a single partner as described on the main page.<p>You must not discuss the project with anyone other than your partner and course staff. You may use online resources for general reference, but not to search for solutions to specific questions posed in this project.<h2 id=the-environment>The Environment</h2><p>You (and we, for grading) will test your exploit programs within a QEMU ARM virtual machine. This virtual machine emulates an ARM processor.<p>There are three options for running this virtual machine.<ul><li>You can install <a href=http://wiki.qemu.org/Main_Page>QEMU</a> on your computer. This is the easiest option for Linux and macOS. This may be difficult on Windows, but there are <a href=http://wiki.qemu.org/Links>unofficial binaries</a> which may work.<li>You can install QEMU inside a Linux virtual machine, e.g., using <a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a>.<li>You can run the QEMU VM from bertvm/ernievm.</ul><p>In any case, you will need to download and decompress qemu-arm.tar.bz2. The ARM VM can be started by running the <code class=highlighter-rouge>start-arm.sh</code> inside the <code class=highlighter-rouge>qemu-arm</code> directory. You can log in to the user account using the username/password <code class=highlighter-rouge>armuser</code>/<code class=highlighter-rouge>armuser</code>. In addition to giving you “console” access to the emulated ARM machine, the start-arm.sh script forwards local port 2200 to port 22 (the ssh port) in the VM. Thus, from a Linux or macOS machine, you can ssh to the ARM VM using<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ssh -larmuser -p 2200 localhost
</code></pre></div></div><p>You can put the following lines in your local machine’s <code class=highlighter-rouge>$HOME/.ssh/config</code> to provide easy ssh access:<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>Host = armguest
HostName = localhost
Port = 2200
User = armuser
</code></pre></div></div><p>You can then use the following to log in.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ssh armguest
</code></pre></div></div><p>If you are running the QEMU VM inside a VirtualBox VM which has been <a href=http://www.howtogeek.com/122641/how-to-forward-ports-to-a-virtual-machine-and-use-it-as-a-server/>configured</a> to forward host port 2222 to guest port 22, then the following line in your <code class=highlighter-rouge>$HOME/.ssh/config</code> works (modify <code class=highlighter-rouge>username</code> and add an ssh key as necessary):<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>Host = vboxvm
HostName = localhost
Port = 2222
User = username

Host = armguest
ProxyCommand = ssh -q vboxvm localhost 2200
</code></pre></div></div><p>The VM has Ubuntu installed as well as a number of useful utilities such as vim, ssh, and wget, and several hex editors such as <code class=highlighter-rouge>dhex</code>.<p>Once you have the QEMU VM installed, launch it, log in, and clone your assignment repository. You’ll first need to install git using <code class=highlighter-rouge>sudo apt-get install git</code>.<h2 id=the-targets>The Targets</h2><p>Once you have cloned your assignment repository in the VM, you need to enter your name and your partner’s name in the <code class=highlighter-rouge>ID</code> file. After you have done this, run<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./generate_targets.py
</code></pre></div></div><p>to generate the <code class=highlighter-rouge>targets</code> directory.<p><strong>WARNING: Once you have generated the <code class=highlighter-rouge>targets</code> directory, any changes to your <code class=highlighter-rouge>ID</code> file at all will cause the grading script to generate different targets and your exploits will likely not work.</strong><p>The <code class=highlighter-rouge>targets</code> directory contains the source code for the targets along with a <code class=highlighter-rouge>Makefile</code> specifying how they are to be built. To compile the targets and install them setuid root in <code class=highlighter-rouge>/tmp</code>, use the commands <code class=highlighter-rouge>make</code> and <code class=highlighter-rouge>make install</code>.<p><code class=highlighter-rouge>target5</code> is fairly complicated. It reads commands for manipulating strings from the file specified as its argument. Due to the way <code class=highlighter-rouge>target5</code> is compiled, the glibc <code class=highlighter-rouge>malloc</code>/<code class=highlighter-rouge>free</code>/<code class=highlighter-rouge>realloc</code> functions are not used. Instead, the replacement functions in <code class=highlighter-rouge>smalloc.c</code> are called. It is easiest to set a breakpoint in <code class=highlighter-rouge>smalloc</code>/<code class=highlighter-rouge>sfreer</code>/<code class=highlighter-rouge>srealloc</code> rather than trying to step into calls to <code class=highlighter-rouge>malloc</code>.<h2 id=the-exploits>The Exploits</h2><p>The <code class=highlighter-rouge>sploits</code> directory in the assignment contains skeleton source for the exploits which you are to write, along with a <code class=highlighter-rouge>Makefile</code> for building them. Also included is <code class=highlighter-rouge>shellcode.h</code>, which contains shellcode for you to use.<p>Your exploits should assume that the compiled target programs are installed in <code class=highlighter-rouge>/tmp</code>—<code class=highlighter-rouge>/tmp/target1</code>, …, <code class=highlighter-rouge>/tmp/target6</code>.<p>Along with each exploit skeleton file, there is an empty text file that you should fill with an explanation of the bug in the corresponding target and how your exploit takes advantage of it. You will submit this explanation along with your exploit.<h2 id=the-assignment>The Assignment</h2><p>You are to write exploits, one per target. Each exploit, when run in the virtual machine with its target installed setuid-root in <code class=highlighter-rouge>/tmp</code>, should yield a root shell (<code class=highlighter-rouge>/bin/sh</code>).<h2 id=hints>Hints</h2><ul><li>Read Aleph One’s “Smashing the Stack for Fun and Profit,” carefully! Also, read the “suggested reading” listed in the project <code class=highlighter-rouge>README.md</code>. You will want to have a good understanding of what happens to the stack, program counter, and relevant registers before and after a function call. Read scut’s “Exploiting Format String Vulnerabilities.” It will be helpful to have a solid understanding of the basic buffer overflow exploits before reading the more advanced exploit papers.<li>The GDB debugger is your best friend in this assignment as you’ll want to understand what’s going on in the target program’s memory space. Specifically, note the <code class=highlighter-rouge>disassemble</code>, <code class=highlighter-rouge>stepi</code>, and <code class=highlighter-rouge>nexti</code> commands. You may find the <code class=highlighter-rouge>x</code> command useful to examine memory (and the different ways you can print the contents such as <code class=highlighter-rouge>/a</code> or <code class=highlighter-rouge>/i</code> after <code class=highlighter-rouge>x</code>). The <code class=highlighter-rouge>info register</code> command is helpful for printing out the contents of registers.<li><p>A useful way to run GDB is to use the <code class=highlighter-rouge>-e</code> and <code class=highlighter-rouge>-s</code> command line flags; for example, the command<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>gdb -e ./sploit3 -s /tmp/target3 
</code></pre></div></div><p>tells GDB to execute <code class=highlighter-rouge>sploit3</code> and use the symbols from <code class=highlighter-rouge>target3</code> which allows you to trace execution in the target in exactly the way it is executed by the exploit. By contrast, executing just <code class=highlighter-rouge>gdb /tmp/target3</code> will trace the target in the way it is executed by the shell, so the memory layout will be different. (Avoiding a segfault while using this requires careful timing in setting breakpoints. See the assignment <code class=highlighter-rouge>README.md</code> for the details.)<li>One of the projects is very constrained in what arguments can be passed to it and you may have trouble running code on the heap (i.e., memory allocated by <code class=highlighter-rouge>malloc</code>). Try placing the shellcode somewhere else.<li>Make sure that your exploits work within the provided virtual machine.<li>Start early! Theoretical knowledge of exploits does not readily translate into the ability to write working exploits. The first target is relatively simple to exploit, but the difficulty ramps up from there.</ul><h2 id=warnings>Warnings</h2><p>Aleph One gives code that calculates addresses on the target’s stack based on addresses on the exploit’s stack. Addresses on the exploit’s stack can be changed based on how the exploit is executed (working directory, arguments, environment, etc.); in our testing, we do not guarantee to execute your exploits the same way <code class=highlighter-rouge>bash</code> does.<p>You must, therefore, hard-code target stack locations in your exploits. You should <em>not</em> use a function such as <code class=highlighter-rouge>get_sp</code> in the exploits you hand in.<h2 id=deliverables>Deliverables</h2><ul><li>You will submit using the provided <code class=highlighter-rouge>submit.sh</code> script. Make sure that all of your exploits compile with a single <code class=highlighter-rouge>make</code> command!<li>In addition, along with each exploit, you should include a text file (<code class=highlighter-rouge>sploit1.txt</code>, <code class=highlighter-rouge>sploit2.txt</code>, and so on). In this text file, explain how your exploit works: what the bug is in the corresponding target, how you exploit it, and where the various constants in your exploit come from.<li>Finally, you must include the file <code class=highlighter-rouge>ID</code> which contains the names of all partners (or just your own if you worked by yourself). Heed the warning about changing <code class=highlighter-rouge>ID</code> <a href=#the-targets>above</a>!</ul></main>