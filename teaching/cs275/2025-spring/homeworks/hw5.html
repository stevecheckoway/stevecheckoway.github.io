<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Hw5</title><meta name=description content="Homework 5: MiniScheme Beginnings"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2025-spring/homeworks/hw5.html> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-5-minischeme-beginnings>Homework 5: MiniScheme Beginnings</h1><p><strong>Due: Friday, March 21 at 00:00</strong><br><strong>First Commit: Monday, March 17 at 00:00</strong><p>This assignment helps you set the foundation for the MiniScheme project. Specifically, you’ll start by implementing environments and then continue to implementing to MiniScheme parts A &amp; B.<p>This is the <em>first of three</em> homework assignments that constitute the MiniScheme project.<p>Your implementations will be in several files. The start of each file should be<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>#</span><span class=nv>lang</span> <span class=nv>racket</span>
<span class=c1>; Your name(s) here.</span>
</code></pre></div></div><h2 id=preliminaries>Preliminaries</h2><p>Click on the <a href=#>assignment link</a>. You should make a new team as normal. However, you <strong>cannot change teams for subsequent MiniScheme Homeworks</strong>, so your team name and choice of partner should reflect this. I might recommend a variant of “steve-elinor-minischeme” as a team name.<p>As a reminder, if you’re working with a partner, one partner should create a new team. The second partner should click the link and choose the appropriate team. <strong>It’s extremely helpful for the graders if you include your name and your partner’s name in the team name.</strong> (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository on your computer by following the instruction and begin working. But before you do, read the entire assignment and be sure to check out the expected coding style, as posted on Ed.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Your repository should contain the following files<ul><li><code class="language-plaintext highlighter-rouge">env.rkt</code><li><code class="language-plaintext highlighter-rouge">env-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">parse.rkt</code><li><code class="language-plaintext highlighter-rouge">parse-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">interp.rkt</code><li><code class="language-plaintext highlighter-rouge">interp-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">minischeme.rkt</code><li><code class="language-plaintext highlighter-rouge">HONORCODE.md</code></ul><p>It may also a <a href=https://git-scm.com/docs/gitignore><code class="language-plaintext highlighter-rouge">.gitignore</code></a> file which tells Git to ignore files matching patterns in your working directory.<p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>Make sure you put your name (and your partner’s name if you’re working with one) as a comment at the top of each file.<h2 id=minischeme-environments>MiniScheme Environments</h2><p>As a reminder, we will be building an interpreter over the next few weeks for a subset of the Scheme language. The first thing we need to do is develop a way to hold bindings and their values to execute code. In other words: we need environments!<h2 id=overview>Overview</h2><p>We need to create an environment to hold the data for the expressions we will interpret. The scoping rules for Scheme determine the structure of this environment. Consider the following three examples. First<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</code></pre></div></div><p>This has an environment with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> created in a let-block. These bindings are used in the body of the <code class="language-plaintext highlighter-rouge">let</code>.<p>Next, consider the following. This has a let-block that creates a <code class="language-plaintext highlighter-rouge">lambda</code> expression, which is called in the body of the <code class="language-plaintext highlighter-rouge">let</code>:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=mi>4</span><span class=p>))])</span>
  <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>When this is evaluated we want to bind <code class="language-plaintext highlighter-rouge">x</code> to the value of the argument, <code class="language-plaintext highlighter-rouge">5</code>, and then evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> using that binding.<p>Finally, we combine these. At the outer level in the following expression we have a let-block with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. The body is another, nested, <code class="language-plaintext highlighter-rouge">let</code>, which binds a <code class="language-plaintext highlighter-rouge">lambda</code> expression with a parameter <code class="language-plaintext highlighter-rouge">x</code>. The body of the interior <code class="language-plaintext highlighter-rouge">let</code> is a call to the function.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>When we evaluate this we first make an environment with bindings of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> respectively, then we use this to evaluate the inner let-expression. In that expression we make a binding of <code class="language-plaintext highlighter-rouge">f</code> to the value of the lambda-expression (a closure), and then we call <code class="language-plaintext highlighter-rouge">f</code> with argument <code class="language-plaintext highlighter-rouge">5</code>. This requires us to evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>. The body of <code class="language-plaintext highlighter-rouge">f</code> does not have a binding for <code class="language-plaintext highlighter-rouge">y</code>, so we look it up in the outer environment and see that its value is <code class="language-plaintext highlighter-rouge">3</code>. Finally, we evaluates <code class="language-plaintext highlighter-rouge">(+ x y)</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">y</code> bound to <code class="language-plaintext highlighter-rouge">3</code>, yielding <code class="language-plaintext highlighter-rouge">8</code> for the value of the full expression.<p>Environments are extended in two ways. Let expressions have bindings that extend the current environment; the body of the <code class="language-plaintext highlighter-rouge">let</code> is evaluated in the extended environment. Lambda-expressions do not extend the environment; they evaluate to closures that store the current environment from the location where the <code class="language-plaintext highlighter-rouge">(lambda (...) ...)</code> is evaluated.<p>When the closure that results from a <code class="language-plaintext highlighter-rouge">lambda-expression</code> is called, the closure’s environment is extended with the parameters from the lambda-expression being bound to the values of the arguments.<p>We will define the environment as an association list, where symbols are associated with values. There are two ways we might do this. In the first example above, where <code class="language-plaintext highlighter-rouge">x</code> is bound to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">3</code>, we might use the list <code class="language-plaintext highlighter-rouge">'((x 2) (y 3))</code>, or we might use <code class="language-plaintext highlighter-rouge">'((x y) (2 3))</code>. The former structure is closer to the way the bindings appear in let-expressions; the latter is closer to the components of a call. The former structure might appear simpler, but the latter is actually easier to code and we will go with that.<p>Scheme, and many other languages you have and likely will learn, employs <em>lexical scoping</em>. When we want to resolve the binding for a free variable, we look first in the current scope, then in the surrounding scope, then in the scope that surrounds that, until the variable is found or we reach the outermost scope. To implement this our environments will be structured as a “list” (hint: what should it <em>actually</em> be if not a literal list as described here?) with four elements: the symbol <code class="language-plaintext highlighter-rouge">'env</code>, a list of symbols, a list of values, and the previous environment. The top-most environment does not have a previous-environment (by definition) so we’ll use <code class="language-plaintext highlighter-rouge">null</code> to represent the empty environment.<p>Thus, the environment for the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>z</span> <span class=mi>4</span><span class=p>]</span> <span class=p>[</span><span class=nf>x</span> <span class=mi>5</span><span class=p>])</span>
    <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>y</span> <span class=nv>z</span><span class=p>))))</span>
</code></pre></div></div><p>will be something like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>'</span><span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>z</span> <span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nf>4</span> <span class=mi>5</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nf>2</span> <span class=mi>3</span><span class=p>)</span>
           <span class=p>()))</span>
</code></pre></div></div><p>When we resolve the bindings for <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> to evaluate <code class="language-plaintext highlighter-rouge">(+ x (+ y z))</code> we find the binding <code class="language-plaintext highlighter-rouge">5</code> for <code class="language-plaintext highlighter-rouge">x</code> (there are two bindings for <code class="language-plaintext highlighter-rouge">x</code>, but the one we want is is the first one we come to), and of course we find <code class="language-plaintext highlighter-rouge">4</code> for <code class="language-plaintext highlighter-rouge">z</code> and <code class="language-plaintext highlighter-rouge">3</code> for <code class="language-plaintext highlighter-rouge">y</code>. This leads to the correct value, <code class="language-plaintext highlighter-rouge">12</code> for the expression.<p>Similarly, in the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>we evaluate the call <code class="language-plaintext highlighter-rouge">(f 5)</code> by evaluating the body of <code class="language-plaintext highlighter-rouge">f</code> in an environment that first has <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>, and then has the environment surrounding the definition of <code class="language-plaintext highlighter-rouge">f</code>.<p>You will see in later parts how this environment is created. At present we need to create the tools that will allow this.<h2 id=part-1-the-environment-data-type>Part 1: The environment data type</h2><p>The two most important features of an environment are that we need to be able to look up symbols to get the values they are bound to, and we need to be able to extend an environment with new bindings to get a new environment. We’ll define an environment as either the empty environment, with no bindings, or an extended environment with a list of symbols, a corresponding list of the values those symbols are bound to, and a previous environment that is being extended. Here is the definition of the empty environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; The empty environment is null.</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>empty-env</span> <span class=nv>null</span><span class=p>)</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>empty-env?</span> <span class=nv>null?</span><span class=p>)</span>
</code></pre></div></div><p>How will we build the environment? Well, we want a constructor such that the following works:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>)</span>
</code></pre></div></div><p>Recognizer<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>env?</span> <span class=nv>x</span><span class=p>)</span>
</code></pre></div></div><p>And accessors.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>env-syms</span> <span class=nv>e</span><span class=p>)</span>
<span class=p>(</span><span class=nf>env-vals</span> <span class=nv>e</span><span class=p>)</span>
<span class=p>(</span><span class=nf>env-previous</span> <span class=nv>e</span><span class=p>)</span>
</code></pre></div></div><p>Now, define the new data type in <code class="language-plaintext highlighter-rouge">env.rkt</code>. <strong>Use built-in Racket functionality to define this data type: do <em>NOT</em> implement the constructor, recognizers, or accessors yourself!</strong><p>Note that <code class="language-plaintext highlighter-rouge">env</code> is the procedure you will use every time you need to extend an environment when evaluating a let-expression or a function call. For example, when evaluating the expression <code class="language-plaintext highlighter-rouge">(let ([x 1] [y 2]) ...)</code> we might use the following.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>We can then further extend the environment as follows:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><h2 id=part-2-implementing-the-environment-lookup>Part 2: Implementing the environment lookup</h2><p>After Part 1 above, <code class="language-plaintext highlighter-rouge">env.rkt</code> contains code which describes the environment data type. Part 2 asks you to implement <code class="language-plaintext highlighter-rouge">env-lookup</code> (35 points) and write thoughtful related tests (see details below) (15 points).<p>Add to <code class="language-plaintext highlighter-rouge">env.rkt</code> the procedure <code class="language-plaintext highlighter-rouge">(env-lookup environment symbol)</code>, which takes an environment and a symbol and returns the first binding for that symbol in the environment. For example, with environments <code class="language-plaintext highlighter-rouge">env-a</code> and <code class="language-plaintext highlighter-rouge">env-b</code> defined as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>we should have the following behavior:<ul><li><code class="language-plaintext highlighter-rouge">(env-lookup env-a 'x)</code> should return 1<li><code class="language-plaintext highlighter-rouge">(env-lookup env-b 'x)</code> should return 5<li><code class="language-plaintext highlighter-rouge">(env-lookup env-b 'y)</code> should return 2<li><code class="language-plaintext highlighter-rouge">(env-lookup env-b 'foo)</code> should cause an error</ul><p>If <code class="language-plaintext highlighter-rouge">env-lookup</code> does not find a binding for the symbol you should throw an error as below:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nb>error</span> <span class=ss>'env-lookup</span> <span class=s>"No binding for ~s"</span> <span class=nv>symbol</span><span class=p>)</span>
</code></pre></div></div><p>Make sure you <code class="language-plaintext highlighter-rouge">(provide env-lookup)</code> at the top of <code class="language-plaintext highlighter-rouge">env.rkt</code> so that modules you’ll write in future parts (and in the tests described below) can use that procedure.<p>The file <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> contains a <code class="language-plaintext highlighter-rouge">test-env</code> environment that maps <code class="language-plaintext highlighter-rouge">x</code> to 1 and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code>. In addition it defines an <code class="language-plaintext highlighter-rouge">env-tests</code> test suite that tests the basic behavior of the environment data type. Extend this test suite with additional tests for <code class="language-plaintext highlighter-rouge">env-lookup</code>. You will probably want to define new extended environments for your tests.<p>In particular, be sure to test at least the following situations:<ul><li>Looking up a symbol that’s not bound in an environment throws an error. The test below depends on <code class="language-plaintext highlighter-rouge">(env-previous empty-env)</code> throwing an error. You’ll want something very similar and you should use the <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-exn%29%29><code class="language-plaintext highlighter-rouge">test-exn</code> procedure</a>: <div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-exn</span> <span class=s>"Empty environment has no previous"</span>
          <span class=nv>exn:fail?</span>
          <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><li>Looking up a symbol in an empty environment throws an error.<li>Looking up a symbol that’s bound in an environment returns its value.<li>Looking up a symbol that’s not bound in an environment but is bound in the environment’s previous environment returns the correct value.<li>Looking up a symbol that’s bound in an environment and also in the environment’s previous environment returns the correct value (see examples above).</ul><p>All testing for MiniScheme runs through <code class="language-plaintext highlighter-rouge">tests.rkt</code>. Run this file to call the tests you wrote in <code class="language-plaintext highlighter-rouge">env-tests.rkt</code>.<p>Now that you have a working environment, it would be a <em>great time to commit your code!</em><h2 id=overview-of-minischeme-a--b>Overview of MiniScheme A &amp; B</h2><p>We will start with a very basic version of our MiniScheme language, version A, and gradually add language features. As we do so, we will update our parser and interpreter to implement the new language features.<p>As mentioned in lecture, the parser and interpreter for MiniScheme will reside in files <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>, respectively. After you complete each of the remaining parts, you should be sure to commit your code. <em>That way, you can always retrieve an earlier version if you need to.</em><p>Here’s what you’ll have in each file.<ul><li><code class="language-plaintext highlighter-rouge">parse.rkt</code>: Tree data types and the <code class="language-plaintext highlighter-rouge">parse</code> procedure which converts the input to a tree to interpret;<li><code class="language-plaintext highlighter-rouge">interp.rkt</code>: Initially just <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure which takes a parse tree and an environment and produces a value and <code class="language-plaintext highlighter-rouge">init-env</code> which will hold the initial environment; and<li><code class="language-plaintext highlighter-rouge">env.rkt</code>: Environment data type and <code class="language-plaintext highlighter-rouge">env-lookup</code> procedure</ul><p>As you go, think about where to put new definitions. Racket has trouble with circular requirements (such as <code class="language-plaintext highlighter-rouge">parse.rkt</code> requiring <code class="language-plaintext highlighter-rouge">interp.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code> requiring <code class="language-plaintext highlighter-rouge">parse.rkt</code>). You probably want your <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">env.rkt</code> files to not require any other module, and your <code class="language-plaintext highlighter-rouge">interp.rkt</code> file to require both <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">env.rkt</code>.<p>In addition to those files, we’ll have some testing files.<ul><li><code class="language-plaintext highlighter-rouge">parse-tests.rkt</code>: This defines a test suite for the parser;<li><code class="language-plaintext highlighter-rouge">interp-tests.rkt</code>: This defines a test suite for the interpreter;<li><code class="language-plaintext highlighter-rouge">env-tests.rkt</code>: This defines tests for the environment; and<li><code class="language-plaintext highlighter-rouge">tests.rkt</code>: This combines the other three test suites into a single <code class="language-plaintext highlighter-rouge">all-tests</code> test suite and runs it.</ul><p>Start by creating files <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>. Make sure they include the <code class="language-plaintext highlighter-rouge">#lang</code> line and your name(s).<h2 id=minischeme-a-numbers>MiniScheme A: Numbers</h2><p>Version A of MiniScheme is given by the following grammar.<pre><code class=language-raw>EXP → number                      parse into lit-exp
</code></pre><h3 id=parsing>Parsing</h3><p>Our parse procedure will take an input expression and return a parse tree for an <code class="language-plaintext highlighter-rouge">EXP</code>. The only expressions in MiniScheme A are numbers.<p>In <code class="language-plaintext highlighter-rouge">parse.rkt</code> we need a data type to hold <code class="language-plaintext highlighter-rouge">EXP</code> nodes that represent numbers. We’ll call this data type <code class="language-plaintext highlighter-rouge">lit-exp</code>. You need to implement it so that it contains the numerical value being represented, has a constructor, recognizer, and getter (a transparent struct is recommended!).<p>In the instructions I will use the names <code class="language-plaintext highlighter-rouge">lit-exp</code> (constructor), <code class="language-plaintext highlighter-rouge">lit-exp?</code> (recognizer), and <code class="language-plaintext highlighter-rouge">lit-exp-num</code> (getter), although you can call them whatever you’d like.<p>The parse function <code class="language-plaintext highlighter-rouge">(parse input)</code> should create a <code class="language-plaintext highlighter-rouge">lit-exp</code> when it sees a number (and throw an error otherwise).<p>Write the <code class="language-plaintext highlighter-rouge">parse</code> function and and the code that implements the <code class="language-plaintext highlighter-rouge">lit-exp</code> data type, in <code class="language-plaintext highlighter-rouge">parse.rkt</code>. Make this file into a module by adding the appropriate provide lines to make the <code class="language-plaintext highlighter-rouge">parse</code> procedure and the procedures for <code class="language-plaintext highlighter-rouge">lit-exp</code> (or whatever you call it) available to other modules.<p>In <code class="language-plaintext highlighter-rouge">parse-tests.rkt</code>, add tests for <code class="language-plaintext highlighter-rouge">parse</code>. In particular, you should test that <code class="language-plaintext highlighter-rouge">(parse 5)</code> returns something that <code class="language-plaintext highlighter-rouge">lit-exp?</code> evaluates to true. The <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-pred%29%29><code class="language-plaintext highlighter-rouge">test-pred</code></a> procedure, as shown below, will likely be helpful.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-pred</span> <span class=s>"Literal"</span>
           <span class=nv>lit-exp?</span>
           <span class=p>(</span><span class=nf>parse</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>Also test that when you parse a number, you can extract the number from the resultant parse tree using <code class="language-plaintext highlighter-rouge">lit-exp-num</code>.<h3 id=evaluating>Evaluating</h3><p>For the interpreter, you know that Scheme evaluates all integers as themselves. Therefore, <code class="language-plaintext highlighter-rouge">eval-exp</code> is simple. Write <code class="language-plaintext highlighter-rouge">(eval-exp tree e)</code> to evaluate a <code class="language-plaintext highlighter-rouge">lit-exp</code> and throw an error otherwise. Save this code as <code class="language-plaintext highlighter-rouge">interp.rkt</code>. Make sure you require <code class="language-plaintext highlighter-rouge">parse.rkt</code> and (for the next step) <code class="language-plaintext highlighter-rouge">env.rkt</code>. Similarly, make sure you <code class="language-plaintext highlighter-rouge">provide eval-exp</code> for use by other modules.<p>If you run <code class="language-plaintext highlighter-rouge">interp.rkt</code> in DrRacket to load the interpreter and parser into memory, you can type the following:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define</span> <span class=nv>T</span> <span class=p>(</span><span class=nf>parse</span> <span class=ss>'23</span><span class=p>))</span>
<span class=nv>&gt;</span> <span class=p>(</span><span class=nf>eval-exp</span> <span class=nv>T</span> <span class=nv>empty-env</span><span class=p>)</span>
</code></pre></div></div><p>and it should print the value 23.<p>It quickly becomes tedious to always invoke your interpreter by specifically calling <code class="language-plaintext highlighter-rouge">eval-exp</code> after calling the parser on the quoted expression. It would be nice if we could write a read-eval-print loop for MiniScheme. This is precisely what <code class="language-plaintext highlighter-rouge">minischeme.rkt</code> does.<p>Running <code class="language-plaintext highlighter-rouge">minischeme.rkt</code> in DrRacket will give you an input box that allows you to type expressions and get back their value as determined by your <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">interp</code> modules. For example, if you enter the MiniScheme expression 23 this evaluates it and prints its value 23.<p><em>Running into issues?</em> The read-eval-print procedures assumes that your parse procedure is named <code class="language-plaintext highlighter-rouge">parse</code> that your evaluator is called <code class="language-plaintext highlighter-rouge">eval-exp</code> that takes as arguments a parse tree and an environment, in that order; and an initial environment named <code class="language-plaintext highlighter-rouge">init-env</code>. <strong>Please keep these names consistent so that testing &amp; <code class="language-plaintext highlighter-rouge">minischeme.rkt</code> works throughout the project!</strong><p>Now inside <code class="language-plaintext highlighter-rouge">interp.rkt</code>, define and provide an <code class="language-plaintext highlighter-rouge">init-env</code>. For the <code class="language-plaintext highlighter-rouge">init-env</code>, use your <code class="language-plaintext highlighter-rouge">env</code> constructor to create an environment mapping <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">23</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">42</code>. These will be helpful in future parts, so its a good idea to define them now.<p>The last thing we need to do for MiniScheme A is to write some tests. In <code class="language-plaintext highlighter-rouge">interp-tests.rkt</code>, write a test like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-equal?</span> <span class=s>"Number"</span>
             <span class=p>(</span><span class=nf>eval-exp</span> <span class=p>(</span><span class=nf>lit-exp</span> <span class=mi>5</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>)</span>
             <span class=mi>5</span><span class=p>)</span>
</code></pre></div></div><p>Note that we’re explicitly passing the parse tree <code class="language-plaintext highlighter-rouge">(lit-exp 5)</code> rather than calling <code class="language-plaintext highlighter-rouge">(parse 5)</code>. This lets you separately test parsing from evaluating. In subsequent parts, you’ll be modifying <code class="language-plaintext highlighter-rouge">parse</code>. You don’t want a bug in <code class="language-plaintext highlighter-rouge">parse</code> to show up as a bug in <code class="language-plaintext highlighter-rouge">eval-exp</code>. By not using <code class="language-plaintext highlighter-rouge">parse</code> in your interpreter tests, you can keep the two separate.<p>Congratulations, at this point you should have a working interpreter for MiniScheme A! Make sure you commit your work.<h2 id=minischeme-b-variables--values>MiniScheme B: Variables &amp; Values</h2><p>Let’s extend MiniScheme A by adding symbols. So, the grammar for MiniScheme B is:<pre><code class=language-raw>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
</code></pre><p>The parser is a simple modification to <code class="language-plaintext highlighter-rouge">parse</code>. You need to add a line to <code class="language-plaintext highlighter-rouge">(parse input)</code> to handle the case where <code class="language-plaintext highlighter-rouge">(symbol? input)</code> is <code class="language-plaintext highlighter-rouge">#t</code>. You will need a new data type to handle this (I call it <code class="language-plaintext highlighter-rouge">var-exp</code>).<p>To evaluate a variable expression, MiniScheme B needs to be able to look up references. We evaluate a <code class="language-plaintext highlighter-rouge">var-exp</code> tree node in a given environment by calling lookup in that environment on the <code class="language-plaintext highlighter-rouge">var-exp-symbol</code>. Since we asked you to include bindings for symbols <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in the initial environment in Part 4, you should be able to evaluate the MiniScheme expressions <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">y</code> to get their values. Any other symbol at this point should give you an error message.<p>Make sure to add tests to both <code class="language-plaintext highlighter-rouge">parse-tests.rkt</code> and <code class="language-plaintext highlighter-rouge">interp-tests.rkt</code> to address MiniScheme B.<h2 id=common-questions>Common Questions</h2><ul><li><em>Should our environments handle more than 2 possible bindings?</em> Yes! Even though the examples only give you two possible bindings, your environments should be robust enough to handle <code class="language-plaintext highlighter-rouge">n</code> bindings simultaneously.<li><em>Should we test the environment data type separately from <code class="language-plaintext highlighter-rouge">env-lookup</code>?</em> No, tests for <code class="language-plaintext highlighter-rouge">env-lookup</code> should be sufficient.<li><em>If we have <code class="language-plaintext highlighter-rouge">(define env-a (env '(x y x) '(1 2 3) empty-env))</code>, what would <code class="language-plaintext highlighter-rouge">(env-lookup env-a 'x)</code> return?</em> 1</ul><h2 id=finishing-up>Finishing up</h2><p>Make sure you commit and push. And make sure your name is in all of the files you submit. Your friendly graders thank you!</main>