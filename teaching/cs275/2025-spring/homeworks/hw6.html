<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Hw6</title><meta name=description content="Homework 6: MiniScheme C, D &amp; E"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2025-spring/homeworks/hw6.html> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-6-minischeme-c-d--e>Homework 6: MiniScheme C, D &amp; E</h1><p><strong>Due: Friday, April 4 at 23:59</strong><br><strong>First Commit: Monday, March 31 at 23:59</strong><p>This assignment continues our work on MiniScheme. Specifically, you’ll complete MiniScheme parts C, D, and E. Each part builds a new version of MiniScheme, adding functionality step by step. Each part requires testing. You’ll definitely want to add testing for each part as you’re working on it.<p>Your implementations will be in several files. The start of each file should be<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>#</span><span class=nv>lang</span> <span class=nv>racket</span>
<span class=c1>; Your name(s) here.</span>
</code></pre></div></div><h2 id=preliminaries>Preliminaries</h2><p>Click on the <a href=https://classroom.github.com/a/aHvaKwMK>assignment link</a>. A reminder that <strong>new teams are not allowed</strong> for Homework 6. Your teams from Homework 5 have been ported over automatically. You should work in the same manner as Homework 5 (i.e. with the same partner or solo). Please reach out to me if that will be an issue.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Note that apart from a new <code class="language-plaintext highlighter-rouge">HONORCODE.md</code>, <strong>there are no starter files for Homework 6</strong>. This is because you will be directly building on your Homework 5 work! So, start by copying all of your <code class="language-plaintext highlighter-rouge">.rkt</code> files from Homework 5 into your repository and committing them.<p>Upon submission, your repository should include the following files:<ul><li><code class="language-plaintext highlighter-rouge">parse.rkt</code><li><code class="language-plaintext highlighter-rouge">parse-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">interp.rkt</code><li><code class="language-plaintext highlighter-rouge">interp-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">env.rkt</code><li><code class="language-plaintext highlighter-rouge">env-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">minischeme.rkt</code><li><code class="language-plaintext highlighter-rouge">HONORCODE.md</code></ul><p>It may also a <a href=https://git-scm.com/docs/gitignore><code class="language-plaintext highlighter-rouge">.gitignore</code></a> file which tells Git to ignore files matching patterns in your working directory.<p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>Make sure you put your name (and your partner’s name if you’re working with one) as a comment at the top of each file.<h2 id=overview>Overview</h2><p>As a reminder, the version of MiniScheme you built as part of Homework 5 handles numbers and variable mappings. Now it is time to actually support computation!<h2 id=part-c-calls-to-primitive-procedures>Part C: Calls to primitive procedures</h2><p>Now we can add arithmetic expressions to our MiniScheme implementation. The first step is to handle primitive operators themselves, before we move on to applying them to arguments.<p>Parsing for operators like <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, etc. is handled for us already. Why? They are symbols and therefore get parsed to <code class="language-plaintext highlighter-rouge">var-exp</code> nodes.<p>Next our environment needs to associate these symbols to values. There are many ways to do this, but the way we will use will be easy to expand to procedures derived from <code class="language-plaintext highlighter-rouge">lambda</code> expressions. We will first make a data type <code class="language-plaintext highlighter-rouge">prim-proc</code> to represent primitive procedures. The only data this type needs to carry is the symbol for the operator, so this looks similar to the <code class="language-plaintext highlighter-rouge">var-exp</code> type. Make a constructor, a recognizer, and a getter for the data type.<p>Think about which file should contain this data type definition. Keep in mind that <em>nothing in the parser needed to change to support these primitive procedures</em>.<p>Next, we make a list of the primitive arithmetic operators. Start with the following, but make sure to expand it later on (see below for list primitives, for example):<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>primitive-operators</span> <span class=o>'</span><span class=p>(</span><span class=nb>+</span> <span class=nv>-</span> <span class=nv>*</span> <span class=nv>/</span><span class=p>))</span>
</code></pre></div></div><p>We can define a primitive operator environment and make our <code class="language-plaintext highlighter-rouge">init-env</code> extend that instead of the <code class="language-plaintext highlighter-rouge">empty-env</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>prim-env</span>
  <span class=p>(</span><span class=nf>env</span> <span class=nv>primitive-operators</span>
       <span class=p>(</span><span class=nb>map</span> <span class=nv>prim-proc</span> <span class=nv>primitive-operators</span><span class=p>)</span>
       <span class=nv>empty-env</span><span class=p>))</span>

<span class=p>(</span><span class=k>define</span> <span class=nv>init-env</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span>
       <span class=o>'</span><span class=p>(</span><span class=nf>23</span> <span class=mi>42</span><span class=p>)</span>
       <span class=nv>prim-env</span><span class=p>))</span>
</code></pre></div></div><p>This means that when we evaluate <code class="language-plaintext highlighter-rouge">+</code> by looking it up in the environment we will get the structure <code class="language-plaintext highlighter-rouge">'(prim-proc +)</code>.<p>We will now extend the grammar to include applications so we can <em>use</em> primitive operators. The grammar for MiniScheme C is:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (EXP EXP*)                  parse into app-exp
</code></pre></div></div><p>Finally, a language that can compute! You need to implement an <code class="language-plaintext highlighter-rouge">app-exp</code> data type that can hold a procedure (which is itself a tree) and a list of argument expressions (again, these are trees). The constructor for that might be <code class="language-plaintext highlighter-rouge">(app-exp proc args)</code>. Update the parser to build an <code class="language-plaintext highlighter-rouge">app-exp</code> node when the expression being parsed is a (non-empty) list. Remember that you will need to parse both the operator and the list of operands.<p>Add tests to <code class="language-plaintext highlighter-rouge">parse-tests</code> to test that applications are parsed correctly. Make sure you test parsing applications with different numbers of parameters <code class="language-plaintext highlighter-rouge">(foo)</code>, <code class="language-plaintext highlighter-rouge">(bar 1)</code>, <code class="language-plaintext highlighter-rouge">(baz x y)</code>, etc. Add a test to check that <code class="language-plaintext highlighter-rouge">()</code> causes an error (see HW5 for testing errors if you don’t remember how to!).<p>In the <code class="language-plaintext highlighter-rouge">interp</code> module extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to evaluate an <code class="language-plaintext highlighter-rouge">app-exp</code> node by calling a new procedure <code class="language-plaintext highlighter-rouge">apply-proc</code> with the evaluated operator and the list of evaluated arguments. Here is <code class="language-plaintext highlighter-rouge">apply-proc</code>:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-proc</span> <span class=nv>proc</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>prim-proc?</span> <span class=nv>proc</span><span class=p>)</span>
         <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=p>(</span><span class=nf>prim-proc-op</span> <span class=nv>proc</span><span class=p>)</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-proc</span> <span class=s>"bad procedure: ~s"</span> <span class=nv>proc</span><span class=p>)]))</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">apply-primitive-op</code> procedure takes a symbol corresponding to the primitive procedure and a list of argument values. Here is the start of one possible <code class="language-plaintext highlighter-rouge">apply-primitive-op</code>:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=nv>op</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'+</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>+</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'-</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>-</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=o>...</span>
        <span class=nv>handle</span> <span class=ss>'*</span><span class=o>,</span> <span class=ss>'/</span><span class=o>,</span> <span class=nv>and</span> <span class=nv>the</span> <span class=nv>others</span>
        <span class=o>...</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-primitive-op</span> <span class=s>"Unknown primitive: ~s"</span> <span class=nv>op</span><span class=p>)]))</span>
</code></pre></div></div><p><strong>This implementation has several problems!</strong> First, consider the expressions <code class="language-plaintext highlighter-rouge">(-)</code> and <code class="language-plaintext highlighter-rouge">(/)</code>. These are subtracting or dividing 0 arguments. Racket doesn’t support this and raises an error (although <code class="language-plaintext highlighter-rouge">(+)</code> and <code class="language-plaintext highlighter-rouge">(*)</code> return 0 and 1, respectively). Second, consider the expression <code class="language-plaintext highlighter-rouge">(+ +)</code>. Here, we’re trying to add a <code class="language-plaintext highlighter-rouge">prim-proc</code>. That’s not going to work and Racket will raise an error. The problem is that these will be programmer errors and not user errors.<p>Rather than calling <code class="language-plaintext highlighter-rouge">apply</code> directly, for primitive procedures dealing with numbers, you should check that all of the values are numbers and raise a user error via <code class="language-plaintext highlighter-rouge">raise-user-error</code> if they are not. Similarly, for <code class="language-plaintext highlighter-rouge">-</code> and <code class="language-plaintext highlighter-rouge">/</code>, you’ll want to check that there is at least one argument in <code class="language-plaintext highlighter-rouge">args</code>.<p>One approach is to write a function <code class="language-plaintext highlighter-rouge">(check-numeric-args op nonempty args)</code> that raises a user error (with <code class="language-plaintext highlighter-rouge">op</code> as the symbol argument to <code class="language-plaintext highlighter-rouge">raise-user-error</code>) if <code class="language-plaintext highlighter-rouge">args</code> isn’t a list of numbers or if <code class="language-plaintext highlighter-rouge">nonempty</code> is true but <code class="language-plaintext highlighter-rouge">args</code> is the empty list. Otherwise, it should return <code class="language-plaintext highlighter-rouge">args</code>. With that, you can replace the implementation given above with<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=nv>op</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'+</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>+</span> <span class=p>(</span><span class=nf>check-numeric-args</span> <span class=ss>'+</span> <span class=no>#f</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'-</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>-</span> <span class=p>(</span><span class=nf>check-numeric-args</span> <span class=ss>'-</span> <span class=no>#t</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=o>...</span>
        <span class=nv>handle</span> <span class=ss>'*</span><span class=o>,</span> <span class=ss>'/</span><span class=o>,</span> <span class=nv>and</span> <span class=nv>the</span> <span class=nv>others</span>
        <span class=o>...</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-primitive-op</span> <span class=s>"Unknown primitive: ~s"</span> <span class=nv>op</span><span class=p>)]))</span>
</code></pre></div></div><p>Our language should now be able to evaluate calls to primitive operators, such as <code class="language-plaintext highlighter-rouge">(+ 2 4)</code> or <code class="language-plaintext highlighter-rouge">(+ x y)</code>.<p>Next extend MiniScheme C to handle to following primitive procedures:<ul><li><code class="language-plaintext highlighter-rouge">add1</code><li><code class="language-plaintext highlighter-rouge">sub1</code><li><code class="language-plaintext highlighter-rouge">negate</code> - <code class="language-plaintext highlighter-rouge">(negate 6)</code> is <code class="language-plaintext highlighter-rouge">-6</code> and <code class="language-plaintext highlighter-rouge">(negate (negate 6))</code> is <code class="language-plaintext highlighter-rouge">6</code><li><code class="language-plaintext highlighter-rouge">list</code><li><code class="language-plaintext highlighter-rouge">cons</code><li><code class="language-plaintext highlighter-rouge">car</code><li><code class="language-plaintext highlighter-rouge">cdr</code></ul><p>For each of these functions, check that the number and type of arguments are correct and raise an error if they are not.<p>Remember this is Mini<em>Scheme</em>, so there is no <code class="language-plaintext highlighter-rouge">first</code> and <code class="language-plaintext highlighter-rouge">rest</code>. Make sure to also add a new symbol <code class="language-plaintext highlighter-rouge">'null</code> bound to the empty list to the initial environment.<p>Add tests to <code class="language-plaintext highlighter-rouge">interp-tests</code> to test evaluating some of your primitive procedures. Make sure you specify your tests in terms of <code class="language-plaintext highlighter-rouge">app-exp</code>, <code class="language-plaintext highlighter-rouge">var-exp</code>, and <code class="language-plaintext highlighter-rouge">lit-exp</code>.<p>Our methodology should now be pretty clear. At each step, we have a new line in the grammar to handle a new kind of Scheme expression. We update the parser, which requires making a new tree data type to handle the new parsed expression. We then update the <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure to evaluate the new tree node. For the remaining steps, the instructions will assume that you are comfortable with this methodology, so please ask questions if not!<h2 id=part-d-conditionals>Part D: Conditionals</h2><p>Let’s update our language to include conditional evaluation. We will adopt the convention that 0 and <code class="language-plaintext highlighter-rouge">False</code> represent false, and everything else represents true. Note that <code class="language-plaintext highlighter-rouge">#t</code> and <code class="language-plaintext highlighter-rouge">#f</code> are not values in MiniScheme. You should assign the value <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code> to the symbols <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code>. True expressions, such as <code class="language-plaintext highlighter-rouge">(eqv? 2 (+ 1 1))</code> should evaluate to <code class="language-plaintext highlighter-rouge">True</code>, not to <code class="language-plaintext highlighter-rouge">#t</code> (Note that we will use <code class="language-plaintext highlighter-rouge">eqv?</code> as our equality operator in MinScheme and it should be implemented using <code class="language-plaintext highlighter-rouge">eqv?</code> in Racket).<p>This is the grammar for MiniScheme D:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (EXP EXP*)                  parse into app-exp
</code></pre></div></div><p>Now implement both parsing and interpretation for if-expressions. You will need to add <code class="language-plaintext highlighter-rouge">False</code> and <code class="language-plaintext highlighter-rouge">True</code> to the initial environment as described above. The meaning of <code class="language-plaintext highlighter-rouge">(if foo bar buzz)</code> is just what you’d expect: If <code class="language-plaintext highlighter-rouge">foo</code> evaluates to <code class="language-plaintext highlighter-rouge">False</code> or <code class="language-plaintext highlighter-rouge">0</code>, then the value of the if-then-else expression is obtained by evaluating <code class="language-plaintext highlighter-rouge">buzz</code>; otherwise, the value is obtained by evaluating <code class="language-plaintext highlighter-rouge">bar</code>.<p>You need to make a new data type (maybe called <code class="language-plaintext highlighter-rouge">ite-exp</code>) and update the parser in <code class="language-plaintext highlighter-rouge">parse.rkt</code>, and update the <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure in <code class="language-plaintext highlighter-rouge">interp.rkt</code>. For the parser, note that both if expressions and application expressions are lists. We know a list represents an if-expression if its first element is the symbol <code class="language-plaintext highlighter-rouge">'if</code>. Put the test for this in the inner <code class="language-plaintext highlighter-rouge">cond</code> after the test for an empty list. We will assume a list represents an application expression if we don’t recognize its first element as a special form. So far, <code class="language-plaintext highlighter-rouge">if</code> is our only special form. Later parts will have more special forms.<p>Now extend MiniScheme D to implement the primitives <code class="language-plaintext highlighter-rouge">eqv?</code>, <code class="language-plaintext highlighter-rouge">lt?</code>, <code class="language-plaintext highlighter-rouge">gt?</code>, <code class="language-plaintext highlighter-rouge">leq?</code> and <code class="language-plaintext highlighter-rouge">geq?</code> where <code class="language-plaintext highlighter-rouge">eqv?</code> behaves like Scheme’s <code class="language-plaintext highlighter-rouge">eqv?</code> and <code class="language-plaintext highlighter-rouge">lt?</code>, <code class="language-plaintext highlighter-rouge">gt?</code>, <code class="language-plaintext highlighter-rouge">leq?</code>, and <code class="language-plaintext highlighter-rouge">geq?</code> behave like the usual inequality operators <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, and <code class="language-plaintext highlighter-rouge">&gt;=</code>. Each of these should return <code class="language-plaintext highlighter-rouge">'True</code> or <code class="language-plaintext highlighter-rouge">'False</code> and not <code class="language-plaintext highlighter-rouge">#t</code> or <code class="language-plaintext highlighter-rouge">#f</code>.<p>Add primitive procedures <code class="language-plaintext highlighter-rouge">null?</code>, <code class="language-plaintext highlighter-rouge">list?</code>, and <code class="language-plaintext highlighter-rouge">number?</code> which behave like their Scheme counterparts, but return <code class="language-plaintext highlighter-rouge">True</code> or <code class="language-plaintext highlighter-rouge">False</code> rather than <code class="language-plaintext highlighter-rouge">#t</code> or <code class="language-plaintext highlighter-rouge">#f</code>.<p>Make sure to <em>add tests</em> for the parser and interpreter and commit your code once you’re finished.<h2 id=part-e-let-expressions>Part E: Let expressions</h2><p>The grammar for MiniScheme E is<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
</code></pre></div></div><p>As you can see, we have added new clause for the <code class="language-plaintext highlighter-rouge">let</code> expression. To make <code class="language-plaintext highlighter-rouge">eval-exp</code> clearer, I suggest that you make a <code class="language-plaintext highlighter-rouge">let-exp</code> data type that contains three children:<ol><li>A list of the symbols that are bound in the binding list<li>A list of the parsed expressions (i.e., trees) that the symbols are bound to<li>The <code class="language-plaintext highlighter-rouge">let</code> body.</ol><p>Thus, although we have grammar symbols for <code class="language-plaintext highlighter-rouge">LET-BINDING</code> and <code class="language-plaintext highlighter-rouge">LET-BINDINGS</code>, we choose to build the tree slightly differently.<p>After the parser is extended to handle <code class="language-plaintext highlighter-rouge">let</code> expressions, extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to handle the <code class="language-plaintext highlighter-rouge">let-exp</code> nodes created by the parser. The general approach is to evaluate a <code class="language-plaintext highlighter-rouge">let-exp</code> node in an environment by extending the environment with the let symbols bound to the values of the <code class="language-plaintext highlighter-rouge">let</code> bindings (<code class="language-plaintext highlighter-rouge">map</code> a curried version of <code class="language-plaintext highlighter-rouge">eval-exp</code> onto the binding expressions), and then evaluate the let body within this extended environment.<p>When you are finished you should be able to evaluate expressions such as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>a</span> <span class=mi>1</span><span class=p>]</span>
      <span class=p>[</span><span class=nf>b</span> <span class=mi>5</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))</span>
</code></pre></div></div><p>and<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>a</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>)]</span>
      <span class=p>[</span><span class=nf>b</span> <span class=mi>24</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>c</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>b</span> <span class=nv>a</span><span class=p>)])</span>
    <span class=p>(</span><span class=nb>*</span> <span class=nv>c</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))))</span>
</code></pre></div></div><p>Make sure to add parser and interpreter tests. Once you’ve done that, you’re all done with parts A through E of MiniScheme!<h2 id=notes-on-testing>Notes on Testing</h2><p>Please don’t write tests like this below, if you can help it:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-equal?</span> <span class=s>"Apply (- 23 3)"</span>
             <span class=p>(</span><span class=nf>eval-exp</span> <span class=p>(</span><span class=nf>parse</span> <span class=o>'</span><span class=p>(</span><span class=nb>-</span> <span class=mi>23</span> <span class=mi>3</span><span class=p>))</span> <span class=nv>test-env</span><span class=p>)</span>
             <span class=mi>20</span><span class=p>)</span>
</code></pre></div></div><p>Rather:<ul><li>Test<code class="language-plaintext highlighter-rouge"> parse</code> by giving it a structured list (i.e. a MiniScheme expression)<li>Test <code class="language-plaintext highlighter-rouge">eval-exp</code> by giving it a parse tree you write yourself</ul><p><strong>Why?</strong> It’s easy to make mistakes in <code class="language-plaintext highlighter-rouge">parse</code> that would then carry over to your <code class="language-plaintext highlighter-rouge">eval-exp</code> tests.<p>An example (good) test for <code class="language-plaintext highlighter-rouge">eval-exp</code> for MiniScheme C is below:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-equal?</span> <span class=s>"Apply (- 23 3)"</span>
             <span class=p>(</span><span class=nf>eval-exp</span> <span class=p>(</span><span class=nf>app-exp</span> <span class=p>(</span><span class=nf>var-exp</span> <span class=ss>'-</span><span class=p>)</span>
                                <span class=p>(</span><span class=nb>list</span> <span class=p>(</span><span class=nf>lit-exp</span> <span class=mi>23</span><span class=p>)</span>
                                      <span class=p>(</span><span class=nf>lit-exp</span> <span class=mi>3</span><span class=p>)))</span>
                       <span class=nv>test-env</span><span class=p>)</span>
             <span class=mi>20</span><span class=p>)</span>
</code></pre></div></div><h2 id=finishing-up>Finishing up</h2><p>Make sure you (and your partner, if you have one!) have signed the Honor Code and then add/commit/push. Also make sure your name(s) is in all of the files you submit. Your friendly graders thank you!</main>