<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Hw9</title><meta name=description content="Homework 9: Typed Racket"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2025-spring/homeworks/hw9.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-9-typed-racket>Homework 9: Typed Racket</h1><p><strong>Due: Friday, May 2 at 23:59</strong><br><p>In this assignment, you’ll be implementing some functions on lists using Typed Racket.<p>Your implementation will be in the <code class="language-plaintext highlighter-rouge">hw9.rkt</code> file. The start of the file should be<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>#</span><span class=nv>lang</span> <span class=nv>typed/racket</span>
<span class=c1>; Your name(s) here.</span>
</code></pre></div></div><p>The goals of this assignment are two-fold,<ol><li>Learn a new-ish language mostly on your own; and<li>Reinforce your understanding of the standard list functions used in functional programming languages.</ol><h2 id=preliminaries>Preliminaries</h2><p>Click on the <a href=https://classroom.github.com/a/RiJh6qxW>assignment link</a>. The same partner making rules apply as normal. <em>You can work in new teams for Homework 9</em>, as this is not part of the MiniScheme Project.<p>Once you have accepted the assignment and created/joined a team, you can clone the repository on your computer by following the instructions and begin working. But before you do, read the entire assignment and be sure to check out the expected coding style, as posted on Ed.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<ul><li><code class="language-plaintext highlighter-rouge">hw9.rkt</code><li><code class="language-plaintext highlighter-rouge">HONORCODE.md</code></ul><p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>Make sure you put your name (and your partner’s name if you’re working with one) as a comment at the top of each file.<h2 id=some-examples-to-start>Some examples to start</h2><p>Your task is to write implementations of several functions that operate on lists in Typed Racket.<p>You are definitely going to want to read <a href=https://docs.racket-lang.org/ts-guide/index.html>The Typed Racket Guide</a> before and during your work on this assignment. Refer to it often! In particular, you should read chapters 1 through 4 and section 8.2. (Section 8.2 is confusing! Please ask questions about it on Ed.) You can skip sections 3.1.4, 4.3, 4.7, and 4.10. You may also want to consult <a href=https://docs.racket-lang.org/ts-reference/index.html>The Typed Racket Reference</a>.<p>Each function you write <strong>must</strong> contain a proper type definition. This includes functions you define via <code class="language-plaintext highlighter-rouge">define</code> and those you define via <code class="language-plaintext highlighter-rouge">lambda</code>. Here’s an example function showing how to compute the maximum of a list of real numbers (see <a href=https://docs.racket-lang.org/ts-reference/type-ref.html#(part._.Numeric_.Types)>the reference</a> for how the various types of numbers in Typed Racket relate).<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>:</span> <span class=nv>maximum</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>Real</span><span class=p>)</span> <span class=p>(</span><span class=nf>U</span> <span class=nv>Real</span> <span class=nv>False</span><span class=p>)))</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>maximum</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span>
      <span class=no>#f</span>
      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>head</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>lst</span><span class=p>)]</span>
            <span class=p>[</span><span class=nb>max</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>U</span> <span class=nv>Real</span> <span class=nv>False</span><span class=p>)</span> <span class=p>(</span><span class=nf>maximum</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>))])</span>
        <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>not</span> <span class=nv>max</span><span class=p>)</span> <span class=nv>head</span><span class=p>]</span>
              <span class=p>[(</span><span class=nb>&gt;</span> <span class=nv>max</span> <span class=nv>head</span><span class=p>)</span> <span class=nv>max</span><span class=p>]</span>
              <span class=p>[</span><span class=nf>else</span> <span class=nv>head</span><span class=p>]))))</span>
</code></pre></div></div><p>The first line declares the type of <code class="language-plaintext highlighter-rouge">maximum</code> to be a function that takes a list of real numbers as arguments and returns either a real number or <code class="language-plaintext highlighter-rouge">#f</code> (see <a href=https://docs.racket-lang.org/ts-guide/types.html#%28part._.Union_.Types%29>Union types</a> in the guide).<p>The definition of <code class="language-plaintext highlighter-rouge">maximum</code> is pretty standard: It walks to the end of the list first (see the recursive call on the rest of <code class="language-plaintext highlighter-rouge">lst</code>). Then, as the recursive calls return, it compares the first element of the list to the maximum of the rest of the list (if such a maximum exists) and returns whichever is larger.<p>Notice how I specified the types of the variables in the <code class="language-plaintext highlighter-rouge">let</code> bindings as <code class="language-plaintext highlighter-rouge">[var : type expr]</code> which says that <code class="language-plaintext highlighter-rouge">var</code> has type <code class="language-plaintext highlighter-rouge">type</code> and its value is computed by <code class="language-plaintext highlighter-rouge">expr</code>. For example, <code class="language-plaintext highlighter-rouge">[head : Real (first lst)]</code> says <code class="language-plaintext highlighter-rouge">head</code> has type <code class="language-plaintext highlighter-rouge">Real</code> and its value is <code class="language-plaintext highlighter-rouge">(first lst)</code>. <code class="language-plaintext highlighter-rouge">max</code> is declared similarly but note that since the return type of <code class="language-plaintext highlighter-rouge">maximum</code> is <code class="language-plaintext highlighter-rouge">(U Real False)</code>, the type of <code class="language-plaintext highlighter-rouge">max</code> is declared to be <code class="language-plaintext highlighter-rouge">(U Real False)</code>. If that declaration is changed to<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>[</span><span class=nb>max</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nf>maximum</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>))]</span>
</code></pre></div></div><p>then you get a type error<pre><code class=language-raw>Type Checker: type mismatch
  expected: Real
  given: (U False Real) in: (maximum (rest lst))
</code></pre><p>The second example demonstrates parametric polymorphism, recursive helper functions, and specifying types of <code class="language-plaintext highlighter-rouge">lambda</code>s.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>:</span> <span class=nv>reverse</span> <span class=p>(</span><span class=nf>All</span> <span class=p>(</span><span class=nf>a</span><span class=p>)</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>))))</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nb>reverse</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nf>f</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>))</span>
              <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>lst</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>)]</span>
                  <span class=p>[</span><span class=nf>acc</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>)])</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>Listof</span> <span class=nv>a</span><span class=p>)</span>
                <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span>
                    <span class=nv>acc</span>
                    <span class=p>(</span><span class=nf>f</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>lst</span><span class=p>)</span> <span class=nv>acc</span><span class=p>))))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=nv>lst</span> <span class=nv>empty</span><span class=p>)))</span>
</code></pre></div></div><p>The type of <code class="language-plaintext highlighter-rouge">reverse</code> tells us that it is a function that takes a list of elements of some arbitrary type <code class="language-plaintext highlighter-rouge">a</code> as an argument and returns a list of elements of the same type. See <a href=https://docs.racket-lang.org/ts-guide/types.html#%28part._.Polymorphic_.Functions%29>Polymorphic Functions</a> in the guide.<p>The <code class="language-plaintext highlighter-rouge">letrec</code> defines a recursive function <code class="language-plaintext highlighter-rouge">f</code> that takes two lists of <code class="language-plaintext highlighter-rouge">a</code> as arguments and returns a list of <code class="language-plaintext highlighter-rouge">a</code>. Inside the <code class="language-plaintext highlighter-rouge">lambda</code>, each parameter is specified as <code class="language-plaintext highlighter-rouge">[var : type]</code> and the return type of the <code class="language-plaintext highlighter-rouge">lambda</code> is specified after the parameters. For example, <code class="language-plaintext highlighter-rouge">(lambda ([x : Number]) : Number x)</code> specifies that the <code class="language-plaintext highlighter-rouge">lambda</code> has one argument that’s a <code class="language-plaintext highlighter-rouge">Number</code> and returns a <code class="language-plaintext highlighter-rouge">Number</code>.<h2 id=your-task>Your task</h2><p>Implement the following functions in Typed Racket. Remember, each function you write must contain a proper type definition. This includes functions you define via <code class="language-plaintext highlighter-rouge">define</code> and those you define via <code class="language-plaintext highlighter-rouge">lambda</code>.<p>You may not implement these functions using any higher-order functions in the standard library (e.g., no <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">foldl</code>, <code class="language-plaintext highlighter-rouge">foldr</code>, or <code class="language-plaintext highlighter-rouge">apply</code>).<p>The provided starter code contains the examples as RackUnit tests. RackUnit in Typed Racket is buggy. The names of tests aren’t always reported correctly and the summary showing how many tests passed, failed, or had errors reports failed tests as having passed. Tests that fail still print their failure, they’re just counted as successes in the final summary.<ol><li><code class="language-plaintext highlighter-rouge">(fold-left proc init lst)</code>. This should behave like the standard library <code class="language-plaintext highlighter-rouge">foldl</code> function when called with a single list. Here are some examples <ul><li><code class="language-plaintext highlighter-rouge">(fold-left - 10 (range 10))</code> returns 15;<li><code class="language-plaintext highlighter-rouge">(fold-left (inst cons Symbol Null) empty '(a b c d))</code> returns <code class="language-plaintext highlighter-rouge">'(d c b a)</code>; and<li><div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>fold-left</span> <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>f</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=nv>Real</span> <span class=nv>Real</span><span class=p>)]</span>
               <span class=p>[</span><span class=nf>acc</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=nv>Real</span> <span class=nv>Real</span><span class=p>)])</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=nv>Real</span> <span class=nv>Real</span><span class=p>)</span>
             <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span>
               <span class=p>(</span><span class=nf>f</span> <span class=p>(</span><span class=nf>acc</span> <span class=nv>x</span><span class=p>))))</span>
           <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=nv>x</span><span class=p>)</span>
           <span class=p>(</span><span class=nb>list</span>
            <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>3</span> <span class=nv>x</span><span class=p>))</span>
            <span class=nv>add1</span>
            <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>-2</span> <span class=nv>x</span><span class=p>))</span>
            <span class=nv>sub1</span>
            <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nb>/</span> <span class=mi>143</span> <span class=nv>x</span><span class=p>))))</span>
</code></pre></div></div><p>returns a function that when called with argument 1 returns <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>−</mo><mn>1</mn><mn>3</mn></mrow><annotation encoding=application/x-tex>-13</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>−</span><span class=mord>1</span><span class=mord>3</span></span></span></span>.</ul><p>The second example includes <code class="language-plaintext highlighter-rouge">(inst cons Symbol Null)</code>. This is <a href=https://docs.racket-lang.org/ts-reference/special-forms.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fprims..rkt%29._inst%29%29><em>instantiating</em></a> the <code class="language-plaintext highlighter-rouge">cons</code> function to construct a <code class="language-plaintext highlighter-rouge">(Listof Symbol)</code>. The issue here is <code class="language-plaintext highlighter-rouge">cons</code> is polymorphic and Typed Racket doesn’t know what concrete type to give it. <code class="language-plaintext highlighter-rouge">cons</code> has two type arguments (its type is <code class="language-plaintext highlighter-rouge">(All (a b) …)</code>) and <code class="language-plaintext highlighter-rouge">(inst cons Symbol Null)</code> instantiates with the concrete types <code class="language-plaintext highlighter-rouge">Symbol</code> and <code class="language-plaintext highlighter-rouge">Null</code>. We can see this by asking DrRacket to print out types<pre><code class=language-raw>&gt; (:print-type cons)
(All (a b) (case-&gt;
            (-&gt; a (Listof a) (Listof a))
            (-&gt; a b (Pairof a b))))

&gt; (:print-type (inst cons Symbol Null))
(case-&gt;
 (-&gt; Symbol (Listof Symbol) (Listof Symbol))
 (-&gt; Symbol Symbol (List Symbol)))
</code></pre><p>The first type says <code class="language-plaintext highlighter-rouge">cons</code> either takes an element of some type <code class="language-plaintext highlighter-rouge">a</code> and a <code class="language-plaintext highlighter-rouge">(Listof a)</code> and produces a <code class="language-plaintext highlighter-rouge">(Listof a)</code> <em>or</em> it takes an element of some type <code class="language-plaintext highlighter-rouge">a</code> and an element of some type <code class="language-plaintext highlighter-rouge">b</code> and produces a pair. The second type instantiates <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">Symbol</code> and <code class="language-plaintext highlighter-rouge">b</code> with <code class="language-plaintext highlighter-rouge">Null</code> so it either takes a <code class="language-plaintext highlighter-rouge">Symbol</code> and a <code class="language-plaintext highlighter-rouge">(Listof Symbol)</code> and produces a <code class="language-plaintext highlighter-rouge">(Listof Symbol)</code>, or it takes a <code class="language-plaintext highlighter-rouge">Symbol</code> and <code class="language-plaintext highlighter-rouge">null</code> (the type of <code class="language-plaintext highlighter-rouge">null</code> is <code class="language-plaintext highlighter-rouge">Null</code>) and produces a 1-element list containing a <code class="language-plaintext highlighter-rouge">Symbol</code>.<li><code class="language-plaintext highlighter-rouge">(fold-right proc init lst)</code>. This should behave like the standard library <code class="language-plaintext highlighter-rouge">foldr</code> function when called with a single list. Here are some examples <ul><li><code class="language-plaintext highlighter-rouge">(fold-left - 10 (range 10))</code> returns 15;<li><code class="language-plaintext highlighter-rouge">(fold-left (inst cons Symbol Null) empty '(a b c d))</code> returns <code class="language-plaintext highlighter-rouge">'(d c b a)</code>; and<li><div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>fold-right</span> <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>f</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=nv>Real</span> <span class=nv>Real</span><span class=p>)]</span>
                <span class=p>[</span><span class=nf>acc</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=nv>Real</span> <span class=nv>Real</span><span class=p>)])</span> <span class=nv>:</span> <span class=p>(</span><span class=nf>-&gt;</span> <span class=nv>Real</span> <span class=nv>Real</span><span class=p>)</span>
              <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span>
                <span class=p>(</span><span class=nf>f</span> <span class=p>(</span><span class=nf>acc</span> <span class=nv>x</span><span class=p>))))</span>
            <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=nv>x</span><span class=p>)</span>
            <span class=p>(</span><span class=nb>list</span>
             <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>3</span> <span class=nv>x</span><span class=p>))</span>
             <span class=nv>add1</span>
             <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>-2</span> <span class=nv>x</span><span class=p>))</span>
             <span class=nv>sub1</span>
             <span class=p>(</span><span class=k>λ</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>:</span> <span class=nv>Real</span><span class=p>])</span> <span class=nv>:</span> <span class=nv>Real</span> <span class=p>(</span><span class=nb>/</span> <span class=mi>143</span> <span class=nv>x</span><span class=p>))))</span>
</code></pre></div></div><p>returns a function that when called with argument 1 returns <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>−</mo><mn>2</mn><mn>8</mn><mn>0</mn></mrow><annotation encoding=application/x-tex>-280</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>−</span><span class=mord>2</span><span class=mord>8</span><span class=mord>0</span></span></span></span>.</ul><li><p><code class="language-plaintext highlighter-rouge">(map proc lst)</code>. This should behave like the standard library function <code class="language-plaintext highlighter-rouge">map</code> when called with one list. Examples can be found in the provided starter code.<li><code class="language-plaintext highlighter-rouge">(scan-left proc init lst)</code>. This function behaves similarly to <code class="language-plaintext highlighter-rouge">fold-left</code> except that rather than return only the final value that comes from successively applying <code class="language-plaintext highlighter-rouge">proc</code> to elements of the list and the accumulator, it returns all of the values, starting with <code class="language-plaintext highlighter-rouge">init</code> and ending with the final value of <code class="language-plaintext highlighter-rouge">(fold-left proc init lst)</code>. Here is one example, others are in the provided starter code. <ul><li><code class="language-plaintext highlighter-rouge">(scan-left + 0 '(1 2 3 4))</code> returns <code class="language-plaintext highlighter-rouge">'(0 1 3 6 10)</code>.</ul><li><code class="language-plaintext highlighter-rouge">(scan-right proc init lst)</code>. This function behaves analogously to <code class="language-plaintext highlighter-rouge">scan-left</code> except that it starts at the right end of the list. The last element of the returned list is <code class="language-plaintext highlighter-rouge">init</code> and the first element is the final value of <code class="language-plaintext highlighter-rouge">(fold-right proc init lst)</code>. Here is one example, others are in the provided starter code. <ul><li><code class="language-plaintext highlighter-rouge">(scan-right + 0 '(1 2 3 4))</code> returns <code class="language-plaintext highlighter-rouge">'(10 9 7 4 0)</code>.</ul></ol><h2 id=finishing-up>Finishing up</h2><p>Make sure you (and your partner, if you have one!) have signed the Honor Code and then add/commit/push. Also make sure your name(s) is in all of the files you submit. Your friendly graders thank you!</main>