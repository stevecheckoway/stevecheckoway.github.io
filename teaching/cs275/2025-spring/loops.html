<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Loops in Racket</title><meta name=description content="Loops in Racket…for this course"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2025-spring/loops.html> <link rel=stylesheet href=/css/main.css><main><h1 id=loops-in-racketfor-this-course>Loops in Racket…for this course</h1><p>Looping behavior is common in programming languages. In CSCI 150, you learned about <code class="language-plaintext highlighter-rouge">for</code> and <code class="language-plaintext highlighter-rouge">while</code> loops in Python.<div class="language-python highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nf>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
    <span class=nf>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</code></pre></div></div><p>In CSCI 151, you saw similar loops in Java. Here’s a fragment of code summing the values stored in a linked list using a <code class="language-plaintext highlighter-rouge">while</code> loop.<div class="language-java highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nc>Node</span> <span class=o>*</span><span class=n>n</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
<span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
<span class=k>while</span> <span class=o>(</span><span class=n>n</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>sum</span> <span class=o>+=</span> <span class=n>n</span><span class=o>.</span><span class=na>val</span><span class=o>;</span>
    <span class=n>n</span> <span class=o>=</span> <span class=n>n</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></div></div><p>Racket has a number of constructs which provide loop-like behavior.<p>In CSCI 150, you learned another way to get loop-like behavior: recursion. <strong>In this course, you are required to use recursion and are forbidden from using loops.</strong><p>Let’s look at two common looping mechanisms in Racket that you may not use in this course and how to get the same behavior using recursion. (These are the two mechanisms you’re most likely to find if you search the Internet for loops and Racket.)<h2 id=for><code class="language-plaintext highlighter-rouge">for</code></h2><p>The first looping mechanism is <a href=https://docs.racket-lang.org/guide/for.html><code class="language-plaintext highlighter-rouge">for</code></a>. Here’s an example Racket program that performs the same computation as the Python loop above using Racket’s <code class="language-plaintext highlighter-rouge">for</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>for</span> <span class=p>([</span><span class=nf>x</span> <span class=p>(</span><span class=nf>range</span> <span class=mi>10</span><span class=p>)])</span>
  <span class=p>(</span><span class=nb>displayln</span> <span class=nv>x</span><span class=p>))</span>
</code></pre></div></div><p>The <em>semantics</em> of <code class="language-plaintext highlighter-rouge">for</code>—which is to say, the behavior of <code class="language-plaintext highlighter-rouge">for</code>—is to evaluate the body of the loop <code class="language-plaintext highlighter-rouge">(displayln x)</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to each element of the list in turn. That is, <code class="language-plaintext highlighter-rouge">(displayln 0)</code>, <code class="language-plaintext highlighter-rouge">(displayln 1)</code>, …, <code class="language-plaintext highlighter-rouge">(displayln 9)</code>.<p>The <em>functional programming</em> approach for such loops is to rewrite the loop to use explicit recursion. Here’s a template for basic recursion in Racket.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>some-recursive-function</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span> <span class=nv>base-case</span><span class=p>]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=nv>recursive-case</span><span class=p>]))</span>
</code></pre></div></div><p>This defines a function with the awkward name, <code class="language-plaintext highlighter-rouge">some-recursive-function</code> which takes a list as an argument and binds it to a variable named <code class="language-plaintext highlighter-rouge">lst</code>. If <code class="language-plaintext highlighter-rouge">lst</code> is the empty list, then <code class="language-plaintext highlighter-rouge">some-recursive-function</code> evaluates and returns the <code class="language-plaintext highlighter-rouge">base-case</code> expression (or expressions). Otherwise, the list is not empty and in the <code class="language-plaintext highlighter-rouge">recursive-case</code>, we can use <code class="language-plaintext highlighter-rouge">(first lst)</code> and make a recursive call, passing the rest of the list.<p>Here’s the complete example.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>display-list</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span> <span class=p>(</span><span class=nb>void</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span>
         <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>lst</span><span class=p>))</span>
         <span class=p>(</span><span class=nf>display-list</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>))]))</span>
</code></pre></div></div><p>Note that the <code class="language-plaintext highlighter-rouge">recursive-case</code> contains two expressions, the <code class="language-plaintext highlighter-rouge">displayln</code> and the recursive call to <code class="language-plaintext highlighter-rouge">display-list</code>. Most of the functions you’ll write in this class will involve constructing values rather than printing them (we let DrRacket print data for us in most cases). As a result, you’ll likely have just a single (potentially quite complex) expression for the recursive case (or cases) and you’ll do something with that result.<p>Here’s how we would sum up the values in a list which is a more typical example of recursion in Racket.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>sum</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span> <span class=mi>0</span><span class=p>]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>+</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>lst</span><span class=p>)</span>
                 <span class=p>(</span><span class=nf>sum</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>)))]))</span>
</code></pre></div></div><p>Notice that <code class="language-plaintext highlighter-rouge">0</code> is the base case and the recursive case adds the first element of the list to the result of the recursive call to <code class="language-plaintext highlighter-rouge">sum</code> on the rest of the list.<p>Note that <code class="language-plaintext highlighter-rouge">for</code> is designed for the unusual case where we don’t care about the <em>values</em> produced by the body of the loop. Instead, we only care about <em>side effects</em> like printing out values.<p>One consequence of this is we cannot use <code class="language-plaintext highlighter-rouge">for</code> to implement <code class="language-plaintext highlighter-rouge">sum</code> without using something else we’re not going to be using in this course: mutation. That is, we’d need to initialize some <code class="language-plaintext highlighter-rouge">sum</code> variable to <code class="language-plaintext highlighter-rouge">0</code> and then modify the value each time through the loop.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>bad-sum</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>sum</span> <span class=mi>0</span><span class=p>])</span>
    <span class=p>(</span><span class=nf>for</span> <span class=p>([</span><span class=nf>x</span> <span class=nv>lst</span><span class=p>])</span>
      <span class=p>(</span><span class=k>set!</span> <span class=nv>sum</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>sum</span> <span class=nv>x</span><span class=p>)))</span>
    <span class=nv>sum</span><span class=p>))</span>
</code></pre></div></div><p>This feels pretty natural when coming from an imperative language like Python or Java but it is not how we write functional code.<p>To be clear, <strong>you may not use <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">for*</code> or <code class="language-plaintext highlighter-rouge">for/list</code> or any other <code class="language-plaintext highlighter-rouge">for</code> construct in CSCI 275</strong>. Similarly, unless specifically directed to (in the MiniScheme project), <strong>you may not use <code class="language-plaintext highlighter-rouge">set!</code></strong> or any other function that involves modifying the values of variables.<h2 id=let-loop><code class="language-plaintext highlighter-rouge">let loop</code></h2><p>The second construct you’re likely to find if you search for loops and Racket is what’s known as a “named <code class="language-plaintext highlighter-rouge">let</code>.” A named <code class="language-plaintext highlighter-rouge">let</code> is simply syntactic sugar for some other common Racket syntax that you should use instead.<p>Here’s an example, again computing a sum of elements in a list.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>sum</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>let</span> <span class=nv>loop</span> <span class=p>([</span><span class=nf>lst</span> <span class=nv>lst</span><span class=p>]</span>
             <span class=p>[</span><span class=nf>result</span> <span class=mi>0</span><span class=p>])</span>
    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span>
        <span class=nv>result</span>
        <span class=p>(</span><span class=nf>loop</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>)</span>
              <span class=p>(</span><span class=nb>+</span> <span class=nv>result</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>lst</span><span class=p>))))))</span>
</code></pre></div></div><p>There’s nothing special about the name <code class="language-plaintext highlighter-rouge">loop</code> used in <code class="language-plaintext highlighter-rouge">let loop</code>, but it’s the name you’ll see most often. As you can see, this code gives the impression that there’s a loop happening here: There are two loop variables, <code class="language-plaintext highlighter-rouge">lst</code> and <code class="language-plaintext highlighter-rouge">result</code> which are initialized to the argument <code class="language-plaintext highlighter-rouge">lst</code> and <code class="language-plaintext highlighter-rouge">0</code>, respectively. The body of the loop checks if <code class="language-plaintext highlighter-rouge">lst</code> is empty and if so, returns <code class="language-plaintext highlighter-rouge">result</code>. Otherwise, it starts the next iteration of the loop with <code class="language-plaintext highlighter-rouge">lst</code> bound to the rest of <code class="language-plaintext highlighter-rouge">lst</code> and <code class="language-plaintext highlighter-rouge">result</code> bound to the sum of <code class="language-plaintext highlighter-rouge">result</code> and the first element of the list.<p>In reality, what is happening is this is defining a new function named <code class="language-plaintext highlighter-rouge">loop</code> that has two parameters, <code class="language-plaintext highlighter-rouge">lst</code> and <code class="language-plaintext highlighter-rouge">result</code>. The body of the <code class="language-plaintext highlighter-rouge">let</code> is the body of the <code class="language-plaintext highlighter-rouge">loop</code> function. Rather than starting the next iteration of the loop as I wrote above, calling <code class="language-plaintext highlighter-rouge">loop</code> is actually just making a standard recursive call.<p><code class="language-plaintext highlighter-rouge">let loop</code> implements what I have called “accumulator-passing style” in which functions have extra accumulator parameters which are used to store intermediate values of computation.<p>Let’s implement <code class="language-plaintext highlighter-rouge">sum</code> using an explicit recursive helper function.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>sum</span> <span class=nv>lst</span><span class=p>)</span>
  <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=nf>lst</span> <span class=nv>result</span><span class=p>)</span>
                <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nf>empty?</span> <span class=nv>lst</span><span class=p>)</span>
                    <span class=nv>result</span>
                    <span class=p>(</span><span class=nf>f</span> <span class=p>(</span><span class=nf>rest</span> <span class=nv>lst</span><span class=p>)</span>
                       <span class=p>(</span><span class=nb>+</span> <span class=nv>result</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>lst</span><span class=p>)))))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=nv>lst</span> <span class=mi>0</span><span class=p>)))</span>
</code></pre></div></div><p>This code is explicit that it’s creating a new recursive function named <code class="language-plaintext highlighter-rouge">f</code> that has parameters <code class="language-plaintext highlighter-rouge">lst</code> and <code class="language-plaintext highlighter-rouge">result</code>. The body of the <code class="language-plaintext highlighter-rouge">letrec</code> is the call to <code class="language-plaintext highlighter-rouge">f</code>, passing the initial values.<p>To be clear, <strong>you may not use named <code class="language-plaintext highlighter-rouge">let</code> (<code class="language-plaintext highlighter-rouge">let loop</code>) in this course</strong>. Use the explicit form with a <code class="language-plaintext highlighter-rouge">letrec</code> instead.</main>