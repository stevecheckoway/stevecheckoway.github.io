<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>MiniScheme interpreter</title><meta name=description content="MiniScheme interpreter"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2020-fall/minischeme.html> <link rel=stylesheet href=/css/main.css><style>ol>li{margin:1em}</style><main><h1 id=minischeme-interpreter>MiniScheme interpreter</h1><p>This page describes the MiniScheme interpreter you will implement over several weeks, starting with <a href=homeworks/hw5.html>homework 5</a>. Each part builds on the previous parts so make sure you keep up with the work or you’ll become very far behind.<p>Additional parts will be added as new assignments are released.<section><h2 id=part-1-environments>Part 1. Environments</h2><p>We need to create an environment to hold the data for the expressions we will interpret. The scoping rules for Scheme determine the structure of this environment. Consider the following three examples. First<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</code></pre></div></div><p>This has an environment with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> created in a let-block. These bindings are used in the body of the <code class="language-plaintext highlighter-rouge">let</code>.<p>Next, consider the following. This has a let-block that creates a lamba-expression, which is called in the body of the let:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=mi>4</span><span class=p>))])</span>
  <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>When this is evaluated we want to bind <code class="language-plaintext highlighter-rouge">x</code> to the value of the argument, <code class="language-plaintext highlighter-rouge">5</code>, and then evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> using that binding.<p>Finally, we combine these. At the outer level in the following expression we have a let-block with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. The body is another, nested, <code class="language-plaintext highlighter-rouge">let</code>, which binds a <code class="language-plaintext highlighter-rouge">lambda</code> expression with a parameter <code class="language-plaintext highlighter-rouge">x</code>. The body of the interior let is a call to the function.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>When we evaluate this we first make an environment with bindings of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> respectively, then we use this to evaluate the inner let-expression. In that expression we make a binding of <code class="language-plaintext highlighter-rouge">f</code> to the value of the lambda-expression (a closure, of course), and then we call <code class="language-plaintext highlighter-rouge">f</code> with argument <code class="language-plaintext highlighter-rouge">5</code>. This requires us to evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>. The body of <code class="language-plaintext highlighter-rouge">f</code> does not have a binding for <code class="language-plaintext highlighter-rouge">y</code>, so we look it up in the outer environment and see that its value is <code class="language-plaintext highlighter-rouge">3</code>. Finally, we evaluates <code class="language-plaintext highlighter-rouge">(+ x y)</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">y</code> bound to <code class="language-plaintext highlighter-rouge">3</code>, yielding <code class="language-plaintext highlighter-rouge">8</code> for the value of the full expression.<p>Environments are extended in two ways. Let-expressions have bindings that extend the current environment; the body of the <code class="language-plaintext highlighter-rouge">let</code> is evaluated in the extended environment. Lambda-expressions do not extend the environment; they evaluate to closures that store the current environment from the location where the <code class="language-plaintext highlighter-rouge">(lambda (...) ...)</code> is evaluated.<p>When the closure that results from a <code class="language-plaintext highlighter-rouge">lambda-expression</code> is called, the closure’s environment is extended with the parameters from the lambda-expression being bound to the values of the arguments.<p>We will define the environment as an association list, where symbols are associated with values. There are two ways we might do this. In the first example above, where <code class="language-plaintext highlighter-rouge">x</code> is bound to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">3</code>, we might use the list <code class="language-plaintext highlighter-rouge">'((x 2) (y 3))</code>, or we might use <code class="language-plaintext highlighter-rouge">'((x y) (2 3))</code>. The former structure is closer to the way the bindings appear in let-expressions; the latter is closer to the components of a call. The former structure might appear simpler, but the latter is actually easier to code and we will go with that.<p>Scheme, and many other languages you have and likely will learn, employs lexical scoping. When we want to resolve the binding for a free variable, we look first in the current scope, then in the surrounding scope, then in the scope that surrounds that, until the variable is found or we reach the outermost scope. To implement this our environments will be structured as a list with four elements: the symbol <code class="language-plaintext highlighter-rouge">'env</code>, a list of symbols, a list of values, and the previous environment. The top-most environment does not have a previous-environment (by definition) so we’ll use <code class="language-plaintext highlighter-rouge">null</code> to represent the empty environment.<p>Thus, the environment for the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>z</span> <span class=mi>4</span><span class=p>]</span> <span class=p>[</span><span class=nf>x</span> <span class=mi>5</span><span class=p>])</span>
    <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>y</span> <span class=nv>z</span><span class=p>))))</span>
</code></pre></div></div><p>will be something like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>'</span><span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>z</span> <span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nf>4</span> <span class=mi>5</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nf>2</span> <span class=mi>3</span><span class=p>)</span>
           <span class=p>()))</span>
</code></pre></div></div><p>When we resolve the bindings for <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> to evaluate <code class="language-plaintext highlighter-rouge">(+ x (+ y z))</code> we find the binding <code class="language-plaintext highlighter-rouge">5</code> for <code class="language-plaintext highlighter-rouge">x</code> (there are two bindings for <code class="language-plaintext highlighter-rouge">x</code>, but the one we want is is the first one we come to), and of course we find <code class="language-plaintext highlighter-rouge">4</code> for <code class="language-plaintext highlighter-rouge">z</code> and <code class="language-plaintext highlighter-rouge">3</code> for <code class="language-plaintext highlighter-rouge">y</code>. This leads to the correct value, <code class="language-plaintext highlighter-rouge">12</code> for the expression.<p>Similarly, in the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>we evaluate the call <code class="language-plaintext highlighter-rouge">(f 5)</code> by evaluating the body of <code class="language-plaintext highlighter-rouge">f</code> in an environment that first has <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>, and then has the environment surrounding the definition of <code class="language-plaintext highlighter-rouge">f</code>.<p>You will see in later parts how this environment is created. At present we need to create the tools that will allow this.</section><section><h2 id=part-2-the-environment-data-type>Part 2. The environment data type</h2><p>The two most important features of an environment are that we need to be able to look up symbols to get the values they are bound to, and we need to be able to extend an environment with new bindings to get a new environment. We’ll define an environment as either the empty environment, with no bindings, or an extended environment with a list of symbols, a corresponding list of the values those symbols are bound to, and a previous environment that is being extended. Here is the definition of the empty environment and a constructor for an extended environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; The empty environment is null.</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>empty-env</span> <span class=nv>null</span><span class=p>)</span>

<span class=c1>; Environment constructor.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env</span> <span class=nv>syms</span> <span class=nv>vals</span> <span class=nv>previous-env</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>syms</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"syms is not a list"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>vals</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"vals is not a list"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nf>env?</span> <span class=nv>previous-env</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"previous-env is not an env"</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>list</span> <span class=ss>'env</span> <span class=nv>syms</span> <span class=nv>vals</span> <span class=nv>previous-env</span><span class=p>)]))</span>
</code></pre></div></div><p>Note that <code class="language-plaintext highlighter-rouge">env</code> is the procedure you will use every time you need to extend an environment when evaluating a let-expression or a function call. For example, when evaluating the expression <code class="language-plaintext highlighter-rouge">(let ([x 1] [y 2]) ...)</code> we might use the following.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>We can further extend this environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>This data type has easy recognizer functions.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; Environment recognizers.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=nb>null?</span> <span class=nv>e</span><span class=p>))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>e</span><span class=p>)</span>
       <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>null?</span> <span class=nv>e</span><span class=p>))</span>
       <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>e</span><span class=p>)</span> <span class=ss>'env</span><span class=p>)))</span>
</code></pre></div></div><p>The accessor functions for the different fields of an extended environment are also easy.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; Environment accessors.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-syms</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>empty</span><span class=p>]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>second</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-syms</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-vals</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>empty</span><span class=p>]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>third</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-vals</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-previous</span> <span class=s>"e has no previous env"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>fourth</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-previous</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>
</code></pre></div></div><p>All that remains is to build some helper functions to look up bindings in an environment.</section><section><h2 id=part-3-implementing-the-environment-lookup>Part 3. Implementing the environment lookup</h2><p>The file <code class="language-plaintext highlighter-rouge">env.rkt</code> contains the code given above for the environment data type. Add to this file function <code class="language-plaintext highlighter-rouge">(env-lookup environment symbol)</code>, which takes an environment and a symbol and returns the first binding for that symbol in the environment. For example, with environments <code class="language-plaintext highlighter-rouge">env-a</code> and <code class="language-plaintext highlighter-rouge">env-b</code> defined as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>we should have the following behavior:<ul><li><code class="language-plaintext highlighter-rouge">(lookup env-a 'x)</code> should return 1<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'x)</code> should return 5<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'y)</code> should return 2<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'foo)</code> should cause an error</ul><p>If <code class="language-plaintext highlighter-rouge">env-lookup</code> does not find a binding for the symbol you should invoke the error handler <code class="language-plaintext highlighter-rouge">(error sym string)</code>, as in<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nb>error</span> <span class=ss>'env-lookup</span> <span class=s>"No binding for ~s"</span> <span class=nv>sym</span><span class=p>)</span>
</code></pre></div></div><p>Make sure you <code class="language-plaintext highlighter-rouge">provide</code> <code class="language-plaintext highlighter-rouge">env-lookup</code> at the top of <code class="language-plaintext highlighter-rouge">env.rkt</code> so that modules you’ll write in future parts (and in the tests described below) can use that procedure.<p>The file <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> contains a <code class="language-plaintext highlighter-rouge">test-env</code> environment that maps <code class="language-plaintext highlighter-rouge">x</code> to 1 and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code>. In addition it defines an <code class="language-plaintext highlighter-rouge">env-tests</code> test suite that tests the basic behavior of the environment data type. Extend this test suite with additional tests for <code class="language-plaintext highlighter-rouge">env-lookup</code>. You will probably want to define new extended environments for your tests.<p>In particular, be sure to test at least the following situations<ul><li>Looking up a symbol that’s not bound in an environment throws an error. You’ll want to use the <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-exn%29%29><code class="language-plaintext highlighter-rouge">test-exn</code> procedure</a>. Unlike <code class="language-plaintext highlighter-rouge">test-true</code>, <code class="language-plaintext highlighter-rouge">test-false</code>, and <code class="language-plaintext highlighter-rouge">test-equal?</code>, <code class="language-plaintext highlighter-rouge">test-exn</code> expects a 0-argument procedure which, when run, throws an error. For example, <div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-exn</span> <span class=s>"Empty environment has no previous"</span>
          <span class=nv>exn:fail?</span>
          <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>is testing that <code class="language-plaintext highlighter-rouge">(env-previous empty-env)</code> throws an error. You’ll want something very similar.<li>Looking up a symbol in an empty environment throws an error.<li>Looking up a symbol that’s bound in an environment returns its value.<li>Looking up a symbol that’s not bound in an environment but is bound in the environment’s previous environment returns the correct value.<li>Looking up a symbol that’s bound in an environment and also in the environment’s previous environment returns the correct value (see examples above).</ul></section></main>