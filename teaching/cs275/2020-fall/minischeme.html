<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>MiniScheme interpreter</title><meta name=description content="MiniScheme interpreter"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2020-fall/minischeme.html> <link rel=stylesheet href=/css/main.css><style>ol>li{margin:1em}</style><main><h1 id=minischeme-interpreter>MiniScheme interpreter</h1><p>This page describes the MiniScheme interpreter you will implement over several weeks, starting with <a href=homeworks/hw5.html>homework 5</a>. Each part builds on the previous parts so make sure you keep up with the work or you’ll become very far behind.<p>Additional parts will be added as new assignments are released.<section><h2 id=part-1-environments>Part 1. Environments</h2><p>We need to create an environment to hold the data for the expressions we will interpret. The scoping rules for Scheme determine the structure of this environment. Consider the following three examples. First<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</code></pre></div></div><p>This has an environment with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> created in a let-block. These bindings are used in the body of the <code class="language-plaintext highlighter-rouge">let</code>.<p>Next, consider the following. This has a let-block that creates a lamba-expression, which is called in the body of the let:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=mi>4</span><span class=p>))])</span>
  <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>When this is evaluated we want to bind <code class="language-plaintext highlighter-rouge">x</code> to the value of the argument, <code class="language-plaintext highlighter-rouge">5</code>, and then evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> using that binding.<p>Finally, we combine these. At the outer level in the following expression we have a let-block with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. The body is another, nested, <code class="language-plaintext highlighter-rouge">let</code>, which binds a <code class="language-plaintext highlighter-rouge">lambda</code> expression with a parameter <code class="language-plaintext highlighter-rouge">x</code>. The body of the interior let is a call to the function.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>When we evaluate this we first make an environment with bindings of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> respectively, then we use this to evaluate the inner let-expression. In that expression we make a binding of <code class="language-plaintext highlighter-rouge">f</code> to the value of the lambda-expression (a closure, of course), and then we call <code class="language-plaintext highlighter-rouge">f</code> with argument <code class="language-plaintext highlighter-rouge">5</code>. This requires us to evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>. The body of <code class="language-plaintext highlighter-rouge">f</code> does not have a binding for <code class="language-plaintext highlighter-rouge">y</code>, so we look it up in the outer environment and see that its value is <code class="language-plaintext highlighter-rouge">3</code>. Finally, we evaluates <code class="language-plaintext highlighter-rouge">(+ x y)</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">y</code> bound to <code class="language-plaintext highlighter-rouge">3</code>, yielding <code class="language-plaintext highlighter-rouge">8</code> for the value of the full expression.<p>Environments are extended in two ways. Let-expressions have bindings that extend the current environment; the body of the <code class="language-plaintext highlighter-rouge">let</code> is evaluated in the extended environment. Lambda-expressions do not extend the environment; they evaluate to closures that store the current environment from the location where the <code class="language-plaintext highlighter-rouge">(lambda (...) ...)</code> is evaluated.<p>When the closure that results from a <code class="language-plaintext highlighter-rouge">lambda-expression</code> is called, the closure’s environment is extended with the parameters from the lambda-expression being bound to the values of the arguments.<p>We will define the environment as an association list, where symbols are associated with values. There are two ways we might do this. In the first example above, where <code class="language-plaintext highlighter-rouge">x</code> is bound to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">3</code>, we might use the list <code class="language-plaintext highlighter-rouge">'((x 2) (y 3))</code>, or we might use <code class="language-plaintext highlighter-rouge">'((x y) (2 3))</code>. The former structure is closer to the way the bindings appear in let-expressions; the latter is closer to the components of a call. The former structure might appear simpler, but the latter is actually easier to code and we will go with that.<p>Scheme, and many other languages you have and likely will learn, employs lexical scoping. When we want to resolve the binding for a free variable, we look first in the current scope, then in the surrounding scope, then in the scope that surrounds that, until the variable is found or we reach the outermost scope. To implement this our environments will be structured as a list with four elements: the symbol <code class="language-plaintext highlighter-rouge">'env</code>, a list of symbols, a list of values, and the previous environment. The top-most environment does not have a previous-environment (by definition) so we’ll use <code class="language-plaintext highlighter-rouge">null</code> to represent the empty environment.<p>Thus, the environment for the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>z</span> <span class=mi>4</span><span class=p>]</span> <span class=p>[</span><span class=nf>x</span> <span class=mi>5</span><span class=p>])</span>
    <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>y</span> <span class=nv>z</span><span class=p>))))</span>
</code></pre></div></div><p>will be something like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>'</span><span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>z</span> <span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nf>4</span> <span class=mi>5</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nf>2</span> <span class=mi>3</span><span class=p>)</span>
           <span class=p>()))</span>
</code></pre></div></div><p>When we resolve the bindings for <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> to evaluate <code class="language-plaintext highlighter-rouge">(+ x (+ y z))</code> we find the binding <code class="language-plaintext highlighter-rouge">5</code> for <code class="language-plaintext highlighter-rouge">x</code> (there are two bindings for <code class="language-plaintext highlighter-rouge">x</code>, but the one we want is is the first one we come to), and of course we find <code class="language-plaintext highlighter-rouge">4</code> for <code class="language-plaintext highlighter-rouge">z</code> and <code class="language-plaintext highlighter-rouge">3</code> for <code class="language-plaintext highlighter-rouge">y</code>. This leads to the correct value, <code class="language-plaintext highlighter-rouge">12</code> for the expression.<p>Similarly, in the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>we evaluate the call <code class="language-plaintext highlighter-rouge">(f 5)</code> by evaluating the body of <code class="language-plaintext highlighter-rouge">f</code> in an environment that first has <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>, and then has the environment surrounding the definition of <code class="language-plaintext highlighter-rouge">f</code>.<p>You will see in later parts how this environment is created. At present we need to create the tools that will allow this.</section><section><h2 id=part-2-the-environment-data-type>Part 2. The environment data type</h2><p>The two most important features of an environment are that we need to be able to look up symbols to get the values they are bound to, and we need to be able to extend an environment with new bindings to get a new environment. We’ll define an environment as either the empty environment, with no bindings, or an extended environment with a list of symbols, a corresponding list of the values those symbols are bound to, and a previous environment that is being extended. Here is the definition of the empty environment and a constructor for an extended environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; The empty environment is null.</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>empty-env</span> <span class=nv>null</span><span class=p>)</span>

<span class=c1>; Environment constructor.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env</span> <span class=nv>syms</span> <span class=nv>vals</span> <span class=nv>previous-env</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>syms</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"syms is not a list"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>vals</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"vals is not a list"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nf>env?</span> <span class=nv>previous-env</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"previous-env is not an env"</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>list</span> <span class=ss>'env</span> <span class=nv>syms</span> <span class=nv>vals</span> <span class=nv>previous-env</span><span class=p>)]))</span>
</code></pre></div></div><p>Note that <code class="language-plaintext highlighter-rouge">env</code> is the procedure you will use every time you need to extend an environment when evaluating a let-expression or a function call. For example, when evaluating the expression <code class="language-plaintext highlighter-rouge">(let ([x 1] [y 2]) ...)</code> we might use the following.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>We can further extend this environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>This data type has easy recognizer functions.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; Environment recognizers.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=nb>null?</span> <span class=nv>e</span><span class=p>))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>e</span><span class=p>)</span>
       <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>null?</span> <span class=nv>e</span><span class=p>))</span>
       <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>e</span><span class=p>)</span> <span class=ss>'env</span><span class=p>)))</span>
</code></pre></div></div><p>The accessor functions for the different fields of an extended environment are also easy.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; Environment accessors.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-syms</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>empty</span><span class=p>]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>second</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-syms</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-vals</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>empty</span><span class=p>]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>third</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-vals</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-previous</span> <span class=s>"e has no previous env"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>fourth</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-previous</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>
</code></pre></div></div><p>All that remains is to build some helper functions to look up bindings in an environment.</section><section><h2 id=part-3-implementing-the-environment-lookup>Part 3. Implementing the environment lookup</h2><p>The file <code class="language-plaintext highlighter-rouge">env.rkt</code> contains the code given above for the environment data type. Add to this file function <code class="language-plaintext highlighter-rouge">(env-lookup environment symbol)</code>, which takes an environment and a symbol and returns the first binding for that symbol in the environment. For example, with environments <code class="language-plaintext highlighter-rouge">env-a</code> and <code class="language-plaintext highlighter-rouge">env-b</code> defined as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>we should have the following behavior:<ul><li><code class="language-plaintext highlighter-rouge">(lookup env-a 'x)</code> should return 1<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'x)</code> should return 5<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'y)</code> should return 2<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'foo)</code> should cause an error</ul><p>If <code class="language-plaintext highlighter-rouge">env-lookup</code> does not find a binding for the symbol you should invoke the error handler <code class="language-plaintext highlighter-rouge">(error sym string)</code>, as in<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nb>error</span> <span class=ss>'env-lookup</span> <span class=s>"No binding for ~s"</span> <span class=nv>sym</span><span class=p>)</span>
</code></pre></div></div><p>Make sure you <code class="language-plaintext highlighter-rouge">provide</code> <code class="language-plaintext highlighter-rouge">env-lookup</code> at the top of <code class="language-plaintext highlighter-rouge">env.rkt</code> so that modules you’ll write in future parts (and in the tests described below) can use that procedure.<p>The file <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> contains a <code class="language-plaintext highlighter-rouge">test-env</code> environment that maps <code class="language-plaintext highlighter-rouge">x</code> to 1 and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code>. In addition it defines an <code class="language-plaintext highlighter-rouge">env-tests</code> test suite that tests the basic behavior of the environment data type. Extend this test suite with additional tests for <code class="language-plaintext highlighter-rouge">env-lookup</code>. You will probably want to define new extended environments for your tests.<p>In particular, be sure to test at least the following situations<ul><li>Looking up a symbol that’s not bound in an environment throws an error. You’ll want to use the <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-exn%29%29><code class="language-plaintext highlighter-rouge">test-exn</code> procedure</a>. Unlike <code class="language-plaintext highlighter-rouge">test-true</code>, <code class="language-plaintext highlighter-rouge">test-false</code>, and <code class="language-plaintext highlighter-rouge">test-equal?</code>, <code class="language-plaintext highlighter-rouge">test-exn</code> expects a 0-argument procedure which, when run, throws an error. For example, <div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-exn</span> <span class=s>"Empty environment has no previous"</span>
          <span class=nv>exn:fail?</span>
          <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>is testing that <code class="language-plaintext highlighter-rouge">(env-previous empty-env)</code> throws an error. You’ll want something very similar.<li>Looking up a symbol in an empty environment throws an error.<li>Looking up a symbol that’s bound in an environment returns its value.<li>Looking up a symbol that’s not bound in an environment but is bound in the environment’s previous environment returns the correct value.<li>Looking up a symbol that’s bound in an environment and also in the environment’s previous environment returns the correct value (see examples above).</ul><p><strong>This is the end of homework 5. The other parts will be completed in homeworks 6 and 7.</strong></section><section id=minischeme-a><h2 id=part-4-minischeme-version-a>Part 4: MiniScheme version A</h2><p>We will start with a very basic version of our MiniScheme language, version A, and gradually add language features. As we do so, we will update our parser and interpreter to implement the new language features.<p>As a convention, the parser and interpreter for MiniScheme will reside in files <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>, respectively. After you complete each of the remaining parts, you should be sure to commit your code. That way, you can always retrieve an earlier version if you need to.<p>In addition to <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>, you will use <code class="language-plaintext highlighter-rouge">env.rkt</code> from Part 3 so make sure your <code class="language-plaintext highlighter-rouge">env-lookup</code> procedure works!<p>Here’s what you’ll have in each file.<ul><li><code class="language-plaintext highlighter-rouge">parse.rkt</code>: Tree data types and the <code class="language-plaintext highlighter-rouge">parse</code> procedure which converts the input to a tree to interpret;<li><code class="language-plaintext highlighter-rouge">interp.rkt</code>: Initially just <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure which takes a parse tree and an environment and produces a value and <code class="language-plaintext highlighter-rouge">init-env</code> which will hold the initial environment; and<li><code class="language-plaintext highlighter-rouge">env.rkt</code>: Environment data type and <code class="language-plaintext highlighter-rouge">env-lookup</code> procedure</ul><p>As you go, think about where to put new definitions. Racket has trouble with circular requirements (such as <code class="language-plaintext highlighter-rouge">parse.rkt</code> requiring <code class="language-plaintext highlighter-rouge">interp.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code> requiring <code class="language-plaintext highlighter-rouge">parse.rkt</code>). You probably want your <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">env.rkt</code> files to not require any other module, and your <code class="language-plaintext highlighter-rouge">interp.rkt</code> file to require both <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">env.rkt</code>.<p>In addition to those files, we’ll have some testing files.<ul><li><code class="language-plaintext highlighter-rouge">parse-tests.rkt</code>: This defines a test suite for the parser;<li><code class="language-plaintext highlighter-rouge">interp-tests.rkt</code>: This defines a test suite for the interpreter;<li><code class="language-plaintext highlighter-rouge">env-tests.rkt</code>: This defines tests for the environment; and<li><code class="language-plaintext highlighter-rouge">tests.rkt</code>: This combines the other three test suites into a single <code class="language-plaintext highlighter-rouge">all-tests</code> test suite and runs it.</ul><p>Version A of MiniScheme is given by the following grammar.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
</code></pre></div></div><p>Our parse procedure will take an input expression and return a parse tree for an <code class="language-plaintext highlighter-rouge">EXP</code>. The only expressions in MiniScheme A are numbers. Admittedly, this is not very exciting but it is a place to start. Our interpreter for MiniScheme A will be very basic as well.<p>In <code class="language-plaintext highlighter-rouge">parse.rkt</code> we need a data type to hold <code class="language-plaintext highlighter-rouge">EXP</code> nodes that represent numbers. An easy solution is to make a list out of an atom (such as ‘lit-exp) that identifies the data type and the numeric value being represented. There are other possible representations and it doesn’t matter which you choose as long as you have a constructor (which I’ll call <code class="language-plaintext highlighter-rouge">lit-exp</code>), recognizer <code class="language-plaintext highlighter-rouge">lit-exp?</code> and getter <code class="language-plaintext highlighter-rouge">lit-exp-num</code>. You can use any names you want; the only required names are <code class="language-plaintext highlighter-rouge">parse</code> (for the parser), <code class="language-plaintext highlighter-rouge">eval-exp</code> (for the interpreter) and <code class="language-plaintext highlighter-rouge">init-env</code> (for the initial environment).<p>The parse function simply creates a <code class="language-plaintext highlighter-rouge">lit-exp</code> when it sees a number (and throws an error otherwise). It looks like this<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse</span> <span class=nv>input</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>number?</span> <span class=nv>input</span><span class=p>)</span> <span class=p>(</span><span class=nf>lit-exp</span> <span class=nv>input</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>)]))</span>
</code></pre></div></div><p>Save this code and the code that implements the <code class="language-plaintext highlighter-rouge">lit-exp</code> data type, in <code class="language-plaintext highlighter-rouge">parse.rkt</code>. Make this file into a module by adding the appropriate provide lines to make the <code class="language-plaintext highlighter-rouge">parse</code> procedure and the procedures for <code class="language-plaintext highlighter-rouge">lit-exp</code> (or whatever you call it) available to other modules.<p>Before moving on to the interpreter, copy your code for <code class="language-plaintext highlighter-rouge">env.rkt</code> and <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> to your new repository. Remove the line <code class="language-plaintext highlighter-rouge">(run-tests env-tests)</code> from <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> since the <code class="language-plaintext highlighter-rouge">env-tests</code> test suite will be run by <code class="language-plaintext highlighter-rouge">tests.rkt</code> from now on.<p>In <code class="language-plaintext highlighter-rouge">parse-tests.rkt</code>, add tests for <code class="language-plaintext highlighter-rouge">parse</code>. In particular, you should test that <code class="language-plaintext highlighter-rouge">(parse 5)</code> returns something that <code class="language-plaintext highlighter-rouge">lit-exp?</code> evaluates to true. (You may wish to use the <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-pred%29%29><code class="language-plaintext highlighter-rouge">test-pred</code></a> procedure.)<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-pred</span> <span class=s>"Literal"</span>
           <span class=nv>lit-exp?</span>
           <span class=p>(</span><span class=nf>parse</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>Test that when you parse a number, you can extract the number from the resultant parse tree using <code class="language-plaintext highlighter-rouge">lit-exp-num</code>.<p>For the interpreter, you know that Scheme evaluates all integers as themselves. Our evaluation function will be very simple. It looks like this.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>eval-exp</span> <span class=nv>tree</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>lit-exp?</span> <span class=nv>tree</span><span class=p>)</span> <span class=p>(</span><span class=nf>lit-exp-num</span> <span class=nv>tree</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'eval-exp</span> <span class=s>"Invalid tree: ~s"</span> <span class=nv>tree</span><span class=p>)]))</span>
</code></pre></div></div><p>Save this code as <code class="language-plaintext highlighter-rouge">interp.rkt</code>. Make sure you require <code class="language-plaintext highlighter-rouge">parse.rkt</code> and (for the next step) <code class="language-plaintext highlighter-rouge">env.rkt</code>. Similarly, make sure you <code class="language-plaintext highlighter-rouge">provide</code> <code class="language-plaintext highlighter-rouge">eval-exp</code> for use by other modules.<p>We can interpret expressions in the command interpreter of the <code class="language-plaintext highlighter-rouge">interp.rkt</code> file. Run this file in DrRacket to load the interpreter and parser into memory, then type into the command interpreter:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define</span> <span class=nv>T</span> <span class=p>(</span><span class=nf>parse</span> <span class=ss>'23</span><span class=p>))</span>
<span class=nv>&gt;</span> <span class=p>(</span><span class=nf>eval-exp</span> <span class=nv>T</span> <span class=nv>empty-env</span><span class=p>)</span>
</code></pre></div></div><p>This should print the value 23.<p>It quickly becomes tedious to always invoke your interpreter by specifically calling the interpreter <code class="language-plaintext highlighter-rouge">eval-exp</code> after calling the parser on the quoted expression. It would be nice if we could write a read-eval-print loop for MiniScheme. This is precisely what <code class="language-plaintext highlighter-rouge">minischeme.rkt</code> does.<p>Running this program in DrRacket will give you an input box that allows you to type expressions and get back their value as determined by your <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">interp</code> modules. . For example, if you enter the MiniScheme expression 23 this evaluates it and prints its value 23.<p>The read-eval-print procedure assumes that your parse procedure is named <code class="language-plaintext highlighter-rouge">parse</code>; that your evaluator is called <code class="language-plaintext highlighter-rouge">eval-exp</code> that takes as arguments a parse tree and an environment, in that order; and an initial environment named <code class="language-plaintext highlighter-rouge">init-env</code>.<p>Inside <code class="language-plaintext highlighter-rouge">interp.rkt</code>, <code class="language-plaintext highlighter-rouge">define</code> and <code class="language-plaintext highlighter-rouge">provide</code> an <code class="language-plaintext highlighter-rouge">init-env</code>. For the <code class="language-plaintext highlighter-rouge">init-env</code>, use your <code class="language-plaintext highlighter-rouge">env</code> constructor to create an environment mapping <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">23</code> and <code class="language-plaintext highlighter-rouge">y</code> to 42`. For MiniScheme A, these mappings are of no use, but they will be shortly.<p>The last thing we need to do for MiniScheme A is to write some tests. In <code class="language-plaintext highlighter-rouge">interp-tests.rkt</code>, write a test like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-equal?</span> <span class=s>"Number"</span>
             <span class=p>(</span><span class=nf>eval-exp</span> <span class=p>(</span><span class=nf>lit-exp</span> <span class=mi>5</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>)</span>
             <span class=mi>5</span><span class=p>)</span>
</code></pre></div></div><p>Note that we’re explicitly passing the parse tree <code class="language-plaintext highlighter-rouge">(lit-exp 5)</code> rather than calling <code class="language-plaintext highlighter-rouge">(parse 5)</code>. This lets you separately test parsing from evaluating. In subsequent parts, you’ll be modifying <code class="language-plaintext highlighter-rouge">parse</code>. You don’t want a bug in <code class="language-plaintext highlighter-rouge">parse</code> to show up as a bug in <code class="language-plaintext highlighter-rouge">eval-exp</code>. By not using <code class="language-plaintext highlighter-rouge">parse</code> in your interpreter tests, you can keep the two separate.<p>Congratulations, at this point you should have a working interpreter for MiniScheme A! Make sure you commit your work at this point.</section><section id=minischeme-b><h2 id=part-5-minischeme-version-b-variables-and-definitions>Part 5: MiniScheme version B, variables and definitions</h2><p>MiniScheme A is somewhat lacking in utility. Our specification for MiniScheme B will be only slightly more interesting.<p>We will start with the following grammar for MiniScheme B.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
</code></pre></div></div><p>The parser is a simple modification to <code class="language-plaintext highlighter-rouge">parse</code>. You need to add a line to <code class="language-plaintext highlighter-rouge">(parse input)</code> to handle the case where <code class="language-plaintext highlighter-rouge">(symbol? input)</code> is <code class="language-plaintext highlighter-rouge">#t</code>. Of course, you need a <code class="language-plaintext highlighter-rouge">var-exp</code> data type including a constructor (I call it <code class="language-plaintext highlighter-rouge">var-exp</code>), recognizer (<code class="language-plaintext highlighter-rouge">var-exp?</code>) and getter (<code class="language-plaintext highlighter-rouge">var-exp-symbol</code>).<p>To evaluate a variable expression, MiniScheme B needs to be able to look up references. We evaluate a <code class="language-plaintext highlighter-rouge">var-exp</code> tree node in a given environment by calling lookup in that environment on the <code class="language-plaintext highlighter-rouge">var-exp-symbol</code>. Since we asked you to include bindings for symbols <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in the initial environment in Part 4, you should be able to evaluate the MiniScheme expressions <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">y</code> to get their values. Any other symbol at this point should give you an error message.<p>Make sure you commit your work at this point.</section><section id=minischeme-c><h2 id=part-6-minischeme-version-c-calls-to-primitive-procedures>Part 6: MiniScheme version C, calls to primitive procedures</h2><p>This is a good point to add primitive arithmetic operators to our environment. Nothing needs to be done for parsing–operators like <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code> and so forth are symbols, so they will be parsed to <code class="language-plaintext highlighter-rouge">var-exp</code> nodes. Our environment needs to associate these symbols to values. There are many ways to do this; the way we will use will be easy to expand to procedures derived from lambda expressions. We will first make a data type <code class="language-plaintext highlighter-rouge">prim-proc</code> to represent primitive procedures. This is simple; the only data this type needs to carry is the symbol for the operator, so this looks just like the <code class="language-plaintext highlighter-rouge">var-exp</code> type. Make a constructor, a recognizer, and a getter for the data type.<p>Think about which file should contain this data type definition. Keep in mind that <em>nothing in the parser needed to change to support these primitive procedures</em>.<p>Next, we make a list of the primitive arithmetic operators. You can start with the following and later expand it.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>primitive-operators</span> <span class=o>'</span><span class=p>(</span><span class=nb>+</span> <span class=nv>-</span> <span class=nv>*</span> <span class=nv>/</span><span class=p>)</span>
</code></pre></div></div><p>We can define a primative operator environment and make our <code class="language-plaintext highlighter-rouge">init-env</code> extend that instead of the <code class="language-plaintext highlighter-rouge">empty-env</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>prim-env</span>
  <span class=p>(</span><span class=nf>env</span> <span class=nv>primitave-operators</span>
       <span class=p>(</span><span class=nb>map</span> <span class=nv>prim-proc</span> <span class=nv>primitave-operators</span><span class=p>)</span>
       <span class=nv>empty-env</span><span class=p>))</span>

<span class=p>(</span><span class=k>define</span> <span class=nv>init-env</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span>
       <span class=o>'</span><span class=p>(</span><span class=nf>23</span> <span class=mi>42</span><span class=p>)</span>
       <span class=nv>prim-env</span><span class=p>))</span>
</code></pre></div></div><p>This means that when we evaluate + by looking it up in the environment we will get the structure <code class="language-plaintext highlighter-rouge">'(prim-proc +)</code><p>We will now extend the grammar to include applications so we can use our primitive operators.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (EXP EXP*)                  parse into app-exp
</code></pre></div></div><p>This gives us a language that can do something. You need to implement an <code class="language-plaintext highlighter-rouge">app-exp</code> data type that can hold a procedure (which is itself a tree) and a list of argument expressions (again, these are trees). The constructor for that might be <code class="language-plaintext highlighter-rouge">(app-exp proc args)</code>. Update the parser to build an <code class="language-plaintext highlighter-rouge">app-exp</code> node when the expression being parsed is a list.<p>We now have a <code class="language-plaintext highlighter-rouge">parse</code> procedure that looks like this.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse</span> <span class=nv>input</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>number?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>symbol?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>list?</span> <span class=nv>input</span><span class=p>)</span>
         <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>input</span><span class=p>)</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>)]</span>
               <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nf>app-exp</span> <span class=p>(</span><span class=nf>parse</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>input</span><span class=p>))</span> <span class=o>...</span><span class=p>)])]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>)]))</span>
</code></pre></div></div><p>Remember to parse both the operator and the list of operands.<p>One thing to notice about this is that we have duplicated the <code class="language-plaintext highlighter-rouge">(error ...)</code> line. We can simplify our code slightly by extracting that out into a 0-argument <code class="language-plaintext highlighter-rouge">parse-error</code> procedure.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse</span> <span class=nv>input</span><span class=p>)</span>
  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse-error</span><span class=p>)</span>
    <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>))</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>number?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>symbol?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>list?</span> <span class=nv>input</span><span class=p>)</span>
         <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>input</span><span class=p>)</span> <span class=p>(</span><span class=nf>parse-error</span><span class=p>)]</span>
               <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nf>app-exp</span> <span class=p>(</span><span class=nf>parse</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>input</span><span class=p>))</span> <span class=o>...</span><span class=p>)])]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nf>parse-error</span><span class=p>)]))</span>
</code></pre></div></div><p>Add tests to <code class="language-plaintext highlighter-rouge">parse-tests</code> to test that applications are parsed correctly. Make sure you test parsing applications with different numbers of parameters <code class="language-plaintext highlighter-rouge">(foo)</code>, <code class="language-plaintext highlighter-rouge">(bar 1)</code>, <code class="language-plaintext highlighter-rouge">(baz x y)</code>, etc. Add a test that <code class="language-plaintext highlighter-rouge">'()</code> causes an error. Look at <a href=#part-3-implementing-the-environment-lookup>Part 3</a> for how to write a test for an error.<p>In the <code class="language-plaintext highlighter-rouge">interp</code> module we extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to evaluate an <code class="language-plaintext highlighter-rouge">app-exp</code> node by calling a new procedure <code class="language-plaintext highlighter-rouge">apply-proc</code> with the evaluated operator and the list of evaluated arguments. Here is <code class="language-plaintext highlighter-rouge">apply-proc</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-proc</span> <span class=nv>proc</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>prim-proc?</span> <span class=nv>proc</span><span class=p>)</span>
         <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=p>(</span><span class=nf>prim-proc-op</span> <span class=nv>proc</span><span class=p>)</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-proc</span> <span class=s>"bad procedure: ~s"</span> <span class=nv>proc</span><span class=p>)]))</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">apply-primitive-op</code> procedure takes a symbol corresponding to the primitive procedure and a list of argument values. Here is one possible <code class="language-plaintext highlighter-rouge">apply-primitive-op</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=nv>op</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'+</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>+</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'-</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>-</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'*</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>*</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'/</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>/</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-primitive-op</span> <span class=s>"Unknown primitive: ~s"</span> <span class=nv>op</span><span class=p>)]))</span>
</code></pre></div></div><p>Our language now handles calls to primitive operators, such as <code class="language-plaintext highlighter-rouge">(+ 2 4)</code> or <code class="language-plaintext highlighter-rouge">(+ x y)</code>. We are getting somewhere!<p>Next extend MiniScheme C to support three new primitive procedures that each take one argument: add1, sub1, and negate. The first two should be obvious; the negate procedure negates its argument: <code class="language-plaintext highlighter-rouge">(negate 6)</code> is <code class="language-plaintext highlighter-rouge">-6</code>, and <code class="language-plaintext highlighter-rouge">(negate (negate 6))</code> is <code class="language-plaintext highlighter-rouge">6</code>.<p>What kind of Scheme doesn’t have list processing functions? Extend MiniScheme C to implement <code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">cons</code>, <code class="language-plaintext highlighter-rouge">car</code>, <code class="language-plaintext highlighter-rouge">cdr</code>, and <code class="language-plaintext highlighter-rouge">null?</code>. The initial environment should also include a new variable, <code class="language-plaintext highlighter-rouge">'null</code> bound to the empty list.<p>Add tests to <code class="language-plaintext highlighter-rouge">interp-tests</code> to test evaluating some of your primitive procedures. Make sure you specify your tests in terms of <code class="language-plaintext highlighter-rouge">app-exp</code>, <code class="language-plaintext highlighter-rouge">var-exp</code>, and <code class="language-plaintext highlighter-rouge">lit-exp</code>.<p>Our methodology should now be pretty clear. At each step we have a new line in the grammar to handle a new kind of Scheme expression. We update the parser, which requires making a new tree data type to handle the new parsed expression. We then update the <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure to evaluate the new tree node. For the remaining steps we will be more brief.<p>Make sure you commit your code at this point.</section><section id=minischeme-d><h2 id=part-7-minischeme-d-conditionals>Part 7: MiniScheme D, Conditionals</h2><p>Let’s update our language to include conditional evaluation. We will adopt the convention that 0 and <code class="language-plaintext highlighter-rouge">False</code> represent false, and everything else represents true. Note that <code class="language-plaintext highlighter-rouge">#t</code> and <code class="language-plaintext highlighter-rouge">#f</code> are not values in MiniScheme. You should assign the value <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code> to the symbols <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code>. True expressions, such as <code class="language-plaintext highlighter-rouge">(eqv? 2 (+ 1 1))</code> should evaluate to <code class="language-plaintext highlighter-rouge">True</code>, not to <code class="language-plaintext highlighter-rouge">#t</code>.<p>Write MiniScheme D, which implements if-expressions. You will need to add <code class="language-plaintext highlighter-rouge">False</code> and <code class="language-plaintext highlighter-rouge">True</code> to the initial environment as described above. The meaning of <code class="language-plaintext highlighter-rouge">(if foo bar baz)</code> is just what you’d expect: If <code class="language-plaintext highlighter-rouge">foo</code> evaluates to <code class="language-plaintext highlighter-rouge">False</code> or <code class="language-plaintext highlighter-rouge">0</code>, then the value of the if-then-else expression is obtained by evaluating <code class="language-plaintext highlighter-rouge">baz</code>; otherwise, the value is obtained by evaluating <code class="language-plaintext highlighter-rouge">bar</code>.<p>This is the grammar for MiniScheme version D.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (EXP EXP*)                  parse into app-exp
</code></pre></div></div><p>You need to make a new data type and update the parser in <code class="language-plaintext highlighter-rouge">parse.rkt</code>, and update the <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure in <code class="language-plaintext highlighter-rouge">interp.rkt</code>. For the parser, note that both if expressions and application expressions are lists. We know a list represents an if-expression if its first element is the symbol ‘if. Put the test for this in the inner <code class="language-plaintext highlighter-rouge">cond</code> after the test for an empty list. We will assume a list represents an application expression if we don’t recognize its first element as a special form. So far, <code class="language-plaintext highlighter-rouge">if</code> is our only special form. Later parts will have more special forms.<p>Finally, extend MiniScheme D to implement the primitives <code class="language-plaintext highlighter-rouge">eqv?</code>, <code class="language-plaintext highlighter-rouge">lt?</code>, <code class="language-plaintext highlighter-rouge">gt?</code>, <code class="language-plaintext highlighter-rouge">leq?</code> and <code class="language-plaintext highlighter-rouge">geq?</code> where <code class="language-plaintext highlighter-rouge">eqv?</code> behaves like Scheme’s <code class="language-plaintext highlighter-rouge">eqv?</code> and <code class="language-plaintext highlighter-rouge">lt?</code>, <code class="language-plaintext highlighter-rouge">gt?</code>, <code class="language-plaintext highlighter-rouge">leq?</code>, and <code class="language-plaintext highlighter-rouge">geq?</code> behave like the usual inequality opeartors <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, and <code class="language-plaintext highlighter-rouge">&gt;=</code>. Each of these should return <code class="language-plaintext highlighter-rouge">'True</code> or <code class="language-plaintext highlighter-rouge">'False</code> and not <code class="language-plaintext highlighter-rouge">#t</code> or <code class="language-plaintext highlighter-rouge">#f</code>. Modify the definition of your primitive <code class="language-plaintext highlighter-rouge">null?</code> to also return <code class="language-plaintext highlighter-rouge">'True</code> or <code class="language-plaintext highlighter-rouge">'False</code>.<p>Add parser and interpreter tests.<p>Make sure you commit your code at this point.</section><section id=minischeme-e><h2 id=part-8-minischeme-e-let-expressions>Part 8: MiniScheme E, Let expressions</h2><p>The grammar for MiniScheme E is<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
</code></pre></div></div><p>As you can see, we have added new clause for the <code class="language-plaintext highlighter-rouge">let</code> expression. To make <code class="language-plaintext highlighter-rouge">eval-exp</code> clearer, I suggest that you make a <code class="language-plaintext highlighter-rouge">let-exp</code> data type that contains three children:<ol><li>A list of the symbols that are bound in the binding list<li>A list of the parsed expressions (i.e., trees) that the symbols are bound to<li>The let body.</ol><p>Thus, although we have grammar symbols for LET-BINDING and LET-BINDINGS, we choose to build the tree slightly differently.<p>After the parser is extended to handle let expressions, we extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to handle the <code class="language-plaintext highlighter-rouge">let-exp</code> nodes created by the parser. This should be straightforward–we evaluate a <code class="language-plaintext highlighter-rouge">let-exp</code> node in an environment by extending the environment with the let symbols bound to the values of the let bindings (<code class="language-plaintext highlighter-rouge">map</code> a curried version of <code class="language-plaintext highlighter-rouge">eval-exp</code> onto the binding expressions), and then evaluate the let body within this extended environment.<p>When you are finished you should be able to evaluate expressions such as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>a</span> <span class=mi>1</span><span class=p>]</span>
      <span class=p>[</span><span class=nf>b</span> <span class=mi>5</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))</span>
</code></pre></div></div><p>and<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>a</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>)]</span>
      <span class=p>[</span><span class=nf>b</span> <span class=mi>24</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>c</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>b</span> <span class=nv>a</span><span class=p>)])</span>
    <span class=p>(</span><span class=nb>*</span> <span class=nv>c</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))))</span>
</code></pre></div></div><p>Add parser and interpreter tests.<p>Make sure you commit your code at this point.<p>** This is the end of homework 6. The remainder will be completed in homework 7.**</section></main>