<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Hw8</title><meta name=description content="Homework 8: MiniScheme F, G &amp; H"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2024-fall/homeworks/hw8.html> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-8-minischeme-f-g--h>Homework 8: MiniScheme F, G &amp; H</h1><p><strong>Due: Friday, November 15 at 23:59</strong><br><strong>First Commit: Monday, November 11 at 23:59</strong><p><em>I would encourage you to start and complete this assignment early! The content of MiniScheme is in scope for Exam 2, which is happening the same week (in fact the day before) this homework is due.</em><p>This assignment has 3 parts and concludes our MiniScheme implementation! Each part builds a new version of MiniScheme, adding functionality step by step. Each part requires testing. You’ll definitely want to add testing for each part as you’re working on it.<p>Your implementations will be in several files. The start of each file should be<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>#</span><span class=nv>lang</span> <span class=nv>racket</span>
<span class=c1>; Your name(s) here.</span>
</code></pre></div></div><h2 id=preliminaries>Preliminaries</h2><p>Click on the <a href=https://classroom.github.com/a/XQ1abjoQ>assignment link</a>. A reminder that <strong>new teams are not allowed</strong> for Homework 8 and that I have copied over the teams from Homeworks 5/6. Please reach out to me if that will be an issue.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Note that apart from a new <code class="language-plaintext highlighter-rouge">HONORCODE.md</code>, there are no starter files for Homework 8. This is because you will be directly building on your Homework 6 work!<p>Start by copying all of your <code class="language-plaintext highlighter-rouge">.rkt</code> files from Homework 6 into your repository and committing them. Upon submission, your repository should contain the following files:<ul><li><code class="language-plaintext highlighter-rouge">parse.rkt</code><li><code class="language-plaintext highlighter-rouge">parse-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">interp.rkt</code><li><code class="language-plaintext highlighter-rouge">interp-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">env.rkt</code><li><code class="language-plaintext highlighter-rouge">env-tests.rkt</code><li><code class="language-plaintext highlighter-rouge">minischeme.rkt</code><li><code class="language-plaintext highlighter-rouge">test.rkt</code><li><code class="language-plaintext highlighter-rouge">HONORCODE.md</code></ul><p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>Make sure you put your name (and your partner’s name if you’re working with one) as a comment at the top of each file.<h2 id=part-f-lambda-expressions-and-closures>Part F: Lambda expressions and closures</h2><p>No language would be complete without the ability to create new procedures. Our new version of MiniScheme will implement lambda expressions. A lambda expression should evaluate to a structure containing the formal parameters, the body, and <em>the environment that was current when the procedure was created</em> (i.e., when the lambda expression was evaluated). This structure is known as a closure. You should start by making a data type for closures that holds three parts: parameters, body, and environment.<p>We parse a lambda expression such as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</code></pre></div></div><p>into a <code class="language-plaintext highlighter-rouge">lambda-exp</code> tree node.<p>This is a new kind of tree node with two parts: the parameter list and the tree that results from parsing the body. The <code class="language-plaintext highlighter-rouge">parse</code> function doesn’t track the environment, so it can’t build a full closure. Parsing a lambda expression just gives a tree; it is when we evaluate that tree that we get a closure.<p>If <code class="language-plaintext highlighter-rouge">exp</code> is the tree we get from parsing such a lambda expression, <code class="language-plaintext highlighter-rouge">(eval-exp exp e)</code> builds a closure with <code class="language-plaintext highlighter-rouge">exp</code>’s parameter list and body combined with the environment <code class="language-plaintext highlighter-rouge">e</code>.<p>Here is the grammar for MiniScheme F:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (lambda (PARAMS) EXP)       parse into lambda-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
PARAMS → symbol*
</code></pre></div></div><p>We parse a lambda expression into a <code class="language-plaintext highlighter-rouge">lambda-exp</code> node that stores the parameter list and the parsed body.<h3 id=evaluating>Evaluating</h3><p>In <code class="language-plaintext highlighter-rouge">eval-exp</code>, we evaluate a <code class="language-plaintext highlighter-rouge">lambda-exp</code> node as a <code class="language-plaintext highlighter-rouge">closure</code> that has the <code class="language-plaintext highlighter-rouge">lambda-exp</code>’s parameter list and parsed body and also the current environment.<p>When we handled <code class="language-plaintext highlighter-rouge">app-exp</code> in <code class="language-plaintext highlighter-rouge">eval-exp</code> for MiniScheme C, we defined <code class="language-plaintext highlighter-rouge">apply-proc</code> as below:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-proc</span> <span class=nv>proc</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>prim-proc?</span> <span class=nv>proc</span><span class=p>)</span>
         <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=p>(</span><span class=nf>prim-proc-op</span> <span class=nv>proc</span><span class=p>)</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-proc</span> <span class=s>"bad procedure: ~s"</span> <span class=nv>proc</span><span class=p>)]))</span>
</code></pre></div></div><p>Now, extend the <code class="language-plaintext highlighter-rouge">cond</code> with a case for <code class="language-plaintext highlighter-rouge">proc</code> being a <code class="language-plaintext highlighter-rouge">closure</code>. To evaluate the application of a closure to some argument values we start with the environment from the closure, extend that environment with bindings of the parameters to <code class="language-plaintext highlighter-rouge">args</code>, and call <code class="language-plaintext highlighter-rouge">eval-exp</code> on the closure’s body with this extended environment. We have already written procedures to handle each of these steps; it is just a matter of calling them!<p>When you finish your implementation, you should be able to evaluate the following expressions in <code class="language-plaintext highlighter-rouge">minischeme.rkt</code>:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>((</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=nv>x</span><span class=p>)</span> <span class=mi>1</span><span class=p>)</span> 
<span class=mi>1</span> 
<span class=nv>MS&gt;</span> <span class=p>((</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span> <span class=mi>2</span> <span class=mi>4</span><span class=p>)</span> 
<span class=mi>8</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>sqr</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=nv>x</span><span class=p>))])</span> <span class=p>(</span><span class=nf>sqr</span> <span class=mi>64</span><span class=p>))</span> 
<span class=mi>4096</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>sqr</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=nv>x</span><span class=p>))])</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>cube</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>sqr</span> <span class=nv>x</span><span class=p>)))])</span> <span class=p>(</span><span class=nf>cube</span> <span class=mi>3</span><span class=p>)))</span> 
<span class=mi>27</span>
</code></pre></div></div><p>As always, make sure to test your implementation! Specifically, add both parser and interpreter tests. Committing your code is also recommended at this stage.<h2 id=part-g-mutation--sequencing>Part G: Mutation &amp; Sequencing</h2><h3 id=overview>Overview</h3><p>Our next feature will be variable assignment with <code class="language-plaintext highlighter-rouge">set!</code>. Unfortunately, our implementation of environments does not provide a way to change the value bound to a variable. We will modify our old implementation so that variable names are bound to a mutable data type called a <code class="language-plaintext highlighter-rouge">box</code>, which is provided by Racket.<p>Take a moment to familiarize yourself with <code class="language-plaintext highlighter-rouge">box</code>es in Racket:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define</span> <span class=nv>abox</span> <span class=p>(</span><span class=nb>box</span> <span class=mi>17</span><span class=p>))</span> 
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>box?</span> <span class=nv>abox</span><span class=p>)</span> 
<span class=no>#t</span> 
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>unbox</span> <span class=nv>abox</span><span class=p>)</span> 
<span class=mi>17</span>
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>set-box!</span> <span class=nv>abox</span> <span class=mi>32</span><span class=p>)</span> 
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>unbox</span> <span class=nv>abox</span><span class=p>)</span> 
<span class=mi>32</span>
</code></pre></div></div><p>When variables are created (i.e., when we extend an environment) we will bind them to <code class="language-plaintext highlighter-rouge">box</code>es. When they are referenced we will <code class="language-plaintext highlighter-rouge">unbox</code> their bindings.<h3 id=updating-our-existing-implementation>Updating our existing implementation</h3><p>We need to thread the mutability idea throughout our implementation so that it works for all variables (whether or not we ultimately reassign them!).<p>First, when <code class="language-plaintext highlighter-rouge">eval-exp</code> currently evaluates a <code class="language-plaintext highlighter-rouge">var-exp</code>, it gets the symbol from the expression and looks it up in the environment. When our variables all refer to boxes, <code class="language-plaintext highlighter-rouge">eval-exp</code> needs to do an extra step: It gets the symbol from the expression, looks it up in the environment, and <code class="language-plaintext highlighter-rouge">unbox</code>es the result.<p>Secondly, whenever the environment is extended, the new bindings will be boxes that contain values. This occurs in two places. One is when we evaluate a let-expression in <code class="language-plaintext highlighter-rouge">eval-exp</code>, the other is when we apply a closure in <code class="language-plaintext highlighter-rouge">apply-proc</code>. For the latter our code used to be a recursive call to <code class="language-plaintext highlighter-rouge">eval-exp</code> on the body from the closure, using the environment <code class="language-plaintext highlighter-rouge">(env params vals e)</code>. After we introduce boxes we will still do this with a recursive call to <code class="language-plaintext highlighter-rouge">eval-exp</code> on the body, only now we need to box the argument values as we extend the environment. We handle let-expressions in the same way.<p>There are two ways to implement these changes: you can either change the calls to <code class="language-plaintext highlighter-rouge">env</code> to map <code class="language-plaintext highlighter-rouge">box</code> onto the values, or change the code for <code class="language-plaintext highlighter-rouge">env</code> itself to always box values when it puts them in a new environment. Your choice!<p>At this point your interpreter should be running exactly as it did for MiniScheme F: let-expressions, lambda expressions and applications should all work correctly. <strong>Make sure this is the case before you proceed!</strong><h3 id=adding-set-and-begin>Adding <code class="language-plaintext highlighter-rouge">set!</code> and <code class="language-plaintext highlighter-rouge">begin</code></h3><p>MiniScheme G will implement variable assignment in the form of <code class="language-plaintext highlighter-rouge">set!</code> expressions. Note that we will not be implementing <code class="language-plaintext highlighter-rouge">set!</code> as a primitive function, but as a special form. When evaluating <code class="language-plaintext highlighter-rouge">(set! x 5)</code> we don’t want to evaluate variable <code class="language-plaintext highlighter-rouge">x</code> to its previous value, as a call would, but rather to store value 5 in its box.<p>The grammar for MiniScheme G is as follows:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (lambda (PARAMS) EXP)       parse into lambda-exp
    | (set! symbol EXP)           parse into set-exp
    | (begin EXP*)                parse into begin-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
PARAMS → symbol*
</code></pre></div></div><p>Let’s start with <code class="language-plaintext highlighter-rouge">set!</code>.<p>We need to extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to handle <code class="language-plaintext highlighter-rouge">set-exp</code> tree nodes. This is just a matter of putting all of the pieces together: we lookup the symbol from the expression (the variable being assigned to) in the current environment; this should give us a <code class="language-plaintext highlighter-rouge">box</code>. We call <code class="language-plaintext highlighter-rouge">set-box!</code> on this <code class="language-plaintext highlighter-rouge">box</code> with the value we get from recursively calling <code class="language-plaintext highlighter-rouge">eval-exp</code> on the expression part of the <code class="language-plaintext highlighter-rouge">set-exp</code>.<p>Here is what we can do when this is implemented:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>+</span> <span class=nv>-</span><span class=p>)</span> 
<span class=o>#</span><span class=nv>&lt;void&gt;</span>
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>2</span> <span class=mi>2</span><span class=p>)</span> 
<span class=mi>0</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>+</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>negate</span> <span class=nv>y</span><span class=p>))))</span> 
<span class=o>#</span><span class=nv>&lt;void&gt;</span>
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>2</span> <span class=mi>2</span><span class=p>)</span> 
<span class=mi>4</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>2</span> <span class=mi>5</span><span class=p>)</span> 
<span class=mi>7</span> 
</code></pre></div></div><p>Now that we have introduced side effects, it seems a natural next step to implement sequencing of expressions which we will do via <code class="language-plaintext highlighter-rouge">begin</code>. The grammar for MiniScheme G contains the following rule.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → (begin EXP*)
</code></pre></div></div><p>Evaluating <code class="language-plaintext highlighter-rouge">(begin e1 e2 ... en)</code> results in the evaluation of <code class="language-plaintext highlighter-rouge">e1</code>, <code class="language-plaintext highlighter-rouge">e2</code>, …, <code class="language-plaintext highlighter-rouge">en</code> in that order. The returned result is the last expression, <code class="language-plaintext highlighter-rouge">en</code>.<p>A <code class="language-plaintext highlighter-rouge">begin-exp</code> holds a list of parsed expressions. You will need to think about how to add <code class="language-plaintext highlighter-rouge">begin-exp</code> to your <code class="language-plaintext highlighter-rouge">eval-exp</code> procedures. You need to iterate through the list of expressions in such a way that<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>2</span><span class=p>])</span>
    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nf>gt?</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>)</span>
        <span class=p>(</span><span class=k>begin</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>x</span> <span class=mi>24</span><span class=p>)</span>
               <span class=nv>x</span><span class=p>)</span>
        <span class=p>(</span><span class=k>begin</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>y</span> <span class=mi>25</span><span class=p>)</span>
               <span class=nv>y</span><span class=p>)))</span>
</code></pre></div></div><p>returns 25; the whole point of <code class="language-plaintext highlighter-rouge">begin</code> is that the subexpressions might have side effects that alter the environment.<p>Again, a reminder to add parse and interpreter tests as you go. Make sure to commit your code when you are done with Part G as well.<h2 id=part-h-recursion>Part H: Recursion</h2><p>It may seem like we are done, but let’s see what happens if we try to define a recursive procedure (for instance, factorial!) in MiniScheme G using normal <code class="language-plaintext highlighter-rouge">let</code>:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>fac</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span>
                 <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>n</span> <span class=mi>0</span><span class=p>)</span>
                     <span class=mi>1</span>
                     <span class=p>(</span><span class=nb>*</span> <span class=nv>n</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>n</span> <span class=mi>1</span><span class=p>)))))])</span>
      <span class=p>(</span><span class=nf>fac</span> <span class=mi>4</span><span class=p>))</span> 
</code></pre></div></div><p>This gives an error message saying there is no binding for <code class="language-plaintext highlighter-rouge">fac</code>. The problem is in the recursive call to <code class="language-plaintext highlighter-rouge">fac</code> in <code class="language-plaintext highlighter-rouge">(* n (fac (- n 1)))</code>. When we evaluated the lambda expression to create the closure, we did so in an environment in which <code class="language-plaintext highlighter-rouge">fac</code> was not bound. Because procedures use static environments when they are executed, the recursive call failed. The same thing happens in Scheme/Racket: this is exactly why we have <code class="language-plaintext highlighter-rouge">letrec</code>!<p>Recall what happens when a procedure is created. A closure is created that contains the environment at the time the <code class="language-plaintext highlighter-rouge">lambda</code> was evaluated, along with the body of the function and the formal parameters. MiniScheme F has no problems with this.<p>When a procedure is called the free variables in the body are looked up in the environment that was present at the time the lambda was evaluated. This is where MiniScheme ran into problems with the factorial example: the variable <code class="language-plaintext highlighter-rouge">fac</code> in the line<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nb>*</span> <span class=nv>n</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>n</span> <span class=mi>1</span><span class=p>))))))</span>
</code></pre></div></div><p>was not bound to anything at the time the procedure was created, and so we got an error.<p>There is a surprisingly simple way to get around this problem. Try running the following code in <code class="language-plaintext highlighter-rouge">minischeme.rkt</code> based on your MiniScheme G implementation:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>fac</span> <span class=mi>0</span><span class=p>])</span>
      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span>
                 <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>n</span> <span class=mi>0</span><span class=p>)</span>
                     <span class=mi>1</span>
                     <span class=p>(</span><span class=nb>*</span> <span class=nv>n</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>n</span> <span class=mi>1</span><span class=p>)))))])</span>
        <span class=p>(</span><span class=k>begin</span>
          <span class=p>(</span><span class=k>set!</span> <span class=nv>fac</span> <span class=nv>f</span><span class=p>)</span>
          <span class=p>(</span><span class=nf>fac</span> <span class=mi>4</span><span class=p>))))</span>
</code></pre></div></div><p>This works correctly and you can actually follow this pattern for <em>all</em> recursive functions!<p>Therefore, we can consider recursive procedures to be “syntactic sugar” (syntactic simplifications for ease of use) and, to implement them, we will rewrite letrec-expressions as let-expressions inside let-expressions with <code class="language-plaintext highlighter-rouge">set!</code>s to tie everything together.<p>Here is the grammar for our final language, MiniScheme H:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (letrec (LET-BINDINGS) EXP) translate to equivalent let-exp
    | (lambda (PARAMS) EXP)       parse into lambda-exp
    | (set! symbol EXP)           parse into set-exp
    | (begin EXP*)                parse into begin-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
PARAMS → symbol*
</code></pre></div></div><p>The way we are handling <code class="language-plaintext highlighter-rouge">letrecs</code> is what is known as a syntactic transformation. When the parser sees a letrec expression it can either produce an equivalent let expression and parse that, or it can directly create the appropriate <code class="language-plaintext highlighter-rouge">let-exp tree</code>. Either works!<h3 id=implementation-details>Implementation Details</h3><p>To implement MiniScheme H you should only have to modify the parser (remind yourself why this is before you start). You may want to use a helper function <code class="language-plaintext highlighter-rouge">parse-letrec</code> to do the work so you don’t clutter your parser. You may want to make helper functions for each of the special forms, although you certainly do not have to.<p>In the factorial example above, we first bound <code class="language-plaintext highlighter-rouge">fac</code> to 0. Then, in an inner let-expression, we defined a new, placeholder variable <code class="language-plaintext highlighter-rouge">f</code> to the standard, recursive implementation of factorial. Finally, we used <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">set!</code> to set the value of <code class="language-plaintext highlighter-rouge">fac</code> to our placeholder variable <code class="language-plaintext highlighter-rouge">f</code>.<p>When creating the placeholder variables, we don’t want to shadow existing bindings, so we need a way to create some fresh symbols to use as the placeholders. The Racket procedure <code class="language-plaintext highlighter-rouge">gensym</code> always returns fresh, unused symbols that we can use for this purpose.<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=nf>gensym</span><span class=p>)</span>
<span class=nv>g62</span>
</code></pre></div></div><p>When you have adapted your parser, the following examples should work in your miniScheme implementation:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nf>fac</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>x</span> <span class=mi>0</span><span class=p>)</span> <span class=mi>1</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>sub1</span> <span class=nv>x</span><span class=p>)))))])</span> <span class=p>(</span><span class=nf>fac</span> <span class=mi>4</span><span class=p>))</span>
        <span class=mi>24</span>
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nf>fac</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>x</span> <span class=mi>0</span><span class=p>)</span> <span class=mi>1</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>sub1</span> <span class=nv>x</span><span class=p>)))))])</span> <span class=p>(</span><span class=nf>fac</span> <span class=mi>10</span><span class=p>))</span>
        <span class=mi>3628800</span>
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nb>even?</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=mi>0</span> <span class=nv>n</span><span class=p>)</span> <span class=nv>True</span> <span class=p>(</span><span class=nb>odd?</span> <span class=p>(</span><span class=nb>sub1</span> <span class=nv>n</span><span class=p>))))]</span>  
             <span class=p>[</span><span class=nb>odd?</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=mi>0</span> <span class=nv>n</span><span class=p>)</span> <span class=nv>False</span> <span class=p>(</span><span class=nb>even?</span> <span class=p>(</span><span class=nb>sub1</span> <span class=nv>n</span><span class=p>))))]</span> <span class=p>)</span>
   <span class=p>(</span><span class=nb>even?</span> <span class=mi>5</span><span class=p>))</span>
<span class=nv>False</span>
</code></pre></div></div><p>Make sure you have written additional tests for the parser that address <code class="language-plaintext highlighter-rouge">letrec</code>.<p><strong>Congratulations! You have reached the end of Homework 8 and should have a working MiniScheme that supports recursion. This is quite a feat!</strong><h2 id=optional-code-refactoring>Optional: Code Refactoring</h2><p>Once you’ve finished your implementations of both <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>, you might want to consider doing a refactoring pass. <strong>Make sure to commit your working code before you embark on this task or make copies of your implementations to save!</strong><p>Refactoring is the idea of taking an existing code base and reworking it to be easier to read and debug. Depending on the code base there are many ways to refactor, but here you might consider adding in additional abstraction layers or introducing calls to helper functions.<p>Some elements that might lend themselves to refactoring are below, although there are likely other places in your implementation as well:<ul><li>How you handle <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code> in <code class="language-plaintext highlighter-rouge">apply-primitive-op</code> - if you have a lot of repetitive <code class="language-plaintext highlighter-rouge">if</code> statements, think about how you could replace them with a helper procedure!<li>The <code class="language-plaintext highlighter-rouge">cond</code> cases in <code class="language-plaintext highlighter-rouge">parse</code>, especially the <code class="language-plaintext highlighter-rouge">(list? input)</code> subcases.<li>When/how to throw errors: can you build a more generic “error helper” procedure that you reference at different locations?</ul><p>I recommend taking a bit of time on this step, as both a victory lap for completing the project and as a way to reinforce what each element is doing and how you can write more streamlined, elegant code.<h2 id=finishing-up>Finishing up</h2><p>Make sure you (and your partner, if you have one!) have signed the Honor Code and then add/commit/push. Also make sure your name(s) is in all of the files you submit. Your friendly graders thank you!</main>