<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Hw4</title><meta name=description content="Homework 4: Folds &amp; Trees"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2024-fall/homeworks/hw4.html> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-4-folds--trees>Homework 4: Folds &amp; Trees</h1><p><strong>Due: Friday, October 11 at 23:59</strong><br><strong>First Commit: Monday, October 7 at 23:59</strong><p>The goal for this assignment is to practice using folds and working with data structures. There are many ways to implement the functions below. Using <code class="language-plaintext highlighter-rouge">foldl</code>, <code class="language-plaintext highlighter-rouge">foldr</code>, <code class="language-plaintext highlighter-rouge">map</code>, and <code class="language-plaintext highlighter-rouge">apply</code> can make your solutions more concise. This is also the designated assignment to practice working with <code class="language-plaintext highlighter-rouge">fold</code>s!<p>Again, I reserve the right to deduct points on the implementation here if there are no higher-order functions used.<p>Your implementations of the following functions should all be placed in a single Racket file named <code class="language-plaintext highlighter-rouge">hw4.rkt</code>. The corresponding tests for each function should be in a second Racket file named <code class="language-plaintext highlighter-rouge">tests.rkt</code>.<p>You may use the solution to any exercise as a helper function in subsequent exercises and you may also write stand-alone helper functions.<p>The start of each file should be<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>#</span><span class=nv>lang</span> <span class=nv>racket</span>
<span class=c1>; Your name(s) here.</span>
</code></pre></div></div><h2 id=preliminaries>Preliminaries</h2><p>Click on the <a href=https://classroom.github.com/a/8lc7F_Oh>assignment link</a>. The <strong>same partnership and team making procedures apply as previous assignments!</strong><p>If you need a reminder of the procedures, if you’re working with a partner, one partner should create a new team. The second partner should click the link and choose the appropriate team. <strong>It’s extremely helpful for the graders if you include your name and your partner’s name in the team name.</strong> Unfortunately, you cannot use the same team name for multiple assignments. You can append the homework number to your team name if you wish. (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository on your computer by following the instruction and begin working. But before you do, read the entire assignment and be sure to check out the expected coding style in <a href=../fundamentals.html>Racket Fundamentals</a>.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Your repository should contain the following files<ul><li><code class="language-plaintext highlighter-rouge">hw4.rkt</code><li><code class="language-plaintext highlighter-rouge">tests.rkt</code><li><code class="language-plaintext highlighter-rouge">tree.rkt</code><li><code class="language-plaintext highlighter-rouge">HONORCODE.md</code></ul><p>It may also a <a href=https://git-scm.com/docs/gitignore><code class="language-plaintext highlighter-rouge">.gitignore</code></a> file which tells Git to ignore files matching patterns in your working directory.<p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>Make sure you put your name (and your partner’s name, if you’re working with one) as a comment at the top of each file.<h2 id=part-1-folds>Part 1. Folds</h2><p>For each function, write the function and a test suite and add the test suite to the <code class="language-plaintext highlighter-rouge">all-tests</code> test suite. You might want to write the tests first. For Part 1, make sure you write <strong>at least two tests</strong> for each function. Make sure your tests are exercising different circumstances!<p>To receive full credit on problems 1 through 3, use either <code class="language-plaintext highlighter-rouge">foldl</code> or <code class="language-plaintext highlighter-rouge">foldr</code>.<ol><li>Use a fold to write <code class="language-plaintext highlighter-rouge">(replace a b lst)</code> which replaces every instance of <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">b</code>. <ul><li><code class="language-plaintext highlighter-rouge">(replace 3 5 '(1 2 3 5 4 3 2 1))</code> returns <code class="language-plaintext highlighter-rouge">'(1 2 5 5 4 5 2 1)</code><li><code class="language-plaintext highlighter-rouge">(replace 3 5 '(2 4 6 8))</code> returns <code class="language-plaintext highlighter-rouge">'(2 4 6 8)</code></ul></ol><p>A list consisting of elements, each of which is itself a list, representing the data for one individual is called an <em>association list</em> in Racket. See the example below:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code>   <span class=p>(</span><span class=k>define</span> <span class=nv>bags</span>
     <span class=o>'</span><span class=p>((</span><span class=nf>duffle</span> <span class=mi>8</span><span class=p>)</span>
       <span class=p>(</span><span class=nf>garment-bag</span> <span class=mi>2</span><span class=p>)</span>
       <span class=p>(</span><span class=nf>briefcase</span> <span class=mi>5</span><span class=p>)</span>
       <span class=p>(</span><span class=nf>valise</span> <span class=mi>7</span><span class=p>)</span>
       <span class=p>(</span><span class=nf>steamer-trunk</span> <span class=mi>65</span><span class=p>)))</span>
</code></pre></div></div><p>For each function, write the function and a test suite and add the test suite to the <code class="language-plaintext highlighter-rouge">all-tests</code> test suite. You might want to write the tests first. You will need to define your own test association list in <code class="language-plaintext highlighter-rouge">tests.rkt</code> (<strong>not</strong> in <code class="language-plaintext highlighter-rouge">hw4.rkt</code>) to be able to reference it in your tests. This should be outside of a <code class="language-plaintext highlighter-rouge">test-suite</code> definition.<p>Racket has a standard library function <a href=https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._assoc%29%29><code class="language-plaintext highlighter-rouge">assoc</code></a> which is designed to work with association lists. For this assignment, <strong>do not use it</strong> in your implementations.<ol><li>Using a fold, write a procedure <code class="language-plaintext highlighter-rouge">(weigh bags)</code> which takes a baggage list and returns the total weight. <ul><li>Given the list shown, <code class="language-plaintext highlighter-rouge">(weigh bags)</code> returns 87</ul><li>Using a fold, write a procedure <code class="language-plaintext highlighter-rouge">(heaviest bags)</code> which returns the name of the bag with the largest weight where <code class="language-plaintext highlighter-rouge">bags</code> is an association list as described in (3). You may assume no bag has negative weight. <ul><li>Given the list shown in (3), <code class="language-plaintext highlighter-rouge">(heaviest bags)</code> returns <code class="language-plaintext highlighter-rouge">'steamer-trunk</code></ul></ol><p>If you haven’t already done so recently, now would be a <strong>great time</strong> to commit all of your code and push it to GitHub. Recall that you need to first add the files, commit them, and then push. If you’re using Github Desktop, go through the similar steps.<h2 id=part-2-trees>Part 2. Trees</h2><p>In this part, you will write a number of procedures that involve trees. Recall that a tree is a data structure that is either empty or contains some data and has a list of children, each of which is a tree. I have provided a definition of a tree data structure in the file <code class="language-plaintext highlighter-rouge">tree.rkt</code> – you must use this structure to obtain full credit on this assignment. Again, a note that the trees as part of this assignment are not necessarily binary trees.<p>In order to use the definitions in <code class="language-plaintext highlighter-rouge">tree.rkt</code>, you need to add the line<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>require</span> <span class=s>"tree.rkt"</span><span class=p>)</span>
</code></pre></div></div><p>below the <code class="language-plaintext highlighter-rouge">#lang racket</code> line at the top of <code class="language-plaintext highlighter-rouge">hw4.rkt</code> (remember our discussion of modules in Lecture 11!).<p>This particular implementation represents an empty tree as <code class="language-plaintext highlighter-rouge">null</code>. For clarity, <code class="language-plaintext highlighter-rouge">empty-tree</code> is defined as <code class="language-plaintext highlighter-rouge">null</code> and can be used to denote an empty tree.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>empty-tree</span> <span class=nv>null</span><span class=p>)</span>
</code></pre></div></div><p>A new tree can be constructed from a value and a list of children.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>tree</span> <span class=nv>value</span> <span class=p>(</span><span class=nb>list</span> <span class=nv>child-1</span> <span class=nv>child-2</span> <span class=o>...</span> <span class=nv>child-n</span><span class=p>))</span>
</code></pre></div></div><p>For convenience, there’s another constructor.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>make-tree</span> <span class=nv>value</span> <span class=nv>child-1</span> <span class=nv>child-2</span> <span class=o>...</span> <span class=nv>child-n</span><span class=p>)</span>
</code></pre></div></div><p>There are two recognizers that you’ll find extremely useful.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>empty-tree?</span> <span class=nv>t</span><span class=p>)</span> <span class=c1>; Returns #t if t is an empty tree</span>
<span class=p>(</span><span class=nf>tree?</span> <span class=nv>t</span><span class=p>)</span>       <span class=c1>; Returns #t if t is a nonempty tree</span>
</code></pre></div></div><p>Three are two accessor procedures which, when given a tree, return the value and the list of children, respectively.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>tree-value</span> <span class=nv>t</span><span class=p>)</span>    <span class=c1>; Returns t's value</span>
<span class=p>(</span><span class=nf>tree-children</span> <span class=nv>t</span><span class=p>)</span> <span class=c1>; Returns t's list of children</span>
</code></pre></div></div><p>There is a utility procedure which returns <code class="language-plaintext highlighter-rouge">#t</code> when the given tree is a leaf (has no children).<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>leaf?</span> <span class=nv>t</span><span class=p>)</span> <span class=c1>; Returns #t if t has no children</span>
</code></pre></div></div><p>Finally, there are eight example trees defined:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>T1</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>50</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T2</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>22</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T3</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>10</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T4</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>5</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T5</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>17</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T6</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>73</span> <span class=nv>T1</span> <span class=nv>T2</span> <span class=nv>T3</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T7</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>100</span> <span class=nv>T4</span> <span class=nv>T5</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>T8</span> <span class=p>(</span><span class=nf>make-tree</span> <span class=mi>16</span> <span class=nv>T6</span> <span class=nv>T7</span><span class=p>))</span>
</code></pre></div></div><p>All of this code is in <code class="language-plaintext highlighter-rouge">tree.rkt</code>. Take a look at that file to understand how the implementation works.<p>For Part 2, <em>you are expected to use <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">apply</code>, and <code class="language-plaintext highlighter-rouge">fold</code> to make your solutions concise.</em> All of your procedures should be written using the tree operations defined above. <strong>Do not directly manipulate the list representation, you will not get credit for these implementations</strong>. As usual, if the solution to an earlier problem is useful in a later one, you may use it!<p>As with Part 1, write tests for each of these functions in addition to implementing them. Full credit for tests for Part 2 will be obtained if:<ul><li>You write <strong>at least two</strong> meaningful tests for each procedure<li>Assume that all trees are numerical trees (i.e. trees which contain numbers as values). This is true of all the provided trees as well.<li><em>At least one test</em> for <em>each procedure</em> should reference a <strong>test tree of your own development</strong> that is defined in <code class="language-plaintext highlighter-rouge">tests.rkt</code>. This needs to be at least one, if not multiple, totally new trees with different structure than the examples provided. A reminder our tree implementation works for non-binary trees!</ul><ol><li>Write <code class="language-plaintext highlighter-rouge">(child-sum t)</code> which returns the sum of the values in the (immediate) children of <code class="language-plaintext highlighter-rouge">t</code>. <ul><li><code class="language-plaintext highlighter-rouge">(child-sum T8)</code> returns <code class="language-plaintext highlighter-rouge">173</code><li><code class="language-plaintext highlighter-rouge">(child-sum T6)</code> returns <code class="language-plaintext highlighter-rouge">82</code><li><code class="language-plaintext highlighter-rouge">(child-sum empty-tree)</code> returns <code class="language-plaintext highlighter-rouge">0</code></ul><li>Write <code class="language-plaintext highlighter-rouge">(all-sum t)</code> which returns the sum of all of the values in <code class="language-plaintext highlighter-rouge">t</code>. <ul><li><code class="language-plaintext highlighter-rouge">(all-sum T8)</code> returns <code class="language-plaintext highlighter-rouge">293</code><li><code class="language-plaintext highlighter-rouge">(all-sum T6)</code> returns <code class="language-plaintext highlighter-rouge">155</code><li><code class="language-plaintext highlighter-rouge">(all-sum empty-tree)</code> returns <code class="language-plaintext highlighter-rouge">0</code></ul><li><p>Write <code class="language-plaintext highlighter-rouge">(visit-tree f t)</code> where <code class="language-plaintext highlighter-rouge">f</code> is a function of one numerical variable. This returns a new tree with the same structure only every value <code class="language-plaintext highlighter-rouge">v</code> in the tree has been replaced with <code class="language-plaintext highlighter-rouge">(f v)</code>. For example, <code class="language-plaintext highlighter-rouge">(visit-tree add1 t)</code> increments every value in <code class="language-plaintext highlighter-rouge">t</code> by 1.<li>Write <code class="language-plaintext highlighter-rouge">(size-of t)</code> which returns the number of nodes in the subtree rooted at <code class="language-plaintext highlighter-rouge">t</code>. <ul><li><code class="language-plaintext highlighter-rouge">(size-of T8)</code> returns <code class="language-plaintext highlighter-rouge">8</code><li><code class="language-plaintext highlighter-rouge">(size-of T6)</code> returns <code class="language-plaintext highlighter-rouge">4</code><li><code class="language-plaintext highlighter-rouge">(size-of empty-tree)</code> returns <code class="language-plaintext highlighter-rouge">0</code></ul><li>Write <code class="language-plaintext highlighter-rouge">(height t)</code> which returns the height of the tree, the maximum number of edges from the root to the leaf. The empty tree has height <code class="language-plaintext highlighter-rouge">-1</code>, a leaf has height <code class="language-plaintext highlighter-rouge">0</code>, and so on. <ul><li><code class="language-plaintext highlighter-rouge">(height empty-tree)</code> returns <code class="language-plaintext highlighter-rouge">-1</code><li><code class="language-plaintext highlighter-rouge">(height T1)</code> returns <code class="language-plaintext highlighter-rouge">0</code><li><code class="language-plaintext highlighter-rouge">(height T8)</code> returns <code class="language-plaintext highlighter-rouge">2</code></ul><li><strong>Pick one</strong> of the following tree traversals to implement, either a <a href=https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)>pre-order traversal</a> or a <a href=https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(LRN)>post-order traversal</a>. You will only receive full credit if your procedure name matches the traversal it returns. Some potential tests you may want to consider: <ul><li><code class="language-plaintext highlighter-rouge">(pre-order T8)</code> returns <code class="language-plaintext highlighter-rouge">'(16 73 50 22 10 100 5 17)</code><li><code class="language-plaintext highlighter-rouge">(post-order T8)</code> returns <code class="language-plaintext highlighter-rouge">'(50 22 10 73 5 17 100 16)</code></ul></ol><h2 id=common-questions>Common Questions</h2><ul><li><p><em>When there are multiple bags with the same weight (i.e. <code class="language-plaintext highlighter-rouge">'((pen 2) (pencil 2)))</code>, which should heaviest return?</em> The first instance in the association list.<li><p><em>Do we have to handle non-tree arguments to tree methods in Part 2?</em> No, assume the original input is a tree. You do need to handle empty trees and single element trees though.<li><p><em>Can we use <code class="language-plaintext highlighter-rouge">flatten</code>?</em> <code class="language-plaintext highlighter-rouge">flatten</code> as you have previously written it is an operation on lists, not trees. You can write a <code class="language-plaintext highlighter-rouge">flatten-tree</code> helper, if you’d like.</ul><h2 id=finishing-up>Finishing up</h2><p>Make sure you wrote tests of all of these, the test suite for each function is included in the <code class="language-plaintext highlighter-rouge">all-tests</code> test suite, and your tests pass.<p>Once you have finished (or better yet, frequently as you’re working!), you need to push your code to GitHub. Make sure to double check that you’ve included your name and the name of your partner (if you’re working with a partner) in all files, check that you’ve completed the honor code, and then add/commit/push.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ git add hw4.rkt tests.rkt tree.rkt HONORCODE.md
$ git commit
$ git push
</code></pre></div></div></main>