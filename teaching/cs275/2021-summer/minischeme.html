<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>MiniScheme interpreter</title><meta name=description content="MiniScheme interpreter"> <link rel=canonical href=https://checkoway.net/teaching/cs275/2021-summer/minischeme.html> <link rel=stylesheet href=/css/main.css><style>ol>li{margin:1em}</style><main><h1 id=minischeme-interpreter>MiniScheme interpreter</h1><p>This page describes the MiniScheme interpreter you will implement over several weeks, starting with <a href=homeworks/hw5.html>homework 5</a>. Each part builds on the previous parts so make sure you keep up with the work or you’ll become very far behind.<p>Additional parts will be added as new assignments are released.<section><h2 id=part-1-environments>Part 1. Environments</h2><p>We need to create an environment to hold the data for the expressions we will interpret. The scoping rules for Scheme determine the structure of this environment. Consider the following three examples. First<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</code></pre></div></div><p>This has an environment with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> created in a let-block. These bindings are used in the body of the <code class="language-plaintext highlighter-rouge">let</code>.<p>Next, consider the following. This has a let-block that creates a lamba-expression, which is called in the body of the let:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=mi>4</span><span class=p>))])</span>
  <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>When this is evaluated we want to bind <code class="language-plaintext highlighter-rouge">x</code> to the value of the argument, <code class="language-plaintext highlighter-rouge">5</code>, and then evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> using that binding.<p>Finally, we combine these. At the outer level in the following expression we have a let-block with bindings for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. The body is another, nested, <code class="language-plaintext highlighter-rouge">let</code>, which binds a <code class="language-plaintext highlighter-rouge">lambda</code> expression with a parameter <code class="language-plaintext highlighter-rouge">x</code>. The body of the interior let is a call to the function.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>When we evaluate this we first make an environment with bindings of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> respectively, then we use this to evaluate the inner let-expression. In that expression we make a binding of <code class="language-plaintext highlighter-rouge">f</code> to the value of the lambda-expression (a closure, of course), and then we call <code class="language-plaintext highlighter-rouge">f</code> with argument <code class="language-plaintext highlighter-rouge">5</code>. This requires us to evaluate the body of <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>. The body of <code class="language-plaintext highlighter-rouge">f</code> does not have a binding for <code class="language-plaintext highlighter-rouge">y</code>, so we look it up in the outer environment and see that its value is <code class="language-plaintext highlighter-rouge">3</code>. Finally, we evaluates <code class="language-plaintext highlighter-rouge">(+ x y)</code> with <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">y</code> bound to <code class="language-plaintext highlighter-rouge">3</code>, yielding <code class="language-plaintext highlighter-rouge">8</code> for the value of the full expression.<p>Environments are extended in two ways. Let-expressions have bindings that extend the current environment; the body of the <code class="language-plaintext highlighter-rouge">let</code> is evaluated in the extended environment. Lambda-expressions do not extend the environment; they evaluate to closures that store the current environment from the location where the <code class="language-plaintext highlighter-rouge">(lambda (...) ...)</code> is evaluated.<p>When the closure that results from a <code class="language-plaintext highlighter-rouge">lambda-expression</code> is called, the closure’s environment is extended with the parameters from the lambda-expression being bound to the values of the arguments.<p>We will define the environment as an association list, where symbols are associated with values. There are two ways we might do this. In the first example above, where <code class="language-plaintext highlighter-rouge">x</code> is bound to <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">3</code>, we might use the list <code class="language-plaintext highlighter-rouge">'((x 2) (y 3))</code>, or we might use <code class="language-plaintext highlighter-rouge">'((x y) (2 3))</code>. The former structure is closer to the way the bindings appear in let-expressions; the latter is closer to the components of a call. The former structure might appear simpler, but the latter is actually easier to code and we will go with that.<p>Scheme, and many other languages you have and likely will learn, employs lexical scoping. When we want to resolve the binding for a free variable, we look first in the current scope, then in the surrounding scope, then in the scope that surrounds that, until the variable is found or we reach the outermost scope. To implement this our environments will be structured as a list with four elements: the symbol <code class="language-plaintext highlighter-rouge">'env</code>, a list of symbols, a list of values, and the previous environment. The top-most environment does not have a previous-environment (by definition) so we’ll use <code class="language-plaintext highlighter-rouge">null</code> to represent the empty environment.<p>Thus, the environment for the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>z</span> <span class=mi>4</span><span class=p>]</span> <span class=p>[</span><span class=nf>x</span> <span class=mi>5</span><span class=p>])</span>
    <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>y</span> <span class=nv>z</span><span class=p>))))</span>
</code></pre></div></div><p>will be something like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>'</span><span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>z</span> <span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nf>4</span> <span class=mi>5</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>env</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nf>2</span> <span class=mi>3</span><span class=p>)</span>
           <span class=p>()))</span>
</code></pre></div></div><p>When we resolve the bindings for <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> to evaluate <code class="language-plaintext highlighter-rouge">(+ x (+ y z))</code> we find the binding <code class="language-plaintext highlighter-rouge">5</code> for <code class="language-plaintext highlighter-rouge">x</code> (there are two bindings for <code class="language-plaintext highlighter-rouge">x</code>, but the one we want is is the first one we come to), and of course we find <code class="language-plaintext highlighter-rouge">4</code> for <code class="language-plaintext highlighter-rouge">z</code> and <code class="language-plaintext highlighter-rouge">3</code> for <code class="language-plaintext highlighter-rouge">y</code>. This leads to the correct value, <code class="language-plaintext highlighter-rouge">12</code> for the expression.<p>Similarly, in the expression<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>3</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))])</span>
    <span class=p>(</span><span class=nf>f</span> <span class=mi>5</span><span class=p>)))</span>
</code></pre></div></div><p>we evaluate the call <code class="language-plaintext highlighter-rouge">(f 5)</code> by evaluating the body of <code class="language-plaintext highlighter-rouge">f</code> in an environment that first has <code class="language-plaintext highlighter-rouge">x</code> bound to <code class="language-plaintext highlighter-rouge">5</code>, and then has the environment surrounding the definition of <code class="language-plaintext highlighter-rouge">f</code>.<p>You will see in later parts how this environment is created. At present we need to create the tools that will allow this.</section><section><h2 id=part-2-the-environment-data-type>Part 2. The environment data type</h2><p>The two most important features of an environment are that we need to be able to look up symbols to get the values they are bound to, and we need to be able to extend an environment with new bindings to get a new environment. We’ll define an environment as either the empty environment, with no bindings, or an extended environment with a list of symbols, a corresponding list of the values those symbols are bound to, and a previous environment that is being extended. Here is the definition of the empty environment and a constructor for an extended environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; The empty environment is null.</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>empty-env</span> <span class=nv>null</span><span class=p>)</span>

<span class=c1>; Environment constructor.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env</span> <span class=nv>syms</span> <span class=nv>vals</span> <span class=nv>previous-env</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>syms</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"syms is not a list"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>vals</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"vals is not a list"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>not</span> <span class=p>(</span><span class=nf>env?</span> <span class=nv>previous-env</span><span class=p>))</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env</span> <span class=s>"previous-env is not an env"</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>list</span> <span class=ss>'env</span> <span class=nv>syms</span> <span class=nv>vals</span> <span class=nv>previous-env</span><span class=p>)]))</span>
</code></pre></div></div><p>Note that <code class="language-plaintext highlighter-rouge">env</code> is the procedure you will use every time you need to extend an environment when evaluating a let-expression or a function call. For example, when evaluating the expression <code class="language-plaintext highlighter-rouge">(let ([x 1] [y 2]) ...)</code> we might use the following.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>We can further extend this environment.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>This data type has easy recognizer functions.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; Environment recognizers.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=nb>null?</span> <span class=nv>e</span><span class=p>))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>list?</span> <span class=nv>e</span><span class=p>)</span>
       <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>null?</span> <span class=nv>e</span><span class=p>))</span>
       <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>e</span><span class=p>)</span> <span class=ss>'env</span><span class=p>)))</span>
</code></pre></div></div><p>The accessor functions for the different fields of an extended environment are also easy.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>; Environment accessors.</span>
<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-syms</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>empty</span><span class=p>]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>second</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-syms</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-vals</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>empty</span><span class=p>]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>third</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-vals</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>

<span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-previous</span> <span class=s>"e has no previous env"</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nf>extended-env?</span> <span class=nv>e</span><span class=p>)</span> <span class=p>(</span><span class=nf>fourth</span> <span class=nv>e</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'env-previous</span> <span class=s>"e is not an env"</span><span class=p>)]))</span>
</code></pre></div></div><p>All that remains is to build some helper functions to look up bindings in an environment.</section><section><h2 id=part-3-implementing-the-environment-lookup>Part 3. Implementing the environment lookup</h2><p>The file <code class="language-plaintext highlighter-rouge">env.rkt</code> contains the code given above for the environment data type. Add to this file function <code class="language-plaintext highlighter-rouge">(env-lookup environment symbol)</code>, which takes an environment and a symbol and returns the first binding for that symbol in the environment. For example, with environments <code class="language-plaintext highlighter-rouge">env-a</code> and <code class="language-plaintext highlighter-rouge">env-b</code> defined as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>env-a</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>1</span> <span class=mi>2</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>))</span>
<span class=p>(</span><span class=k>define</span> <span class=nv>env-b</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>z</span><span class=p>)</span> <span class=o>'</span><span class=p>(</span><span class=nf>5</span> <span class=mi>7</span><span class=p>)</span> <span class=nv>env-a</span><span class=p>))</span>
</code></pre></div></div><p>we should have the following behavior:<ul><li><code class="language-plaintext highlighter-rouge">(lookup env-a 'x)</code> should return 1<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'x)</code> should return 5<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'y)</code> should return 2<li><code class="language-plaintext highlighter-rouge">(lookup env-b 'foo)</code> should cause an error</ul><p>If <code class="language-plaintext highlighter-rouge">env-lookup</code> does not find a binding for the symbol you should invoke the error handler <code class="language-plaintext highlighter-rouge">(error sym string)</code>, as in<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nb>error</span> <span class=ss>'env-lookup</span> <span class=s>"No binding for ~s"</span> <span class=nv>sym</span><span class=p>)</span>
</code></pre></div></div><p>Make sure you <code class="language-plaintext highlighter-rouge">provide</code> <code class="language-plaintext highlighter-rouge">env-lookup</code> at the top of <code class="language-plaintext highlighter-rouge">env.rkt</code> so that modules you’ll write in future parts (and in the tests described below) can use that procedure.<p>The file <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> contains a <code class="language-plaintext highlighter-rouge">test-env</code> environment that maps <code class="language-plaintext highlighter-rouge">x</code> to 1 and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">2</code>. In addition it defines an <code class="language-plaintext highlighter-rouge">env-tests</code> test suite that tests the basic behavior of the environment data type. Extend this test suite with additional tests for <code class="language-plaintext highlighter-rouge">env-lookup</code>. You will probably want to define new extended environments for your tests.<p>In particular, be sure to test at least the following situations<ul><li>Looking up a symbol that’s not bound in an environment throws an error. You’ll want to use the <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-exn%29%29><code class="language-plaintext highlighter-rouge">test-exn</code> procedure</a>. Unlike <code class="language-plaintext highlighter-rouge">test-true</code>, <code class="language-plaintext highlighter-rouge">test-false</code>, and <code class="language-plaintext highlighter-rouge">test-eqv?</code>, <code class="language-plaintext highlighter-rouge">test-exn</code> expects a 0-argument procedure which, when run, throws an error. For example, <div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-exn</span> <span class=s>"Empty environment has no previous"</span>
          <span class=nv>exn:fail?</span>
          <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=nf>env-previous</span> <span class=nv>empty-env</span><span class=p>))</span>
</code></pre></div></div><p>is testing that <code class="language-plaintext highlighter-rouge">(env-previous empty-env)</code> throws an error. You’ll want something very similar.<li>Looking up a symbol in an empty environment throws an error.<li>Looking up a symbol that’s bound in an environment returns its value.<li>Looking up a symbol that’s not bound in an environment but is bound in the environment’s previous environment returns the correct value.<li>Looking up a symbol that’s bound in an environment and also in the environment’s previous environment returns the correct value (see examples above).</ul><p><strong>This is the end of homework 5. The other parts will be completed in homeworks 6 and 7.</strong></section><section id=minischeme-a><h2 id=part-4-minischeme-version-a>Part 4: MiniScheme version A</h2><p>We will start with a very basic version of our MiniScheme language, version A, and gradually add language features. As we do so, we will update our parser and interpreter to implement the new language features.<p>As a convention, the parser and interpreter for MiniScheme will reside in files <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>, respectively. After you complete each of the remaining parts, you should be sure to commit your code. That way, you can always retrieve an earlier version if you need to.<p>In addition to <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code>, you will use <code class="language-plaintext highlighter-rouge">env.rkt</code> from Part 3 so make sure your <code class="language-plaintext highlighter-rouge">env-lookup</code> procedure works!<p>Here’s what you’ll have in each file.<ul><li><code class="language-plaintext highlighter-rouge">parse.rkt</code>: Tree data types and the <code class="language-plaintext highlighter-rouge">parse</code> procedure which converts the input to a tree to interpret;<li><code class="language-plaintext highlighter-rouge">interp.rkt</code>: Initially just <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure which takes a parse tree and an environment and produces a value and <code class="language-plaintext highlighter-rouge">init-env</code> which will hold the initial environment; and<li><code class="language-plaintext highlighter-rouge">env.rkt</code>: Environment data type and <code class="language-plaintext highlighter-rouge">env-lookup</code> procedure</ul><p>As you go, think about where to put new definitions. Racket has trouble with circular requirements (such as <code class="language-plaintext highlighter-rouge">parse.rkt</code> requiring <code class="language-plaintext highlighter-rouge">interp.rkt</code> and <code class="language-plaintext highlighter-rouge">interp.rkt</code> requiring <code class="language-plaintext highlighter-rouge">parse.rkt</code>). You probably want your <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">env.rkt</code> files to not require any other module, and your <code class="language-plaintext highlighter-rouge">interp.rkt</code> file to require both <code class="language-plaintext highlighter-rouge">parse.rkt</code> and <code class="language-plaintext highlighter-rouge">env.rkt</code>.<p>In addition to those files, we’ll have some testing files.<ul><li><code class="language-plaintext highlighter-rouge">parse-tests.rkt</code>: This defines a test suite for the parser;<li><code class="language-plaintext highlighter-rouge">interp-tests.rkt</code>: This defines a test suite for the interpreter;<li><code class="language-plaintext highlighter-rouge">env-tests.rkt</code>: This defines tests for the environment; and<li><code class="language-plaintext highlighter-rouge">tests.rkt</code>: This combines the other three test suites into a single <code class="language-plaintext highlighter-rouge">all-tests</code> test suite and runs it.</ul><p>Version A of MiniScheme is given by the following grammar.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
</code></pre></div></div><p>Our parse procedure will take an input expression and return a parse tree for an <code class="language-plaintext highlighter-rouge">EXP</code>. The only expressions in MiniScheme A are numbers. Admittedly, this is not very exciting but it is a place to start. Our interpreter for MiniScheme A will be very basic as well.<p>In <code class="language-plaintext highlighter-rouge">parse.rkt</code> we need a data type to hold <code class="language-plaintext highlighter-rouge">EXP</code> nodes that represent numbers. An easy solution is to make a list out of an atom (such as ‘lit-exp) that identifies the data type and the numeric value being represented. There are other possible representations and it doesn’t matter which you choose as long as you have a constructor (which I’ll call <code class="language-plaintext highlighter-rouge">lit-exp</code>), recognizer <code class="language-plaintext highlighter-rouge">lit-exp?</code> and getter <code class="language-plaintext highlighter-rouge">lit-exp-num</code>. You can use any names you want; the only required names are <code class="language-plaintext highlighter-rouge">parse</code> (for the parser), <code class="language-plaintext highlighter-rouge">eval-exp</code> (for the interpreter) and <code class="language-plaintext highlighter-rouge">init-env</code> (for the initial environment).<p>The parse function simply creates a <code class="language-plaintext highlighter-rouge">lit-exp</code> when it sees a number (and throws an error otherwise). It looks like this<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse</span> <span class=nv>input</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>number?</span> <span class=nv>input</span><span class=p>)</span> <span class=p>(</span><span class=nf>lit-exp</span> <span class=nv>input</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>)]))</span>
</code></pre></div></div><p>Save this code and the code that implements the <code class="language-plaintext highlighter-rouge">lit-exp</code> data type, in <code class="language-plaintext highlighter-rouge">parse.rkt</code>. Make this file into a module by adding the appropriate provide lines to make the <code class="language-plaintext highlighter-rouge">parse</code> procedure and the procedures for <code class="language-plaintext highlighter-rouge">lit-exp</code> (or whatever you call it) available to other modules.<p>Before moving on to the interpreter, copy your code for <code class="language-plaintext highlighter-rouge">env.rkt</code> and <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> to your new repository. Remove the line <code class="language-plaintext highlighter-rouge">(run-tests env-tests)</code> from <code class="language-plaintext highlighter-rouge">env-tests.rkt</code> since the <code class="language-plaintext highlighter-rouge">env-tests</code> test suite will be run by <code class="language-plaintext highlighter-rouge">tests.rkt</code> from now on.<p>In <code class="language-plaintext highlighter-rouge">parse-tests.rkt</code>, add tests for <code class="language-plaintext highlighter-rouge">parse</code>. In particular, you should test that <code class="language-plaintext highlighter-rouge">(parse 5)</code> returns something that <code class="language-plaintext highlighter-rouge">lit-exp?</code> evaluates to true. (You may wish to use the <a href=https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._test-pred%29%29><code class="language-plaintext highlighter-rouge">test-pred</code></a> procedure.)<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-pred</span> <span class=s>"Literal"</span>
           <span class=nv>lit-exp?</span>
           <span class=p>(</span><span class=nf>parse</span> <span class=mi>5</span><span class=p>))</span>
</code></pre></div></div><p>Test that when you parse a number, you can extract the number from the resultant parse tree using <code class="language-plaintext highlighter-rouge">lit-exp-num</code>.<p>For the interpreter, you know that Scheme evaluates all integers as themselves. Our evaluation function will be very simple. It looks like this.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>eval-exp</span> <span class=nv>tree</span> <span class=nv>e</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>lit-exp?</span> <span class=nv>tree</span><span class=p>)</span> <span class=p>(</span><span class=nf>lit-exp-num</span> <span class=nv>tree</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'eval-exp</span> <span class=s>"Invalid tree: ~s"</span> <span class=nv>tree</span><span class=p>)]))</span>
</code></pre></div></div><p>Save this code as <code class="language-plaintext highlighter-rouge">interp.rkt</code>. Make sure you require <code class="language-plaintext highlighter-rouge">parse.rkt</code> and (for the next step) <code class="language-plaintext highlighter-rouge">env.rkt</code>. Similarly, make sure you <code class="language-plaintext highlighter-rouge">provide</code> <code class="language-plaintext highlighter-rouge">eval-exp</code> for use by other modules.<p>We can interpret expressions in the command interpreter of the <code class="language-plaintext highlighter-rouge">interp.rkt</code> file. Run this file in DrRacket to load the interpreter and parser into memory, then type into the command interpreter:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define</span> <span class=nv>T</span> <span class=p>(</span><span class=nf>parse</span> <span class=ss>'23</span><span class=p>))</span>
<span class=nv>&gt;</span> <span class=p>(</span><span class=nf>eval-exp</span> <span class=nv>T</span> <span class=nv>empty-env</span><span class=p>)</span>
</code></pre></div></div><p>This should print the value 23.<p>It quickly becomes tedious to always invoke your interpreter by specifically calling the interpreter <code class="language-plaintext highlighter-rouge">eval-exp</code> after calling the parser on the quoted expression. It would be nice if we could write a read-eval-print loop for MiniScheme. This is precisely what <code class="language-plaintext highlighter-rouge">minischeme.rkt</code> does.<p>Running this program in DrRacket will give you an input box that allows you to type expressions and get back their value as determined by your <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">interp</code> modules. . For example, if you enter the MiniScheme expression 23 this evaluates it and prints its value 23.<p>The read-eval-print procedure assumes that your parse procedure is named <code class="language-plaintext highlighter-rouge">parse</code>; that your evaluator is called <code class="language-plaintext highlighter-rouge">eval-exp</code> that takes as arguments a parse tree and an environment, in that order; and an initial environment named <code class="language-plaintext highlighter-rouge">init-env</code>.<p>Inside <code class="language-plaintext highlighter-rouge">interp.rkt</code>, <code class="language-plaintext highlighter-rouge">define</code> and <code class="language-plaintext highlighter-rouge">provide</code> an <code class="language-plaintext highlighter-rouge">init-env</code>. For the <code class="language-plaintext highlighter-rouge">init-env</code>, use your <code class="language-plaintext highlighter-rouge">env</code> constructor to create an environment mapping <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">23</code> and <code class="language-plaintext highlighter-rouge">y</code> to 42`. For MiniScheme A, these mappings are of no use, but they will be shortly.<p>The last thing we need to do for MiniScheme A is to write some tests. In <code class="language-plaintext highlighter-rouge">interp-tests.rkt</code>, write a test like<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nf>test-eqv?</span> <span class=s>"Number"</span>
             <span class=p>(</span><span class=nf>eval-exp</span> <span class=p>(</span><span class=nf>lit-exp</span> <span class=mi>5</span><span class=p>)</span> <span class=nv>empty-env</span><span class=p>)</span>
             <span class=mi>5</span><span class=p>)</span>
</code></pre></div></div><p>Note that we’re explicitly passing the parse tree <code class="language-plaintext highlighter-rouge">(lit-exp 5)</code> rather than calling <code class="language-plaintext highlighter-rouge">(parse 5)</code>. This lets you separately test parsing from evaluating. In subsequent parts, you’ll be modifying <code class="language-plaintext highlighter-rouge">parse</code>. You don’t want a bug in <code class="language-plaintext highlighter-rouge">parse</code> to show up as a bug in <code class="language-plaintext highlighter-rouge">eval-exp</code>. By not using <code class="language-plaintext highlighter-rouge">parse</code> in your interpreter tests, you can keep the two separate.<p>Congratulations, at this point you should have a working interpreter for MiniScheme A! Make sure you commit your work at this point.</section><section id=minischeme-b><h2 id=part-5-minischeme-version-b-variables-and-definitions>Part 5: MiniScheme version B, variables and definitions</h2><p>MiniScheme A is somewhat lacking in utility. Our specification for MiniScheme B will be only slightly more interesting.<p>We will start with the following grammar for MiniScheme B.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
</code></pre></div></div><p>The parser is a simple modification to <code class="language-plaintext highlighter-rouge">parse</code>. You need to add a line to <code class="language-plaintext highlighter-rouge">(parse input)</code> to handle the case where <code class="language-plaintext highlighter-rouge">(symbol? input)</code> is <code class="language-plaintext highlighter-rouge">#t</code>. Of course, you need a <code class="language-plaintext highlighter-rouge">var-exp</code> data type including a constructor (I call it <code class="language-plaintext highlighter-rouge">var-exp</code>), recognizer (<code class="language-plaintext highlighter-rouge">var-exp?</code>) and getter (<code class="language-plaintext highlighter-rouge">var-exp-symbol</code>).<p>To evaluate a variable expression, MiniScheme B needs to be able to look up references. We evaluate a <code class="language-plaintext highlighter-rouge">var-exp</code> tree node in a given environment by calling lookup in that environment on the <code class="language-plaintext highlighter-rouge">var-exp-symbol</code>. Since we asked you to include bindings for symbols <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in the initial environment in Part 4, you should be able to evaluate the MiniScheme expressions <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">y</code> to get their values. Any other symbol at this point should give you an error message.<p>Make sure you commit your work at this point.</section><section id=minischeme-c><h2 id=part-6-minischeme-version-c-calls-to-primitive-procedures>Part 6: MiniScheme version C, calls to primitive procedures</h2><p>This is a good point to add primitive arithmetic operators to our environment. Nothing needs to be done for parsing–operators like <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code> and so forth are symbols, so they will be parsed to <code class="language-plaintext highlighter-rouge">var-exp</code> nodes. Our environment needs to associate these symbols to values. There are many ways to do this; the way we will use will be easy to expand to procedures derived from lambda expressions. We will first make a data type <code class="language-plaintext highlighter-rouge">prim-proc</code> to represent primitive procedures. This is simple; the only data this type needs to carry is the symbol for the operator, so this looks just like the <code class="language-plaintext highlighter-rouge">var-exp</code> type. Make a constructor, a recognizer, and a getter for the data type.<p>Think about which file should contain this data type definition. Keep in mind that <em>nothing in the parser needed to change to support these primitive procedures</em>.<p>Next, we make a list of the primitive arithmetic operators. You can start with the following and later expand it.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>primitive-operators</span> <span class=o>'</span><span class=p>(</span><span class=nb>+</span> <span class=nv>-</span> <span class=nv>*</span> <span class=nv>/</span><span class=p>)</span>
</code></pre></div></div><p>We can define a primative operator environment and make our <code class="language-plaintext highlighter-rouge">init-env</code> extend that instead of the <code class="language-plaintext highlighter-rouge">empty-env</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=nv>prim-env</span>
  <span class=p>(</span><span class=nf>env</span> <span class=nv>primitave-operators</span>
       <span class=p>(</span><span class=nb>map</span> <span class=nv>prim-proc</span> <span class=nv>primitave-operators</span><span class=p>)</span>
       <span class=nv>empty-env</span><span class=p>))</span>

<span class=p>(</span><span class=k>define</span> <span class=nv>init-env</span>
  <span class=p>(</span><span class=nf>env</span> <span class=o>'</span><span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span>
       <span class=o>'</span><span class=p>(</span><span class=nf>23</span> <span class=mi>42</span><span class=p>)</span>
       <span class=nv>prim-env</span><span class=p>))</span>
</code></pre></div></div><p>This means that when we evaluate + by looking it up in the environment we will get the structure <code class="language-plaintext highlighter-rouge">'(prim-proc +)</code><p>We will now extend the grammar to include applications so we can use our primitive operators.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (EXP EXP*)                  parse into app-exp
</code></pre></div></div><p>This gives us a language that can do something. You need to implement an <code class="language-plaintext highlighter-rouge">app-exp</code> data type that can hold a procedure (which is itself a tree) and a list of argument expressions (again, these are trees). The constructor for that might be <code class="language-plaintext highlighter-rouge">(app-exp proc args)</code>. Update the parser to build an <code class="language-plaintext highlighter-rouge">app-exp</code> node when the expression being parsed is a list.<p>We now have a <code class="language-plaintext highlighter-rouge">parse</code> procedure that looks like this.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse</span> <span class=nv>input</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>number?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>symbol?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>list?</span> <span class=nv>input</span><span class=p>)</span>
         <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>input</span><span class=p>)</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>)]</span>
               <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nf>app-exp</span> <span class=p>(</span><span class=nf>parse</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>input</span><span class=p>))</span> <span class=o>...</span><span class=p>)])]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>)]))</span>
</code></pre></div></div><p>Remember to parse both the operator and the list of operands.<p>One thing to notice about this is that we have duplicated the <code class="language-plaintext highlighter-rouge">(error ...)</code> line. We can simplify our code slightly by extracting that out into a 0-argument <code class="language-plaintext highlighter-rouge">parse-error</code> procedure.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse</span> <span class=nv>input</span><span class=p>)</span>
  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>parse-error</span><span class=p>)</span>
    <span class=p>(</span><span class=nb>error</span> <span class=ss>'parse</span> <span class=s>"Invalid syntax ~s"</span> <span class=nv>input</span><span class=p>))</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>number?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>symbol?</span> <span class=nv>input</span><span class=p>)</span> <span class=o>...</span><span class=p>]</span>
        <span class=p>[(</span><span class=nb>list?</span> <span class=nv>input</span><span class=p>)</span>
         <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>empty?</span> <span class=nv>input</span><span class=p>)</span> <span class=p>(</span><span class=nf>parse-error</span><span class=p>)]</span>
               <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nf>app-exp</span> <span class=p>(</span><span class=nf>parse</span> <span class=p>(</span><span class=nf>first</span> <span class=nv>input</span><span class=p>))</span> <span class=o>...</span><span class=p>)])]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nf>parse-error</span><span class=p>)]))</span>
</code></pre></div></div><p>Add tests to <code class="language-plaintext highlighter-rouge">parse-tests</code> to test that applications are parsed correctly. Make sure you test parsing applications with different numbers of parameters <code class="language-plaintext highlighter-rouge">(foo)</code>, <code class="language-plaintext highlighter-rouge">(bar 1)</code>, <code class="language-plaintext highlighter-rouge">(baz x y)</code>, etc. Add a test that <code class="language-plaintext highlighter-rouge">'()</code> causes an error. Look at <a href=#part-3-implementing-the-environment-lookup>Part 3</a> for how to write a test for an error.<p>In the <code class="language-plaintext highlighter-rouge">interp</code> module we extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to evaluate an <code class="language-plaintext highlighter-rouge">app-exp</code> node by calling a new procedure <code class="language-plaintext highlighter-rouge">apply-proc</code> with the evaluated operator and the list of evaluated arguments. Here is <code class="language-plaintext highlighter-rouge">apply-proc</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-proc</span> <span class=nv>proc</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>prim-proc?</span> <span class=nv>proc</span><span class=p>)</span>
         <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=p>(</span><span class=nf>prim-proc-op</span> <span class=nv>proc</span><span class=p>)</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-proc</span> <span class=s>"bad procedure: ~s"</span> <span class=nv>proc</span><span class=p>)]))</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">apply-primitive-op</code> procedure takes a symbol corresponding to the primitive procedure and a list of argument values. Here is one possible <code class="language-plaintext highlighter-rouge">apply-primitive-op</code>.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=nv>op</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'+</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>+</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'-</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>-</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'*</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>*</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[(</span><span class=nb>eq?</span> <span class=nv>op</span> <span class=ss>'/</span><span class=p>)</span> <span class=p>(</span><span class=nb>apply</span> <span class=nv>/</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-primitive-op</span> <span class=s>"Unknown primitive: ~s"</span> <span class=nv>op</span><span class=p>)]))</span>
</code></pre></div></div><p>Our language now handles calls to primitive operators, such as <code class="language-plaintext highlighter-rouge">(+ 2 4)</code> or <code class="language-plaintext highlighter-rouge">(+ x y)</code>. We are getting somewhere!<p>Next extend MiniScheme C to support three new primitive procedures that each take one argument: <code class="language-plaintext highlighter-rouge">add1</code>, <code class="language-plaintext highlighter-rouge">sub1</code>, and <code class="language-plaintext highlighter-rouge">negate</code>. The first two should be obvious; the <code class="language-plaintext highlighter-rouge">negate</code> procedure negates its argument: <code class="language-plaintext highlighter-rouge">(negate 6)</code> is <code class="language-plaintext highlighter-rouge">-6</code>, and <code class="language-plaintext highlighter-rouge">(negate (negate 6))</code> is <code class="language-plaintext highlighter-rouge">6</code>.<p>What kind of Scheme doesn’t have list processing functions? Extend MiniScheme C to implement <code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">cons</code>, <code class="language-plaintext highlighter-rouge">car</code>, and <code class="language-plaintext highlighter-rouge">cdr</code>. The initial environment should also include a new variable, <code class="language-plaintext highlighter-rouge">'null</code> bound to the empty list.<p>Add tests to <code class="language-plaintext highlighter-rouge">interp-tests</code> to test evaluating some of your primitive procedures. Make sure you specify your tests in terms of <code class="language-plaintext highlighter-rouge">app-exp</code>, <code class="language-plaintext highlighter-rouge">var-exp</code>, and <code class="language-plaintext highlighter-rouge">lit-exp</code>.<p>Our methodology should now be pretty clear. At each step we have a new line in the grammar to handle a new kind of Scheme expression. We update the parser, which requires making a new tree data type to handle the new parsed expression. We then update the <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure to evaluate the new tree node. For the remaining steps we will be more brief.<p>Make sure you commit your code at this point.</section><section id=minischeme-d><h2 id=part-7-minischeme-d-conditionals>Part 7: MiniScheme D, Conditionals</h2><p>Let’s update our language to include conditional evaluation. We will adopt the convention that 0 and <code class="language-plaintext highlighter-rouge">False</code> represent false, and everything else represents true. Note that <code class="language-plaintext highlighter-rouge">#t</code> and <code class="language-plaintext highlighter-rouge">#f</code> are not values in MiniScheme. You should assign the value <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code> to the symbols <code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code>. True expressions, such as <code class="language-plaintext highlighter-rouge">(eqv? 2 (+ 1 1))</code> should evaluate to <code class="language-plaintext highlighter-rouge">True</code>, not to <code class="language-plaintext highlighter-rouge">#t</code>.<p>Write MiniScheme D, which implements if-expressions. You will need to add <code class="language-plaintext highlighter-rouge">False</code> and <code class="language-plaintext highlighter-rouge">True</code> to the initial environment as described above. The meaning of <code class="language-plaintext highlighter-rouge">(if foo bar baz)</code> is just what you’d expect: If <code class="language-plaintext highlighter-rouge">foo</code> evaluates to <code class="language-plaintext highlighter-rouge">False</code> or <code class="language-plaintext highlighter-rouge">0</code>, then the value of the if-then-else expression is obtained by evaluating <code class="language-plaintext highlighter-rouge">baz</code>; otherwise, the value is obtained by evaluating <code class="language-plaintext highlighter-rouge">bar</code>.<p>This is the grammar for MiniScheme version D.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (EXP EXP*)                  parse into app-exp
</code></pre></div></div><p>You need to make a new data type and update the parser in <code class="language-plaintext highlighter-rouge">parse.rkt</code>, and update the <code class="language-plaintext highlighter-rouge">eval-exp</code> procedure in <code class="language-plaintext highlighter-rouge">interp.rkt</code>. For the parser, note that both if expressions and application expressions are lists. We know a list represents an if-expression if its first element is the symbol ‘if. Put the test for this in the inner <code class="language-plaintext highlighter-rouge">cond</code> after the test for an empty list. We will assume a list represents an application expression if we don’t recognize its first element as a special form. So far, <code class="language-plaintext highlighter-rouge">if</code> is our only special form. Later parts will have more special forms.<p>Finally, extend MiniScheme D to implement the primitives <code class="language-plaintext highlighter-rouge">eqv?</code>, <code class="language-plaintext highlighter-rouge">lt?</code>, <code class="language-plaintext highlighter-rouge">gt?</code>, <code class="language-plaintext highlighter-rouge">leq?</code> and <code class="language-plaintext highlighter-rouge">geq?</code> where <code class="language-plaintext highlighter-rouge">eqv?</code> behaves like Scheme’s <code class="language-plaintext highlighter-rouge">eqv?</code> and <code class="language-plaintext highlighter-rouge">lt?</code>, <code class="language-plaintext highlighter-rouge">gt?</code>, <code class="language-plaintext highlighter-rouge">leq?</code>, and <code class="language-plaintext highlighter-rouge">geq?</code> behave like the usual ineqv?ity operators <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, and <code class="language-plaintext highlighter-rouge">&gt;=</code>. Each of these should return <code class="language-plaintext highlighter-rouge">'True</code> or <code class="language-plaintext highlighter-rouge">'False</code> and not <code class="language-plaintext highlighter-rouge">#t</code> or <code class="language-plaintext highlighter-rouge">#f</code>.<p>Add primitive procedures <code class="language-plaintext highlighter-rouge">null?</code>, <code class="language-plaintext highlighter-rouge">list?</code>, and <code class="language-plaintext highlighter-rouge">number?</code> which behave like their Scheme counterparts, but return <code class="language-plaintext highlighter-rouge">True</code> or <code class="language-plaintext highlighter-rouge">False</code> rather than <code class="language-plaintext highlighter-rouge">#t</code> or <code class="language-plaintext highlighter-rouge">#f</code>.<p>Add parser and interpreter tests.<p>Make sure you commit your code at this point.</section><section id=minischeme-e><h2 id=part-8-minischeme-e-let-expressions>Part 8: MiniScheme E, Let expressions</h2><p>The grammar for MiniScheme E is<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
</code></pre></div></div><p>As you can see, we have added new clause for the <code class="language-plaintext highlighter-rouge">let</code> expression. To make <code class="language-plaintext highlighter-rouge">eval-exp</code> clearer, I suggest that you make a <code class="language-plaintext highlighter-rouge">let-exp</code> data type that contains three children:<ol><li>A list of the symbols that are bound in the binding list<li>A list of the parsed expressions (i.e., trees) that the symbols are bound to<li>The let body.</ol><p>Thus, although we have grammar symbols for LET-BINDING and LET-BINDINGS, we choose to build the tree slightly differently.<p>After the parser is extended to handle let expressions, we extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to handle the <code class="language-plaintext highlighter-rouge">let-exp</code> nodes created by the parser. This should be straightforward–we evaluate a <code class="language-plaintext highlighter-rouge">let-exp</code> node in an environment by extending the environment with the let symbols bound to the values of the let bindings (<code class="language-plaintext highlighter-rouge">map</code> a curried version of <code class="language-plaintext highlighter-rouge">eval-exp</code> onto the binding expressions), and then evaluate the let body within this extended environment.<p>When you are finished you should be able to evaluate expressions such as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>a</span> <span class=mi>1</span><span class=p>]</span>
      <span class=p>[</span><span class=nf>b</span> <span class=mi>5</span><span class=p>])</span>
  <span class=p>(</span><span class=nb>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))</span>
</code></pre></div></div><p>and<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>a</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>)]</span>
      <span class=p>[</span><span class=nf>b</span> <span class=mi>24</span><span class=p>])</span>
  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>c</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>b</span> <span class=nv>a</span><span class=p>)])</span>
    <span class=p>(</span><span class=nb>*</span> <span class=nv>c</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))))</span>
</code></pre></div></div><p>Add parser and interpreter tests.<p>Make sure you commit your code at this point.<p><strong>This is the end of homework 6. The remainder will be completed in homework 7.</strong></section><section id=minischeme-f><h2 id=part-9-minischeme-f-lambda-expressions-and-closures>Part 9: MiniScheme F, Lambda expressions and closures</h2><p>No language would be complete without the ability to create new procedures. Our new version of MiniScheme will implement lambda expressions. A lambda expression should evaluate to a structure containing the formal parameters, the body, and the environment that was current when the procedure was created (i.e., when the lambda expression was evaluated. This structure is known as a closure. You should start by making a data type for closures that holds three parts: parameters, body, and environment.<p>We parse a lambda expression such as<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</code></pre></div></div><p>into a <code class="language-plaintext highlighter-rouge">lambda-exp</code> tree node.<p>This is a new kind of tree node with two parts: the parameter list and the tree that results from parsing the body. The <code class="language-plaintext highlighter-rouge">parse</code> function doesn’t track the environment, so it can’t build a full closure. Parsing a lambda expression just gives a tree; it is when we evaluate that tree that we get a closure. If <code class="language-plaintext highlighter-rouge">exp</code> is the tree we get from parsing such a lambda expression, <code class="language-plaintext highlighter-rouge">(eval-exp exp e)</code> builds a closure with <code class="language-plaintext highlighter-rouge">exp</code>’s parameter list and body combined with the environment <code class="language-plaintext highlighter-rouge">e</code>.<p>We are ready for MiniScheme F. The syntax is extended once more, this time to include lambda expressions. Here is the grammar for MiniSchemeF.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (lambda (PARAMS) EXP)       parse into lambda-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
PARAMS → symbol*
</code></pre></div></div><p>We parse a lambda expression into a <code class="language-plaintext highlighter-rouge">lambda-exp</code> node that stores the parameter list and the parsed body. In <code class="language-plaintext highlighter-rouge">eval-exp</code>, we evaluate a <code class="language-plaintext highlighter-rouge">lambda-exp</code> node as a <code class="language-plaintext highlighter-rouge">closure</code> that has the <code class="language-plaintext highlighter-rouge">lambda-exp</code>’s parameter list and parsed body and also the current environment.<p>In <a href=#minischeme-c>MiniScheme C</a>, we defined <code class="language-plaintext highlighter-rouge">apply-proc</code> like this.<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nf>apply-proc</span> <span class=nv>proc</span> <span class=nv>args</span><span class=p>)</span>
  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=nf>prim-proc?</span> <span class=nv>proc</span><span class=p>)</span>
         <span class=p>(</span><span class=nf>apply-primitive-op</span> <span class=p>(</span><span class=nf>prim-proc-op</span> <span class=nv>proc</span><span class=p>)</span> <span class=nv>args</span><span class=p>)]</span>
        <span class=p>[</span><span class=nf>else</span> <span class=p>(</span><span class=nb>error</span> <span class=ss>'apply-proc</span> <span class=s>"bad procedure: ~s"</span> <span class=nv>proc</span><span class=p>)]))</span>
</code></pre></div></div><p>We now extend this with a case for <code class="language-plaintext highlighter-rouge">proc</code> being a <code class="language-plaintext highlighter-rouge">closure</code>. To evaluate the application of a closure to some argument values we start with the environment from the closure, extend that environment with bindings of the parameters to <code class="language-plaintext highlighter-rouge">args</code>, and call <code class="language-plaintext highlighter-rouge">eval-exp</code> on the closure’s body with this extended environment. We have already written procedures to handle each of these steps; it is just a matter of calling them. After implementing this you should be able to do the following.<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>((</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=nv>x</span><span class=p>)</span> <span class=mi>1</span><span class=p>)</span> 
<span class=mi>1</span> 
<span class=nv>MS&gt;</span> <span class=p>((</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span> <span class=mi>2</span> <span class=mi>4</span><span class=p>)</span> 
<span class=mi>8</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>((</span><span class=nf>sqr</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=nv>x</span><span class=p>))))</span> <span class=p>(</span><span class=nf>sqr</span> <span class=mi>64</span><span class=p>))</span> 
<span class=mi>4096</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>((</span><span class=nf>sqr</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=nv>x</span><span class=p>))))</span> <span class=p>(</span><span class=k>let</span> <span class=p>((</span><span class=nf>cube</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>sqr</span> <span class=nv>x</span><span class=p>)))))</span> <span class=p>(</span><span class=nf>cube</span> <span class=mi>3</span><span class=p>)))</span> 
<span class=mi>27</span>
</code></pre></div></div><p>Add parser and interpreter tests.<p>Make sure you commit your code at this point.</section><section id=minischeme-g><h2 id=part-10-minischeme-g-variables-assignments-and-sequencing>Part 10: MiniScheme G, Variables, assignments, and sequencing</h2><p>Our next feature will be variable assignment, with <code class="language-plaintext highlighter-rouge">set!</code>. Unfortunately, our implementation of environments does not provide a way to change the value bound to a variable. We will modify our old implementation so that variable names are bound to a mutable data type called a <code class="language-plaintext highlighter-rouge">box</code>, which is provided by DrRacket.<p>Take a moment to familiarize yourself with <code class="language-plaintext highlighter-rouge">box</code>es in Racket:<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define</span> <span class=nv>abox</span> <span class=p>(</span><span class=nb>box</span> <span class=mi>17</span><span class=p>))</span> 
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>box?</span> <span class=nv>abox</span><span class=p>)</span> 
<span class=no>#t</span> 
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>unbox</span> <span class=nv>abox</span><span class=p>)</span> 
<span class=mi>17</span>
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>set-box!</span> <span class=nv>abox</span> <span class=mi>32</span><span class=p>)</span> 
<span class=nv>&gt;</span> <span class=p>(</span><span class=nb>unbox</span> <span class=nv>abox</span><span class=p>)</span> 
<span class=mi>32</span>
</code></pre></div></div><p>When variables are created (i.e., when we extend an environment) we will bind them to <code class="language-plaintext highlighter-rouge">box</code>es. When they are referenced we will <code class="language-plaintext highlighter-rouge">unbox</code> their bindings. We will take these tasks sequentially.<p>First, when <code class="language-plaintext highlighter-rouge">eval-exp</code> currently evaluates a <code class="language-plaintext highlighter-rouge">var-exp</code>, it gets the symbol from the expression and looks it up in the environment. When our variables all refer to boxes, <code class="language-plaintext highlighter-rouge">eval-exp</code> needs to do an extra step: It gets the symbol from the expression, looks it up in the environment, and <code class="language-plaintext highlighter-rouge">unbox</code>es the result.<p>Secondly, whenever the environment is extended, the new bindings will be boxes that contain values. This occurs in two places. One is when we evaluate a let-expression in <code class="language-plaintext highlighter-rouge">eval-exp</code>, the other is when we apply a closure in <code class="language-plaintext highlighter-rouge">apply-proc</code>. For the latter our code used to be a recursive call to <code class="language-plaintext highlighter-rouge">eval-exp</code> on the body from the closure, using the environment <code class="language-plaintext highlighter-rouge">(env params vals e)</code>. After we introduce boxes we will still do this with a recursive call to <code class="language-plaintext highlighter-rouge">eval-exp</code> on the body only now we need to box the argument values as we extend the environment. We handle let-expressions in the same way.<p>There are two ways to implement this—you can either change the calls to <code class="language-plaintext highlighter-rouge">env</code> to <code class="language-plaintext highlighter-rouge">map</code> <code class="language-plaintext highlighter-rouge">box</code> onto the values, or change the code for <code class="language-plaintext highlighter-rouge">env</code> itself to always box values when it puts them in a new environment. Take your pick; one approach is as easy as the other.<p>At this point your interpreter should be running exactly as it did for MiniScheme F: let-expressions, lambda expressions and applications should all work correctly. Make sure this is the case before you proceed. We will now take advantage of our boxed bindings to implement <code class="language-plaintext highlighter-rouge">set!</code>.<p>MiniScheme G will implement variable assignment in the form of <code class="language-plaintext highlighter-rouge">set!</code> expressions. Note that we will not be implementing <code class="language-plaintext highlighter-rouge">set!</code> as a primitive function, but as a special form. When evaluating <code class="language-plaintext highlighter-rouge">(set! x 5)</code> we don’t want to evaluate variable <code class="language-plaintext highlighter-rouge">x</code> to its previous value, as a call would, but rather to store value 5 in its box.<p>The grammar for MiniScheme G is as follows.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (lambda (PARAMS) EXP)       parse into lambda-exp
    | (set! symbol EXP)           parse into set-exp
    | (begin EXP*)                parse into begin-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
PARAMS → symbol*
</code></pre></div></div><p>Let’s start with <code class="language-plaintext highlighter-rouge">set!</code>.<p>We need to extend <code class="language-plaintext highlighter-rouge">eval-exp</code> to handle <code class="language-plaintext highlighter-rouge">set-exp</code> tree nodes. This is just a matter of putting all of the pieces together: we lookup the symbol from the expression (the variable being assigned to) in the current environment; this should give us a <code class="language-plaintext highlighter-rouge">box</code>. We call <code class="language-plaintext highlighter-rouge">set-box!</code> on this <code class="language-plaintext highlighter-rouge">box</code> with the value we get from recursively calling <code class="language-plaintext highlighter-rouge">eval-exp</code> on the expression part of the <code class="language-plaintext highlighter-rouge">set-exp</code>.<p>Here is what we can do when this is implemented.<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>+</span> <span class=nv>-</span><span class=p>)</span> 
<span class=o>#</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>2</span> <span class=mi>2</span><span class=p>)</span> 
<span class=mi>0</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>+</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>negate</span> <span class=nv>y</span><span class=p>))))</span> 
<span class=o>#</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>2</span> <span class=mi>2</span><span class=p>)</span> 
<span class=mi>4</span> 
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=nb>+</span> <span class=mi>2</span> <span class=mi>5</span><span class=p>)</span> 
<span class=mi>7</span> 
<span class=nv>MS&gt;</span> <span class=nv>exit</span> 
<span class=nv>returning</span> <span class=nv>to</span> <span class=nv>Scheme</span> <span class=nv>proper</span>
</code></pre></div></div><p>Now that we have introduced side effects, it seems a natural next step to implement sequencing of expressions which we will do via <code class="language-plaintext highlighter-rouge">begin</code>. The grammar for MiniScheme G contains the following rule.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → (begin EXP*)
</code></pre></div></div><p>Evaluating <code class="language-plaintext highlighter-rouge">(begin e1 e2 ... en)</code> results in the evaluation of <code class="language-plaintext highlighter-rouge">e1</code>, <code class="language-plaintext highlighter-rouge">e2</code>, …, <code class="language-plaintext highlighter-rouge">en</code> in that order. The returned result is the last expression, <code class="language-plaintext highlighter-rouge">en</code>.<p>A <code class="language-plaintext highlighter-rouge">begin-exp</code> holds a list of parsed expression. You will need to think about how to add <code class="language-plaintext highlighter-rouge">begin-exp</code> to your <code class="language-plaintext highlighter-rouge">eval-exp</code> procedures. You need to iterate through the list of expressions in such a way that<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>x</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=nf>y</span> <span class=mi>2</span><span class=p>])</span>
  <span class=p>(</span><span class=k>begin</span> <span class=p>(</span><span class=k>set!</span> <span class=nv>x</span> <span class=mi>23</span><span class=p>)</span>
         <span class=p>(</span><span class=nb>+</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>)))</span> 
</code></pre></div></div><p>returns 25; the whole point of <code class="language-plaintext highlighter-rouge">begin</code> is that the subexpressions might have side effects that alter the environment. Perhaps this will encourage you to be more appreciative of functional programming.<p>Make sure to add parser and interpreter tests as you go.<p>As usual, it’s a good idea to commit your code at this point.</section><section id=minischeme-h><h2 id=part-11-minischeme-h-recursion>Part 11: MiniScheme H, Recursion</h2><p>It looks like we’re about done, but let’s take a closer look. What happens if we try to define a recursive procedure in MiniScheme G? Let’s try the ever-familiar factorial function.<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>fac</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span>
                 <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>n</span> <span class=mi>0</span><span class=p>)</span>
                     <span class=mi>1</span>
                     <span class=p>(</span><span class=nb>*</span> <span class=nv>n</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>n</span> <span class=mi>1</span><span class=p>)))))])</span>
      <span class=p>(</span><span class=nf>fac</span> <span class=mi>4</span><span class=p>))</span> 
</code></pre></div></div><p>This gives an error message saying there is no binding for <code class="language-plaintext highlighter-rouge">fac</code>. But we bound <code class="language-plaintext highlighter-rouge">fac</code> using <code class="language-plaintext highlighter-rouge">let</code>. Why is MiniScheme reporting that <code class="language-plaintext highlighter-rouge">fac</code> is unbound? The problem is in the recursive call to <code class="language-plaintext highlighter-rouge">fac</code> in <code class="language-plaintext highlighter-rouge">(* n (fac (- n 1)))</code>. When we evaluated the lambda expression to create the closure, we did so in an environment in which <code class="language-plaintext highlighter-rouge">fac</code> was not bound. Because procedures use static environments when they are executed, the recursive call failed. The same thing would happen in Scheme itself; this is why we have <code class="language-plaintext highlighter-rouge">letrec</code>.<p>Recall what happens when a procedure is created. A closure is created that contains the environment at the time the <code class="language-plaintext highlighter-rouge">lambda</code> was evaluated, along with the body of the function and the formal parameters. MiniScheme F has no problems with this.<p>When a procedure is called the free variables in the body are looked up in the environment that was present at the time the lambda was evaluated. This is where MiniScheme ran into problems with the factorial example: the variable <code class="language-plaintext highlighter-rouge">fac</code> in the line<div class="language-racket highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=nb>*</span> <span class=nv>n</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>n</span> <span class=mi>1</span><span class=p>))))))</span>
</code></pre></div></div><p>was not bound to anything at the time the procedure was created, and so we got an error.<p>There is a clever way to get around this problem. Try running the following code:<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>fac</span> <span class=mi>0</span><span class=p>])</span>
      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span>
                 <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>n</span> <span class=mi>0</span><span class=p>)</span>
                     <span class=mi>1</span>
                     <span class=p>(</span><span class=nb>*</span> <span class=nv>n</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nb>-</span> <span class=nv>n</span> <span class=mi>1</span><span class=p>)))))])</span>
        <span class=p>(</span><span class=k>begin</span>
          <span class=p>(</span><span class=k>set!</span> <span class=nv>fac</span> <span class=nv>f</span><span class=p>)</span>
          <span class=p>(</span><span class=nf>fac</span> <span class=mi>4</span><span class=p>))))</span>
</code></pre></div></div><p>This works correctly. You can use this pattern for all recursive functions.<p>So then, it appears that recursive procedures are really “syntactic sugar”; we will rewrite letrec-expressions as let-expressions inside let-expressions with <code class="language-plaintext highlighter-rouge">set!</code>s to tie everything together. Here is the grammar for our final language, MiniScheme H.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>EXP → number                      parse into lit-exp
    | symbol                      parse into var-exp
    | (if EXP EXP EXP)            parse into ite-exp
    | (let (LET-BINDINGS) EXP)    parse into let-exp
    | (lambda (PARAMS) EXP)       parse into lambda-exp
    | (set! symbol EXP)           parse into set-exp
    | (begin EXP*)                parse into begin-exp
    | (letrec (LET-BINDINGS) EXP) translate to equivalent let-exp
    | (EXP EXP*)                  parse into app-exp
LET-BINDINGS → LET-BINDING*
LET-BINDING → [symbol EXP]
PARAMS → symbol*
</code></pre></div></div><p>The way we are handling <code class="language-plaintext highlighter-rouge">letrecs</code> is what is known as a syntactic transformation. When the parser sees a letrec expression it can either produce an equivalent let expression and parse that, or it can directly create the appropriate <code class="language-plaintext highlighter-rouge">let-exp tree</code>. The latter is what I do, but either approach works.<p>To implement MiniScheme H you should only have to modify the parser. You may want to use a helper function <code class="language-plaintext highlighter-rouge">parse-letrec</code> to do the work so you don’t clutter your parser. You may want to make helper functions for each of the special forms, although you certainly do not have to.<p>In the factorial example above, we first bound <code class="language-plaintext highlighter-rouge">fac</code> to 0. Then, in an inner let-expression, we defined a new, placeholder variable <code class="language-plaintext highlighter-rouge">f</code> to the standard, recursive implementation of factorial. Finally, we used <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">set!</code> to set the value of <code class="language-plaintext highlighter-rouge">fac</code> to our placeholder variable <code class="language-plaintext highlighter-rouge">f</code>.<p>When creating the placeholder variables, we don’t want to shadow existing bindings so we need a way to create some fresh symbols to use as the placeholders. The procedure <code class="language-plaintext highlighter-rouge">gensym</code> always returns fresh, unused symbols that we can use for this purpose.<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>&gt;</span> <span class=p>(</span><span class=nf>gensym</span><span class=p>)</span>
<span class=nv>g62</span>
</code></pre></div></div><p>When you have this completed the following examples should work.<div class="language-scheme highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nf>fac</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>x</span> <span class=mi>0</span><span class=p>)</span> <span class=mi>1</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nf>sub1</span> <span class=nv>x</span><span class=p>)))))])</span> <span class=p>(</span><span class=nf>fac</span> <span class=mi>4</span><span class=p>))</span>
        <span class=mi>24</span>
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nf>fac</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=nv>x</span> <span class=mi>0</span><span class=p>)</span> <span class=mi>1</span> <span class=p>(</span><span class=nb>*</span> <span class=nv>x</span> <span class=p>(</span><span class=nf>fac</span> <span class=p>(</span><span class=nf>sub1</span> <span class=nv>x</span><span class=p>)))))])</span> <span class=p>(</span><span class=nf>fac</span> <span class=mi>10</span><span class=p>))</span>
        <span class=mi>3628800</span>
<span class=nv>MS&gt;</span> <span class=p>(</span><span class=k>letrec</span> <span class=p>([</span><span class=nb>even?</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=mi>0</span> <span class=nv>n</span><span class=p>)</span> <span class=nv>True</span> <span class=p>(</span><span class=nb>odd?</span> <span class=p>(</span><span class=nf>sub1</span> <span class=nv>n</span><span class=p>))))]</span>  
             <span class=p>[</span><span class=nb>odd?</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=nf>n</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eqv?</span> <span class=mi>0</span> <span class=nv>n</span><span class=p>)</span> <span class=nv>False</span> <span class=p>(</span><span class=nb>even?</span> <span class=p>(</span><span class=nf>sub1</span> <span class=nv>n</span><span class=p>))))]</span> <span class=p>)</span>
   <span class=p>(</span><span class=nb>even?</span> <span class=mi>5</span><span class=p>))</span>
<span class=nv>False</span>
</code></pre></div></div><p>Make sure you have written tests for the parser.<p><strong>Congratulations! You have reached the end of Homework 7 and should have a working MiniScheme that supports recursion. This is quite a feat!</strong><p>Make sure you’ve committed and pushed your code to GitHub.</section></main>