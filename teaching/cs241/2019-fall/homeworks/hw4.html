<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Homework 4: Maze Generation</title><meta name=description content="Homework 4: Maze Generation Due: 2019-11-17 at 23:59"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2019-fall/homeworks/hw4.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-4-maze-generation>Homework 4: Maze Generation</h1><p><strong>Due: 2019-11-17 at 23:59</strong><h2 id=preliminaries>Preliminaries</h2><p>First, find a partner. You’re allowed to work by yourself, but I highly recommend working with a partner. Click on the <a href=https://classroom.github.com/g/OEVt1BuM>assignment link</a>. One partner should create a new team. The second partner should click the link and choose the appropriate team. (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository on clyde and begin working. But before you do, read the entire assignment and be sure to check out the expected <a href=#coding-style>coding style</a>.<p>Be sure to ask any questions on <a href>Piazza</a>.<h3 id=coding-style>Coding style</h3><p><strong>The coding style requirement is identical to the <a href=hw2.html#coding-style>Coding style</a> section of Homework 2.</strong><p>You should run <code class=highlighter-rouge>clang-format</code> on each of the C source and header files you write. This will format all of your files consistently.<h3 id=code-warnings-and-errors>Code warnings and errors</h3><p>Your code must compile without error or warning when compiled with <code class=highlighter-rouge>-std=c11 -Wall</code>.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Your repository should not contain any programs, object files, or dependency files (the dependency files are the ones ending in <code class=highlighter-rouge>.Td</code> or <code class=highlighter-rouge>.d</code>.<p>The <code class=highlighter-rouge>README.md</code> should contain<ul><li>An image link showing the Travis CI build status (see part 0)<li>The names of both partners (or just your name if you worked alone…but please don’t work alone if you can manage it).<li>An estimate of the amount of time it took to complete each part.<li>Any known bugs or incomplete functions.<li>Any interesting design decisions you’d like to share.</ul><p>Each of your source files with a <code class=highlighter-rouge>main</code> function should contain a comment at the top of the file that contains usage information plus a description of what the program does.<h2 id=part-0-makefile-testing-and-travis-ci>Part 0. Makefile, testing, and Travis CI</h2><h3 id=makefile>Makefile</h3><p>Unlike previous assignments, this one comes with a full-featured <code class=highlighter-rouge>Makefile</code>. If you add additional source files, you should add them to the appropriate <code class=highlighter-rouge>_srcs</code> variable. Dependencies should be computed automatically.<p>The <code class=highlighter-rouge>all</code> target should depend on all of the programs you write.<p>The <code class=highlighter-rouge>clean</code> target should delete all of the programs you write and all of the object files.<h3 id=testing>Testing</h3><p>The assignment code also comes with a set of unit tests in the <code class=highlighter-rouge>tests</code> directory. You can run them by running <code class=highlighter-rouge>$ make check</code>.<p>There are several tests in the <code class=highlighter-rouge>tests</code> directory. These consist of the ones I found useful for writing my solutions. You may choose to add to them when testing your own code, although you aren’t required to in this assigment.<p>As you work through the parts below, run <code class=highlighter-rouge>$ make check</code> frequently to make sure that you haven’t broken any code you previously had working.<h3 id=travis-ci>Travis CI</h3><p>This homework also uses the <a href=https://travis-ci.com/>Travis CI</a> continuous integration service. Each time you push your code to GitHub, Travis will download the latest version, build your program and then run the tests.<p>You should be able to see the status of your latest commit by logging in to <a href=https://travis-ci.com>Travis CI</a> using your GitHub account. You can also see the latest status from Travis by clicking on the <code class=highlighter-rouge>1 branch</code> link near the top of the GitHub page for your repository which has URL <code class=highlighter-rouge>https://github.com/systems-programming/${repo_name}/branches</code>. You should see either a green check mark if all tests passed or a red X if one or more tests failed.<p>You should add a build status image to your <code class=highlighter-rouge>README.md</code> by following the <a href=https://docs.travis-ci.com/user/status-images/>instructions</a> to get the Markdown code to paste into <code class=highlighter-rouge>README.md</code>.<h3 id=overview>Overview</h3><p>In CS 151, you probably had to implement a maze solving function using stacks or queues. In this assignment, you’re going to generate rectangular mazes.<p>A <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=application/x-tex>m\times n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.58333em></span><span class="strut bottom" style=height:0.66666em;vertical-align:-0.08333em></span><span class=base><span class="mord mathit">m</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>×</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class="mord mathit">n</span></span></span></span> maze contains <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=application/x-tex>m</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em></span><span class=base><span class="mord mathit">m</span></span></span></span> rows of <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em></span><span class=base><span class="mord mathit">n</span></span></span></span> columns of rooms. Each room has 0–4 walls: up, down, left, and right. The rooms on the edges of the maze must contain walls along the edge. For example, the room at <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator=true>,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(0,0)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>0</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>0</span><span class=mclose>)</span></span></span></span> (the top-left corner of the maze) <em>must</em> have the top and left walls. Adjacent rooms must have consistent walls. For example, if the room at <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(1,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span> has walls to the right and down, then the room at <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(2,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>2</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span> must have an up wall and the room at <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=true>,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(1,4)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>4</span><span class=mclose>)</span></span></span></span> must have a left wall.<p>Inside <code class=highlighter-rouge>maze.h</code>, there is an <code class=highlighter-rouge>enum</code> that defines four values that can be ORed together to specify the possible walls. E.g., <code class=highlighter-rouge>WALL_UP | WALL_RIGHT</code>.<p>Since we’re going to be building the maze, one room at a time, there is an additional value <code class=highlighter-rouge>WALL_NOT_SET</code> that represents the fact that the walls have not been set for the room yet.<p>The first structure you’re going to work with is <code class=highlighter-rouge>RoomCoords</code> defined in <code class=highlighter-rouge>roomcoords.h</code>. To ease the construction of these, there’s a <code class=highlighter-rouge>ROOM(row, col)</code> macro. I found this macro incredibly helpful when writing my solution. There’s a special <code class=highlighter-rouge>RoomCoords</code> value <code class=highlighter-rouge>UNDEFINED_ROOM_COORDS</code> that is used in several places.<p>The other main structure is the <code class=highlighter-rouge>Maze</code> structure. <code class=highlighter-rouge>maze.h</code> declares this as an opaque structure. That is, it doesn’t actually define the structure. You will have to define the structure yourself in <code class=highlighter-rouge>maze.c</code>. The idea behind an opaque structure is that all of the code will work with a <code class=highlighter-rouge>Maze</code> using the functions defined in <code class=highlighter-rouge>maze.h</code> rather than interact with the <code class=highlighter-rouge>Maze</code> members directly. The only code that should interact with the <code class=highlighter-rouge>Maze</code> members is in <code class=highlighter-rouge>maze.c</code>.<p>As you’re implementing the code, you should not change the function signatures (the names, parameter numbers and types, and return types) for any function declared in a header file. Doing so will break the game code.<h2 id=part-1-basic-maze-manipulation-functions-10-points>Part 1. Basic maze manipulation functions (10 points)</h2><p>The first task is to define the <code class=highlighter-rouge>Maze</code> structure. Each maze will need to keep track of<ol><li>the number of rows,<li>the number of columns,<li>the starting room coordinates,<li>the ending room coordinates, and<li>the data representing the rooms themselves.</ol><p>Start by removing the dummy member from <code class=highlighter-rouge>Maze</code>, and add the appropriate members. You’ll need to decide how you want to represent the 2D array of rooms.<p>One possibility is keeping track of the walls for each room. Thus, if room <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator=true>,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=application/x-tex>(r,c)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class=mclose>)</span></span></span></span> has left and right walls, you’ll want to store <code class=highlighter-rouge>WALL_LEFT | WALL_RIGHT</code>. In this case, you’ll need to ensure that <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator=true>,</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(r,c-1)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>−</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>1</span><span class=mclose>)</span></span></span></span> has a right wall, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator=true>,</mo><mi>c</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(r,c+1)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>1</span><span class=mclose>)</span></span></span></span> has a left wall, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo separator=true>,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=application/x-tex>(r-1,c)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>−</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class=mclose>)</span></span></span></span> doesn’t have a down wall, and <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator=true>,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=application/x-tex>(r+1,c)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class=mclose>)</span></span></span></span> doesn’t have an up wall.<p>A second possibility is to only keep track of the left and up walls for each room. To determine if room <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator=true>,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=application/x-tex>(r,c)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class=mclose>)</span></span></span></span> has a right wall, you need to check if room <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator=true>,</mo><mi>c</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(r,c+1)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>1</span><span class=mclose>)</span></span></span></span> has a left wall (or it’s on the right edge of the maze) and to determine if it has a down wall, you need to check if room <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator=true>,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=application/x-tex>(r+1,c)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.02778em>r</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class="mord mathit">c</span><span class=mclose>)</span></span></span></span> has an up wall (or it’s on the bottom edge of the map). In this way, it’s not possible for the walls to become inconsistent but the logic becomes a little more tricky.<p>In either case, a single <code class=highlighter-rouge>unsigned char</code> is sufficient for each room. This includes keeping track of whether a particular room’s walls have been set.<p>You’re free to use another representation of your maze. (The nice thing about having an opaque <code class=highlighter-rouge>Maze</code> type from the perspective of the rest of the code is that your internal representation doesn’t matter.)<p>Look at the descriptions of the functions in <code class=highlighter-rouge>maze.h</code>, and implement these functions.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>Maze</span> <span class=o>*</span><span class=nf>maze_new</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>cols</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>maze_free</span><span class=p>(</span><span class=n>Maze</span> <span class=o>*</span><span class=n>maze</span><span class=p>);</span>
<span class=kt>size_t</span> <span class=nf>maze_get_rows</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>);</span>
<span class=kt>size_t</span> <span class=nf>maze_get_cols</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>);</span>
<span class=n>bool</span> <span class=nf>maze_in_bounds</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>coords</span><span class=p>);</span>
<span class=n>RoomCoords</span> <span class=nf>maze_get_start</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>maze_set_start</span><span class=p>(</span><span class=n>Maze</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>coords</span><span class=p>);</span>
<span class=n>RoomCoords</span> <span class=nf>maze_get_end</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>maze_set_end</span><span class=p>(</span><span class=n>Maze</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>coords</span><span class=p>);</span>
</code></pre></div></div><p>Make sure that when you create a new <code class=highlighter-rouge>Maze</code>, you set the members of the maze such that the various maze getter functions return the correct values.<p>I recommend making liberal use of <code class=highlighter-rouge>assert(3)</code> to check for programmer errors.<p>Run <code class=highlighter-rouge>$ make check</code> to make sure that the checks related to those functions pass (but you should expect most of the checks to fail).<h2 id=part-2-getting-and-setting-walls-30-points>Part 2. Getting and setting walls (30 points)</h2><p>This is probably the trickiest portion of this assignment.<p>Implement the functions to get and set the walls for a given room.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>int</span> <span class=nf>maze_get_walls</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>coords</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>maze_set_walls</span><span class=p>(</span><span class=n>Maze</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>coords</span><span class=p>,</span> <span class=kt>int</span> <span class=n>walls</span><span class=p>);</span>
</code></pre></div></div><p>When setting walls, make sure your maze is consistent as described in <a href=#overview>Part 0</a>. Furthermore, make sure that setting the walls for one room does not make an adjacent room whose walls haven’t been set lose that property. (I.e., if <code class=highlighter-rouge>maze_get_walls(maze, ROOM(r, c))</code> returns <code class=highlighter-rouge>WALL_NOT_SET</code>, then after setting an adjacent room’s wall’s, <code class=highlighter-rouge>maze_get_walls(maze, ROOM(r, c))</code> should still return <code class=highlighter-rouge>WALL_NOT_SET</code>.<p>Walls for a room may be set multiple times but a room’s walls can never become unset.<p>Check that all of the tests in <code class=highlighter-rouge>tests/test_maze.c</code> pass except for <code class=highlighter-rouge>test_first_unset()</code>.<p>Finally, implement<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>RoomCoords</span> <span class=nf>maze_get_first_unset</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>);</span>
</code></pre></div></div><p>by using the functions you’ve already implemented. (I.e., there is no real need for this function to be in this file, but it doesn’t obviously belong anywhere else.)<p>Now when you run <code class=highlighter-rouge>$ make check</code>, all of the tests in <code class=highlighter-rouge>test_maze</code> should pass.<h2 id=part-3-reading-and-writing-mazes-15-points>Part 3. Reading and writing mazes (15 points)</h2><p>In this part, you’ll implement the functions necessary to read a maze from a <code class=highlighter-rouge>FILE *</code> and write a maze to a <code class=highlighter-rouge>FILE *</code>.<p>The structure of the maze file is described in <code class=highlighter-rouge>mazeio.h</code>. There is an example in that file and there are more in the <code class=highlighter-rouge>mazes</code> directory.<p>Implement the following functions.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>Maze</span> <span class=o>*</span><span class=nf>maze_new_from_stream</span><span class=p>(</span><span class=kt>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
<span class=kt>int</span> <span class=nf>maze_write_to_stream</span><span class=p>(</span><span class=n>Maze</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=kt>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</code></pre></div></div><p>When running <code class=highlighter-rouge>$ make check</code>, <code class=highlighter-rouge>tests/test_mazeio</code> should pass all tests.<p>At this point, you should be able to run <code class=highlighter-rouge>mazegame</code>. You can pass it the path of a maze (e.g., one of the mazes in <code class=highlighter-rouge>mazes</code>) to play that maze. (It’s possible this code is buggy, it’s much harder to test than the rest of the assignment. If you happen to get it to crash, let me know!)<p>You can also have it solve a maze by giving it the <code class=highlighter-rouge>-s</code> option.<h2 id=part-4-random-walk-30-points>Part 4. Random walk (30 points)</h2><p>The procedure you’re going to use to generate a random maze sounds complicated, but it’s actually pretty straight forward using <a href=https://en.wikipedia.org/wiki/Random_walk>random walks</a>.<p>A random walk is a sequence of room coordinates such that each room is adjacent to the room before it and the room after it in the sequence. For example, each room in this sequence <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator=true>,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(2,2)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>2</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>2</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(2,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>2</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(1,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(2,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>2</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>3</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(3,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>3</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>3</mn><mo separator=true>,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(3,4)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>3</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>4</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator=true>,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(2,4)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>2</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>4</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(2,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>2</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=true>,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(1,3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>3</span><span class=mclose>)</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=true>,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(1,2)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>2</span><span class=mclose>)</span></span></span></span> is adjacent to the rooms before and after it in the sequence. Notice that several rooms are repeated in the sequence. That’s okay.<p>You’re going to create a random walk starting from a room whose walls have not been set. Each step of the random walk will move to the room above, below, left, or right of the current room, each with equal probability. Any step that would take the walk out side of the bounds of the maze’s grid is simply ignored and a new direction is chosen at random. The walk stops once it encounters a room in the maze whose walls have been set. Thus, if the above sequence of rooms were the outcome of a random walk, then room <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=true>,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding=application/x-tex>(1,2)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mopen>(</span><span class=mord>1</span><span class=mpunct>,</span><span class="mord rule" style=margin-right:0.16666666666666666em></span><span class=mord>2</span><span class=mclose>)</span></span></span></span> would have the walls set but none of the others would. See <code class=highlighter-rouge>randomwalk.h</code> for the specifics.<p>The next step is to erase the loops in the random walk. This gives you a <a href=https://en.wikipedia.org/wiki/Loop-erased_random_walk>loop-erased random walk</a>. The procedure for doing this is described in <code class=highlighter-rouge>randomwalk.h</code>.<p>Finally, you’re going to add the loop-erased random walk to the maze, constructing a new corridor in the maze where the start is a dead end and the end is where it connects with the rest of the maze. See <code class=highlighter-rouge>randomwalk.h</code> for details and <code class=highlighter-rouge>tests/test_walk.c</code>’s <code class=highlighter-rouge>test_add_path()</code> function for an illustration of adding four paths to a maze.<p>Implement the three random walk functions.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>RoomCoords</span> <span class=o>*</span><span class=nf>random_walk</span><span class=p>(</span><span class=n>Maze</span> <span class=k>const</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>start</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>walk_size</span><span class=p>);</span>
<span class=kt>size_t</span> <span class=nf>erase_loops</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>walk</span><span class=p>[</span><span class=n>size</span><span class=p>]);</span>
<span class=kt>void</span> <span class=nf>add_path_to_maze</span><span class=p>(</span><span class=n>Maze</span> <span class=o>*</span><span class=n>maze</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=k>const</span> <span class=n>walk</span><span class=p>[</span><span class=n>size</span><span class=p>]);</span>
</code></pre></div></div><p>At this point, all of the tests in <code class=highlighter-rouge>tests/test_walk</code> should pass.<h2 id=part-5-generating-a-maze-15-points>Part 5. Generating a maze (15 points)</h2><p>The final step of maze generation is to put everything together and actually generate some mazes. The complete algorithm is described in <code class=highlighter-rouge>generate.c</code>, so take a look and implement the function.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>Maze</span> <span class=o>*</span><span class=nf>generate_maze</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>cols</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>start</span><span class=p>,</span> <span class=n>RoomCoords</span> <span class=n>end</span><span class=p>);</span>
</code></pre></div></div><p>After this, <code class=highlighter-rouge>tests/test_generate</code> should pass.<p>At this point, <code class=highlighter-rouge>mazegen</code> should be usable to generate some mazes. Run <code class=highlighter-rouge>$ mazegen -h</code> to see how to use it.</main>