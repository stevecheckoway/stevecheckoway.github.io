<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Homework 3: Strings</title><meta name=description content="Homework 3: Strings Due: 2019-10-13 2019-10-18 at 23:59"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2019-fall/homeworks/hw3.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-3-strings>Homework 3: Strings</h1><p><strong>Due: <del>2019-10-13</del> 2019-10-18 at 23:59</strong><h2 id=preliminaries>Preliminaries</h2><p>First, find a partner. You’re allowed to work by yourself, but I highly recommend working with a partner. Click on the <a href=https://classroom.github.com/g/XvmO7xiC>assignment link</a>. One partner should create a new team. The second partner should click the link and choose the appropriate team. (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository on clyde and begin working. But before you do, read the entire assignment and be sure to check out the expected <a href=#coding-style>coding style</a>.<p>Be sure to ask any questions on <a href=https://piazza.com/class/jyt32n7mdjkw2>Piazza</a>.<h3 id=coding-style>Coding style</h3><p><strong>This section is identical to the <a href=hw2.html#coding-style>Coding style</a> section of Homework 2.</strong><p>You should run <code class="language-plaintext highlighter-rouge">clang-format</code> on each of the C source and header files you write. This will format all of your files consistently.<p>If you use NeoVim or Vim as your editor, you can include the line (called a mode line)<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code>// vim: <span class=nb>set </span><span class=nv>sw</span><span class=o>=</span>2 <span class=nv>sts</span><span class=o>=</span>2 <span class=nv>ts</span><span class=o>=</span>8 et:
</code></pre></div></div><p>at the bottom of each of your files to force Vim to indent by 2 spaces and to ensure that tabs will insert spaces. You can set options in your <code class="language-plaintext highlighter-rouge">~/.vimrc</code> file, creating one if necessary. For example, on clyde, I have the simple <code class="language-plaintext highlighter-rouge">~/.vimrc</code> (note that this is slightly expanded from the one given in the <a href=hw1.html>homework 1</a> write up to set the values for C files).<div class="language-viml highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>set</span> <span class=nb>background</span><span class=p>=</span><span class=nb>dark</span>
<span class=k>filetype</span> plugin <span class=nb>indent</span> <span class=k>on</span>
autocmd <span class=nb>FileType</span> <span class=k>sh</span> <span class=k>setlocal</span> <span class=nb>shiftwidth</span><span class=p>=</span><span class=m>2</span> <span class=nb>softtabstop</span><span class=p>=</span><span class=m>2</span> <span class=nb>tabstop</span><span class=p>=</span><span class=m>8</span> <span class=nb>expandtab</span>
autocmd <span class=nb>FileType</span> <span class=k>c</span> <span class=k>setlocal</span> <span class=nb>shiftwidth</span><span class=p>=</span><span class=m>2</span> <span class=nb>softtabstop</span><span class=p>=</span><span class=m>2</span> <span class=nb>tabstop</span><span class=p>=</span><span class=m>8</span> <span class=nb>expandtab</span>
</code></pre></div></div><p>The first line tells Vim to use colors suitable for a terminal with a dark background. The second line tells Vim to use file-type aware indenting. The third line tells Vim to set those options for shell script files. And the fourth line does the same thing, but for C files. See the <a href=https://vim.fandom.com/wiki/Indenting_source_code>Vim wiki</a> for more details.<p>If you use emacs, you’re kind of on your own. Feel free to ask on Piazza, search StackOverflow, and read the <a href=https://www.emacswiki.org/emacs/IndentationBasics>Emacs Wiki</a>.<p>Same with Nano. <a href=https://stackoverflow.com/questions/42584551/how-to-make-auto-indention-in-nano-while-programming-in-python-in-linux>This</a> might be useful.<h3 id=code-warnings-and-errors>Code warnings and errors</h3><p>Your code must compile without error or warning when compiled with <code class="language-plaintext highlighter-rouge">-std=c11 -Wall</code>.<p>Additionally, for this assignment, you need to compile and link your code with <code class="language-plaintext highlighter-rouge">-fsanitize=address,undefined</code>. To do this, we need to make some changes to your <code class="language-plaintext highlighter-rouge">Makefile</code> rules. Take a look in the skeleton <code class="language-plaintext highlighter-rouge">Makefile</code> provided with the assignment code.<p>Notice how there is a new variable <code class="language-plaintext highlighter-rouge">LDFLAGS</code>. This is where flags passed to the linker go. Since <code class="language-plaintext highlighter-rouge">-fsanitize=address,undefined</code> need to be passed to both the compiler and to the linker, we include them in both <code class="language-plaintext highlighter-rouge">CFLAGS</code> and <code class="language-plaintext highlighter-rouge">LDFLAGS</code>. The rule to compile binaries now<div class="language-make highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nl>foo</span><span class=o>:</span> <span class=nf>a.o b.o c.o</span>
        <span class=err>$(CC)</span> <span class=err>$(LDFLAGS)</span> <span class=err>-o</span> <span class=err>$@</span> <span class=err>$^</span>
</code></pre></div></div><h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Your repository should contain the following files<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>├── Makefile
├── README.md
├── tests
│&nbsp;&nbsp; ├── common.sh
│&nbsp;&nbsp; ├── run_tests
│&nbsp;&nbsp; ├── test_caesar
│&nbsp;&nbsp; ├── test_help
│&nbsp;&nbsp; ├── test_pig
│&nbsp;&nbsp; ├── test_reverse
│&nbsp;&nbsp; └── test_shouty
└── wordmod.c
</code></pre></div></div><p>It may also a <a href=https://git-scm.com/docs/gitignore><code class="language-plaintext highlighter-rouge">.gitignore</code></a> file which tells Git to ignore files matching patterns in your working directory (like <code class="language-plaintext highlighter-rouge">*.o</code>, for example).<p>You may also split your implementation of <code class="language-plaintext highlighter-rouge">wordmod</code> into multiple source and header files. These should also be included in your repository.<p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">master</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">master</code> contains the version of the code you want graded.)<p>The <code class="language-plaintext highlighter-rouge">README.md</code> should contain<ul><li>An image link showing the Travis CI build status (see part 0)<li>The names of both partners (or just your name if you worked alone…but<li>please don’t work alone if you can manage it).<li>An estimate of the amount of time it took to complete each program.<li>Any known bugs or incomplete functions.<li>Any interesting design decisions you’d like to share.</ul><p>Each of your source files with a <code class="language-plaintext highlighter-rouge">main</code> function should contain a comment at the top of the file that contains usage information plus a description of what the program does.<p>Example.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>// Usage: ./wordmod [OPTIONS]</span>
<span class=c1>// </span>
<span class=c1>// Wordmod will ...</span>
</code></pre></div></div><h2 id=part-0-makefile-testing-and-travis-ci>Part 0. Makefile, testing, and Travis CI</h2><h3 id=makefile>Makefile</h3><p>The assignment code comes with a bare-bones <code class="language-plaintext highlighter-rouge">Makefile</code>. You need to expand upon it as you work through the following parts. Use a pattern rule to compile <code class="language-plaintext highlighter-rouge">.o</code> files from the corresponding <code class="language-plaintext highlighter-rouge">.c</code> files. Make sure each <code class="language-plaintext highlighter-rouge">.o</code> file depends on the appropriate header files and each program you write depends on the appropriate <code class="language-plaintext highlighter-rouge">.o</code> files.<p>The <code class="language-plaintext highlighter-rouge">all</code> target should depend on all of the programs you write.<p>The <code class="language-plaintext highlighter-rouge">clean</code> target should delete all of the programs you write and all of the object files. (Using <code class="language-plaintext highlighter-rouge">*.o</code> in <code class="language-plaintext highlighter-rouge">clean</code> is perfectly acceptable.)<h3 id=testing>Testing</h3><p>The assignment code also comes with a set of testing scripts in the <code class="language-plaintext highlighter-rouge">tests</code> directory. You can run them by running <code class="language-plaintext highlighter-rouge">$ make check</code>.<p>There are a handful of tests in the testing directory. You need to write more tests to test the functionality of each part.<p>As you work through the parts below, run <code class="language-plaintext highlighter-rouge">$ make check</code> frequently to make sure that you haven’t broken any code you previously had working.<h3 id=travis-ci>Travis CI</h3><p>This homework also uses the <a href=https://travis-ci.com/>Travis CI</a> continuous integration service. Each time you push your code to GitHub, Travis will download the latest version, build your program and then run the tests.<p>You should be able to see the status of your latest commit by logging in to <a href=https://travis-ci.com>Travis CI</a> using your GitHub account. You can also see the latest status from Travis by clicking on the <code class="language-plaintext highlighter-rouge">1 branch</code> link near the top of the GitHub page for your repository which has URL <code class="language-plaintext highlighter-rouge">https://github.com/systems-programming/${repo_name}/branches</code>. You should see either a green check mark if all tests passed or a red X if one or more tests failed.<p>You should add a build status image to your <code class="language-plaintext highlighter-rouge">README.md</code> by following the <a href=https://docs.travis-ci.com/user/status-images/>instructions</a> to get the Markdown code to paste into <code class="language-plaintext highlighter-rouge">README.md</code>.<h2 id=part-1-overview-and-command-line-arguments>Part 1. Overview and command line arguments</h2><p>In this assignment, you will write a program called <code class="language-plaintext highlighter-rouge">wordmod</code> that will perform a variety of modifications to words read from <code class="language-plaintext highlighter-rouge">stdin</code> and written to <code class="language-plaintext highlighter-rouge">stdout</code>. The choice of modification will be controlled by command line flags.<p>The basic flow of <code class="language-plaintext highlighter-rouge">wordmod</code> should be the following.<ol><li>Use <code class="language-plaintext highlighter-rouge">getopt(3)</code> to parse command line arguments and determine which transformation, if any, is to be applied to the input.<li>In a loop, <ol><li>Read in and print any characters that do not form part of a word;<li>Read in a word of up to 45 characters;<li>Perform the requested transformation by calling an appropriate function on the just-read word; and<li>Print the transformed word.</ol></ol><p>There should be a command line option for each transformation described in the subsequent parts. In addition, <code class="language-plaintext highlighter-rouge">-h</code> should print out a help message with usage information and exit with exit value 0. Any unknown options should cause the help message and usage information to be printed and exit with exit value 0. (<code class="language-plaintext highlighter-rouge">getopt()</code> itself will print a message about invalid options.) As usual, error messages should go to <code class="language-plaintext highlighter-rouge">stderr</code> and normal output should go to <code class="language-plaintext highlighter-rouge">stdout</code>. (<code class="language-plaintext highlighter-rouge">-h</code> produces normal output, unknown options produce error messages.)<p>Here’s example output.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ ./wordmod -h
Usage: ./wordmod [OPTIONS]

Options:
  -c NUM  Caesar cipher, shift by NUM
  -h      show this help
  -p      Pig Latin
  -r      reverse
  -s      shouty
</code></pre></div></div><p>If the user specifies multiple transformations, print an error message (on <code class="language-plaintext highlighter-rouge">stderr</code>) and exit with a nonzero exit value.<p>If the word you read in is longer than 45 characters, do not perform any transformations on it. Just output it as is. For the purposes of this assignment, a word is considered a consecutive sequence of letters, digits, and apostrophes. You may want to write a function <code class="language-plaintext highlighter-rouge">isword()</code>.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>// Returns true if ch is a letter, digit, or apostrophe.</span>
<span class=n>bool</span> <span class=nf>isword</span><span class=p>(</span><span class=kt>int</span> <span class=n>ch</span><span class=p>);</span>
</code></pre></div></div><p>Take a look at the man pages for <code class="language-plaintext highlighter-rouge">isalpha(3)</code> and <code class="language-plaintext highlighter-rouge">isdigit(3)</code>.<p>For each modification, you’re going to call a function and pass the string in as input. The modification function will write the modification to another string. For most of these, it’s important you don’t use the same array for input and output. C won’t complain, but your code will likely crash or otherwise misbehave!<p>You want something like the following.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>feof</span><span class=p>(</span><span class=n>stdin</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>ferror</span><span class=p>(</span><span class=n>stdin</span><span class=p>))</span> <span class=p>{</span>
  <span class=kt>char</span> <span class=n>word</span><span class=p>[</span><span class=n>INPUT_SIZE</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
  <span class=kt>char</span> <span class=n>modified</span><span class=p>[</span><span class=n>OUTPUT_SIZE</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>

  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>echo_until_word</span><span class=p>())</span>
    <span class=k>break</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>get_word</span><span class=p>(</span><span class=n>word</span><span class=p>))</span> <span class=p>{</span>
    <span class=cm>/* Handle an overly long word. */</span>
    <span class=k>continue</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>switch</span><span class=p>(</span><span class=n>transform</span><span class=p>)</span> <span class=p>{</span>
  <span class=cm>/* ... */</span>
  <span class=k>case</span> <span class=sc>'s'</span><span class=p>:</span>
    <span class=n>shouty</span><span class=p>(</span><span class=n>modified</span><span class=p>,</span> <span class=n>word</span><span class=p>);</span>
    <span class=k>break</span><span class=p>;</span>
  <span class=cm>/* ... */</span>
  <span class=p>}</span>
  <span class=cm>/* print the modified word */</span>
<span class=p>}</span>
</code></pre></div></div><dl><dt>where<dt><code class="language-plaintext highlighter-rouge">feof(3)</code> and <code class="language-plaintext highlighter-rouge">ferror(3)</code><dd>are standard library functions, check their man pages;<dt><code class="language-plaintext highlighter-rouge">echo_until_word()</code><dd>prints characters until it encounters a word character or <code class="language-plaintext highlighter-rouge">EOF</code>, returning <code class="language-plaintext highlighter-rouge">true</code> if a word character was encountered and <code class="language-plaintext highlighter-rouge">false</code> if <code class="language-plaintext highlighter-rouge">EOF</code>;<dt><code class="language-plaintext highlighter-rouge">get_word()</code><dd>stores at most <code class="language-plaintext highlighter-rouge">INPUT_SIZE</code> word characters (plus a trailing <code class="language-plaintext highlighter-rouge">0</code> byte), returning <code class="language-plaintext highlighter-rouge">true</code> if the next input character is either <code class="language-plaintext highlighter-rouge">EOF</code> or not a word character.<dt><code class="language-plaintext highlighter-rouge">transform</code><dd>is the selected transformation; and<dt><code class="language-plaintext highlighter-rouge">shouty()</code><dd>is defined in <a href=#part-2-shouty>Part 2</a>.</dl><p>For each of the functions described in the remaining parts, you might want to add a <code class="language-plaintext highlighter-rouge">size_t size</code> parameter that is the size of your output array. You would modify the code above to call it like<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code>    <span class=n>shouty</span><span class=p>(</span><span class=n>modified</span><span class=p>,</span> <span class=n>word</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>modified</span><span class=p>);</span>
</code></pre></div></div><p>This size might be useful if you use <code class="language-plaintext highlighter-rouge">strlcpy(3)</code>/<code class="language-plaintext highlighter-rouge">strlcat(3)</code>. Note that if you want to use those functions, you need to modify your <code class="language-plaintext highlighter-rouge">Makefile</code> to include <code class="language-plaintext highlighter-rouge">-lbsd</code> at the end of the recipe for <code class="language-plaintext highlighter-rouge">wordmod</code>:<div class="language-make highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nl>wordmod</span><span class=o>:</span> <span class=nf>$(wordmod_objs)</span>
        <span class=err>$(CC)</span> <span class=err>$(LDFLAGS)</span> <span class=err>-o</span> <span class=err>$@</span> <span class=err>$^</span> <span class=err>-lbsd</span>
</code></pre></div></div><h1 id=part-2-shouty>Part 2. Shouty</h1><p>The first transformation is <em>shouty</em>. For this part, you should write a function<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>shouty</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>output</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>input</span><span class=p>);</span>
</code></pre></div></div><p>which takes a string <code class="language-plaintext highlighter-rouge">input</code> and copies it to the string <code class="language-plaintext highlighter-rouge">output</code>, making each character upper case.<p>This transformation should be used when the user passes the <code class="language-plaintext highlighter-rouge">-s</code> option.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ echo 'Sometimes I feel shouty!' | ./wordmod -s
SOMETIMES I FEEL SHOUTY!
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">toupper(3)</code> function may be useful.<h1 id=part-3-reverse>Part 3. Reverse</h1><p>The next transformation is <em>reverse</em>. For this part, you should write a function<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>reverse</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>output</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>input</span><span class=p>);</span>
</code></pre></div></div><p>which takes <code class="language-plaintext highlighter-rouge">input</code> and reverses it into <code class="language-plaintext highlighter-rouge">output</code>.<p>This transformation should be used when the user passes the <code class="language-plaintext highlighter-rouge">-s</code> option.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ echo 'TACOCAT si a emordnilap' | ./wordmod -r
TACOCAT is a palindrome
</code></pre></div></div><h1 id=part-4-caesar-cipher>Part 4. Caesar cipher</h1><p>For this transformation, you should implement the <a href=https://en.wikipedia.org/wiki/Caesar_cipher>Caesar cipher</a> with a variable shift count. Letters should retain their case, digits and apostrophe should be unchanged. The amount to shift should be given as an argument to the <code class="language-plaintext highlighter-rouge">-c</code> option. Positive shift amounts should shift forward in the alphabet, negative shift counts should shift backward. (See the examples below.)<p>Implement<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>caesar</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>output</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>input</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shift_amount</span><span class=p>);</span>
</code></pre></div></div><p>which shifts each letter character of <code class="language-plaintext highlighter-rouge">input</code> by <code class="language-plaintext highlighter-rouge">shift_amount</code>.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ echo '0 shifts given' | ./wordmod -c 0
0 shifts given
$ echo 'Fuvsg ol 13; irel fuvsgl!' | ./wordmod -c 13
Shift by 13; very shifty!
$ echo 'Vkliw lqwr uhyhuvh.' | ./wordmod -c -3
Shift into reverse.
</code></pre></div></div><p>Check out the man pages for <code class="language-plaintext highlighter-rouge">isupper(3)</code> and <code class="language-plaintext highlighter-rouge">islower(3)</code>.<h1 id=part-5-pig-latin>Part 5. Pig Latin</h1><p>For this part, you’ll be implementing a transformation to turn English into <a href=https://en.wikipedia.org/wiki/Pig_Latin>Pig Latin</a> (don’t worry about the rules described on Wikipedia, just follow the ones given below).<p>Implement the function<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>pig</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>output</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>input</span><span class=p>);</span>
</code></pre></div></div><p>according to the following rules.<ol><li>If the word contains anything but letters (which for our purposes means it contains a digit or apostrophe), don’t transform it.<li>If the word contains no vowels—a, e, i, o, u, or y—don’t transform it.<li>If the word starts with a, e, i, o, or u, append “yay”.<li>Otherwise move all of the characters before the first vowel—a, e, i, o, u, or y—to the end of the word and append “ay”.</ol><p>The exception is that “qu” should be treated a consonant in these rules. That is, “qu” remains “qu” (because rule 2 says it has no vowels) and “quite” becomes “itequay” rather than “uiteqay” (because rule 4 says the first vowel is the “i”).<p>In addition to the rules above, you need to modify capitalization such that if the input word stars with a capital letter, then the output word should start with a capital letter and the original capital letter should be lowercased. (See the examples below.)<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ echo "That'll do, pig." | ./wordmod -p
That'll oday, igpay.
$ echo 'Linux is pretty OK.' | ./wordmod -p
Inuxlay isyay ettypray OKyay.
</code></pre></div></div><p>You may find <code class="language-plaintext highlighter-rouge">strcspn(3)</code> useful.</main>