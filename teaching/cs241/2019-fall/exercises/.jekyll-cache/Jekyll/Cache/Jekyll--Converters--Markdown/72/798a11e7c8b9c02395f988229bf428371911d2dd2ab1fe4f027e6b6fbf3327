I"´<h1 id="lecture-4--sep-11th-2019">Lecture 4 ‚Äì Sep 11th, 2019</h1>

<h2 id="setup">Setup</h2>
<ol>
  <li>Log on to clyde: <code class="highlighter-rouge">ssh user@clyde.cs.oberlin.edu</code>.</li>
  <li>Create a directory with whatever name you like and <code class="highlighter-rouge">cd</code> into it.</li>
</ol>

<h2 id="task">Task</h2>
<ol>
  <li>The command <code class="highlighter-rouge">$ ls /bin /usr/bin</code> will print out a list of all the files
in <code class="highlighter-rouge">/bin</code> and <code class="highlighter-rouge">/usr/bin</code>. Each of these is a program you can run, but there
are likely too many to display in your terminal. So run the command again,
but redirect the output to a file called <code class="highlighter-rouge">binaries</code>.</li>
  <li>Run <code class="highlighter-rouge">$ wc -l binaries</code> to see how many lines are in the file.</li>
  <li>Open the file with your favorite command line editor (e.g., <code class="highlighter-rouge">nvim</code>, <code class="highlighter-rouge">vim</code>,
<code class="highlighter-rouge">emacs</code>, <code class="highlighter-rouge">nano</code>) and take a look at the output. Is the number you printed
out in step 2 the actual number of binaries? Hint: Look closely at the
first line.</li>
  <li>One thing to notice is the output from <code class="highlighter-rouge">ls</code> is different when directed to a
file than it is when it goes to the terminal. It turns out that programs
can detect if their stdout is connected to a terminal or not. Some programs
use this ability to change their output, some do not. Run <code class="highlighter-rouge">$man isatty</code> and
take a look at the manual page for the <code class="highlighter-rouge">isatty()</code> function. This is a C
function and we‚Äôll get to programming in C soon enough. For now, it‚Äôs
enough to know that stdout is file descriptor 1 so the function call
<code class="highlighter-rouge">isatty(1)</code> tells the program if stdout is a terminal or not.</li>
  <li>Let‚Äôs figure out how many binaries start with the letter <code class="highlighter-rouge">z</code> by using
<code class="highlighter-rouge">grep</code>. Recall <code class="highlighter-rouge">grep</code> reads files (or stdin) and prints lines matching a
pattern. Run <code class="highlighter-rouge">$ grep z binaries</code>. Notice that it prints out all lines
containing a <code class="highlighter-rouge">z</code>. That‚Äôs not what we want, but we‚Äôre close.</li>
  <li>Grep interprets the <code class="highlighter-rouge">^</code> character to mean ‚Äúmatch the beginning of the line‚Äù
so <code class="highlighter-rouge">$ grep ^z binaries</code> should do what we want. Run that and look at the
output.</li>
  <li>
    <p>Let‚Äôs figure out how many of them there are. Rerun that <code class="highlighter-rouge">grep</code> command and
redirect stdout to a file <code class="highlighter-rouge">zfiles</code>. Run the appropriate <code class="highlighter-rouge">wc</code> command to
figure out how many there are.</p>

    <p>To recap what we‚Äôve done so far, we created a file containing a list of all
of the binaries in <code class="highlighter-rouge">/bin</code> and <code class="highlighter-rouge">/usr/bin</code>. We used <code class="highlighter-rouge">grep</code> to extract just
those that start with <code class="highlighter-rouge">z</code> and stored that in a file. Finally, we ran <code class="highlighter-rouge">wc</code>
on that to figure out how many there are. Pretty simple but we had to
create two files for it that we don‚Äôt really care about if our goal was
just to figure out that final number.</p>
  </li>
  <li>
    <p>We can skip the creation of the first file by <em>piping</em> the output of <code class="highlighter-rouge">ls</code>
to <code class="highlighter-rouge">grep</code> and storing the result to a file. Explicitly,</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /bin /usr/bin | <span class="nb">grep</span> <span class="s1">'^z'</span> <span class="o">&gt;</span>zfiles1
</code></pre></div>    </div>

    <p>Notice that we don‚Äôt specific a file name for <code class="highlighter-rouge">grep</code>. When we omit it, it
reads from stdin.</p>
  </li>
  <li>
    <p>Let‚Äôs check that the two files we just created are identical by using the
<code class="highlighter-rouge">diff</code> program to print out the differences between two files. Run</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>diff <span class="nt">-u</span> zfiles zfiles1
</code></pre></div>    </div>

    <p>Nothing should be printed when you do that because the files should be the
same.</p>
  </li>
  <li>Append a line of text (anything you want) to <code class="highlighter-rouge">zfiles1</code> using <code class="highlighter-rouge">echo</code> with
an append redirection (<code class="highlighter-rouge">&gt;&gt;</code>).</li>
  <li>Rerun the <code class="highlighter-rouge">diff</code> command from step 9. You should see some output. (Diffing
files is extremely useful. We‚Äôll see more of this later and you‚Äôll see a
lot of it as you program more.)</li>
  <li>Enough <code class="highlighter-rouge">diff</code> for now. In step 8, we skipped the creation of one file by
using a pipe but we still created a second file. Construct a new command
piping the output of <code class="highlighter-rouge">ls</code> to <code class="highlighter-rouge">grep</code> and piping that output to <code class="highlighter-rouge">wc</code>. You
should get exactly the output you got in step 7.</li>
  <li>We actually did more work than we needed to. Remember that the shell will
expand wildcards that match file names. For example, <code class="highlighter-rouge">/bin/z*</code> will be
expanded to the paths of all of the files that match that pattern. Run <code class="highlighter-rouge">$
echo /bin/z*</code> to see the result.</li>
  <li>
    <p>Using <code class="highlighter-rouge">ls</code> rather than <code class="highlighter-rouge">echo</code> (because <code class="highlighter-rouge">echo</code> prints a single line and we
want multiple lines) and the appropriate patterns, construct a pipeline to
count all of the binaries starting with <code class="highlighter-rouge">z</code> again. That is, fill in the
missing bits in</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="o">[</span>...] | <span class="nb">wc</span> <span class="nt">-l</span>
</code></pre></div>    </div>
  </li>
  <li>That‚Äôs enough for today. You can delete the directory you created.</li>
</ol>
:ET