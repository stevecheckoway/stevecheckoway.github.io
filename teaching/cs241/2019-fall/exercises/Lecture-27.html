<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 27</title><meta name=description content="Lecture 27 – Nov 13th, 2019"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2019-fall/exercises/Lecture-27.html> <link rel=stylesheet href=/css/main.css><main><h1 id=lecture-27--nov-13th-2019>Lecture 27 – Nov 13th, 2019</h1><h2 id=setup>Setup</h2><ol><li>Log in to clyde.</ol><h2 id=task>Task</h2><ol><li><p><a href=Lecture-26.html>Last time</a>, you wrote two versions of a program to compute a 1-byte checksum. If you completed them, you may use those programs. Otherwise, you can copy <code class=highlighter-rouge>~steve/ex/checksum-v2</code> to your home directory and use my solutions.<p>If you use your own, edit the <code class=highlighter-rouge>Makefile</code> to change <code class=highlighter-rouge>-fsanitize=address,unknown</code> to <code class=highlighter-rouge>-fsanitize=unknown</code> in both the <code class=highlighter-rouge>CFLAGS</code> and <code class=highlighter-rouge>LDFLAGS</code>. Run <code class=highlighter-rouge>$ make clean</code> and then <code class=highlighter-rouge>$ make</code> to rebuild without the Address Sanitizer.<li>You can time how long a Bash command takes to run but prefixing the command with <code class=highlighter-rouge>time</code>. Time how long <code class=highlighter-rouge>checksum</code> and <code class=highlighter-rouge>checksum2</code> take to run on themselves: <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ time ./checksum checksum checksum2
$ time ./checksum2 checksum checksum2
</code></pre></div></div><p>Time will print out three numbers, the total (<code class=highlighter-rouge>real</code>) time it took to run the command and how much of that was spent in your code (<code class=highlighter-rouge>user</code>) versus the kernel (<code class=highlighter-rouge>sys</code>).<p>You probably saw that <code class=highlighter-rouge>checksum</code> spent significantly more time in the kernel than <code class=highlighter-rouge>checksum2</code>.<p>Let’s figure out why that is.<li>You’re going to use <code class=highlighter-rouge>strace(1)</code> to trace the system calls made by a program. We’re interested in file operations since that’s what the difference between the two programs are. We can use the <code class=highlighter-rouge>-e</code> option to limit the set of system calls <code class=highlighter-rouge>strace(1)</code> prints out. To make things shorter, let’s run the checksum programs on the <code class=highlighter-rouge>Makefile</code>. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ strace -e trace=open,openat,close,read,write ./checksum Makefile
$ strace -e trace=open,openat,close,read,write ./checksum2 Makefile
</code></pre></div></div><p>In both cases, it will open, read from, and close files you don’t care about. You can ignore those lines of output and just focus on the ones where it’s opening and reading from the <code class=highlighter-rouge>Makefile</code>. I.e., focus on the lines starting with<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>openat(AT_FDCWD, "Makefile", O_RDONLY)  = 3
</code></pre></div></div><p>(<code class=highlighter-rouge>openat(2)</code> is a system call like <code class=highlighter-rouge>open(2)</code> except it takes the path to be relative to a directory. You can read about its operation in its man page, if you like.)<p>Why did <code class=highlighter-rouge>checksum</code> take so much more time than <code class=highlighter-rouge>checksum2</code>? Next time you find yourself writing code to read and write from files, think carefully about whether you want to use a <code class=highlighter-rouge>FILE *</code> or a file descriptor.<li><p>In Bash, we can redirect output of an arbitrary command to a file like this <code class=highlighter-rouge>$ cmd &gt;output.txt</code>.<p>Let’s figure out how Bash does that using <code class=highlighter-rouge>strace(1)</code>. Bash’s <code class=highlighter-rouge>-c</code> option takes a string to run as input. E.g., if we run<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ bash -c '/bin/echo hello &gt;output.txt'
</code></pre></div></div><p>in Bash, then this will start a new instance of Bash which will run the command in quotes and then exit.<p>We can use strace’s <code class=highlighter-rouge>-f</code> option to trace children processes (remember, Bash will first <code class=highlighter-rouge>fork(2)</code> and then use <code class=highlighter-rouge>execve(2)</code> to transform the child process into <code class=highlighter-rouge>/bin/echo</code>.<p>Run this command.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ strace -o syscalls.txt -f bash -c '/bin/echo hello &gt;output.txt'
</code></pre></div></div><p>Passing <code class=highlighter-rouge>-o file</code> to <code class=highlighter-rouge>strace(1)</code> causes it to write its output to <code class=highlighter-rouge>file</code> rather than <code class=highlighter-rouge>stderr</code>.<li><p>Open <code class=highlighter-rouge>syscalls.txt</code> in an editor (Vim will highlight the <code class=highlighter-rouge>strace(1)</code> output by default. There’s an Emacs mode that will do it too, but it doesn’t appear to be installed on Clyde.) There’s a lot of output here. The number preceding each line is the process id (PID) of the process that made the system call.<p>Let’s find the <code class=highlighter-rouge>fork(2)</code> in the output. Interestingly, Linux doesn’t use a <code class=highlighter-rouge>fork</code> system call. Instead, it uses <code class=highlighter-rouge>clone</code> which is more general. When I did this, I got the line<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>8038  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f76f75c2a10) = 8039
</code></pre></div></div><p>which tells me that the Bash with PID 8038 forked and the child had PID 8039. The next few lines of <code class=highlighter-rouge>rt_sig...</code> system calls are changing signal handling masks, we’ll talk about this next time.<p>There’s also a <code class=highlighter-rouge>getpid(2)</code> and <code class=highlighter-rouge>wait4(2)</code>. The latter is just like <code class=highlighter-rouge>wait(2)</code> but with more options.<p>Finally, there’s an <code class=highlighter-rouge>openat(2)</code> which opens <code class=highlighter-rouge>output.txt</code> for writing, creating it if it doesn’t already exist, and truncating the file if it does.<p>Starting with the <code class=highlighter-rouge>openat(2)</code> and going up to the system call just before the <code class=highlighter-rouge>execve("/bin/echo", ...)</code> is the sequence of system calls that Bash made to perform the redirection. There’s only one new one there. Read its corresponding man page.<li>Copy <code class=highlighter-rouge>~steve/ex/redir</code> to your directory. Modify <code class=highlighter-rouge>redir.c</code> such that when you run <code class=highlighter-rouge>$ ./redir -o file command arguments</code> it runs <code class=highlighter-rouge>command arguments</code> with <code class=highlighter-rouge>stdout</code> redirected to <code class=highlighter-rouge>file</code>. You only need to add some lines inside the <code class=highlighter-rouge>if</code> statement to open the file and perform the redirection. You can make a similar set of system calls that Bash did to perform the redirection.</ol></main>