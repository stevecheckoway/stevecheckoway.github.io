<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 13</title><meta name=description content="Lecture 13 – Oct 2nd, 2019"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2019-fall/exercises/Lecture-13.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css> <script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-34500030-2","auto"),ga("send","pageview")</script><main><h1 id=lecture-13--oct-2nd-2019>Lecture 13 – Oct 2nd, 2019</h1><h2 id=setup>Setup</h2><ol><li>Log in to clyde.<li>Create a directory and <code class=highlighter-rouge>cd</code> into it.</ol><h2 id=task>Task</h2><ol><li>Implement a function in C that returns the value of the most significant bit of an <code class=highlighter-rouge>unsigned int</code> using <code class=highlighter-rouge>CHAR_BIT</code> (defined in <code class=highlighter-rouge>limits.h</code>) and <code class=highlighter-rouge>sizeof(unsigned int)</code> to figure out how many bits are in an <code class=highlighter-rouge>unsigned int</code>. <div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>msb</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
  <span class=cm>/* ... */</span>
<span class=p>}</span>
</code></pre></div></div><p>I recommend creating a constant <code class=highlighter-rouge>NUM_BITS</code> defined in terms of <code class=highlighter-rouge>CHAR_BIT</code> and <code class=highlighter-rouge>sizeof(unsigned int)</code> that is the number of bits in an <code class=highlighter-rouge>unsigned int</code>.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#define NUM_BITS (</span><span class=cm>/* ... */</span><span class=cp>)
</span></code></pre></div></div><li>Test your implementation by printing out the result of <code class=highlighter-rouge>msb(0)</code>, <code class=highlighter-rouge>msb(1)</code>, <code class=highlighter-rouge>msb(-1)</code>. [Fun fact: Because clyde, like all modern machines, uses two’s complement integers, converting a signed integer like <code class=highlighter-rouge>-1</code> to an unsigned integer does not change the bit pattern, instead negative integers become large positive integers.]<li>Implement a function that extracts the least significant <code class=highlighter-rouge>n</code> bits of an <code class=highlighter-rouge>unsigned int x</code>. <div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>extract_lsbs</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=cm>/* ... */</span>
<span class=p>}</span>
</code></pre></div></div><p><code class=highlighter-rouge>assert(3)</code> is defined in <code class=highlighter-rouge>assert.h</code>.<li>Test <code class=highlighter-rouge>extract_lsbs</code> by printing out the result of extracting a few different numbers of bits (printing hex using <code class=highlighter-rouge>printf</code>’s <code class=highlighter-rouge>%x</code> specifier is by far the easiest way to see this). E.g., <code class=highlighter-rouge>extract_lsbs(0x378, 5)</code> should return <code class=highlighter-rouge>0x18</code>.<li>Implement a function that returns a bit field—a contiguous sequence of bits—from <code class=highlighter-rouge>x</code> that starts at <code class=highlighter-rouge>start</code> and is <code class=highlighter-rouge>n</code> bits long. <div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>extract_field</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span>
                           <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span>
                           <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>start</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span> <span class=o>-</span> <span class=n>start</span><span class=p>);</span>
  <span class=cm>/* ... */</span>
<span class=p>}</span>
</code></pre></div></div><li>Test <code class=highlighter-rouge>extract_field</code>. E.g., <code class=highlighter-rouge>extract_field(0x11223344, 17, 9)</code> should return <code class=highlighter-rouge>0x91</code>.<li><p>That second assert in task 5 is unusual looking, but correct. The more natural looking assertion, <code class=highlighter-rouge>assert(n + start &lt; NUM_BITS)</code> is <em>incorrect</em>.<p>Find unsigned integers <code class=highlighter-rouge>start</code> and <code class=highlighter-rouge>n</code> such that calling the following function with them causes the program to abort, but only on the marked line.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>crash_me</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>start</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=n>start</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span> <span class=o>-</span> <span class=n>start</span><span class=p>);</span> <span class=c1>// Abort on this line.</span>
<span class=p>}</span>
</code></pre></div></div><p>When it crashes, it should look like this (although file names and line numbers will differ).<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>a.out: bit_fields.c:27: void crash_me(unsigned int, unsigned int): Assertion `n &lt; NUM_BITS - start' failed.
Aborted (core dumped)
</code></pre></div></div></ol></main>