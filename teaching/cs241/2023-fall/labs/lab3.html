<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lab 3: Introduction to Rust</title><meta name=description content="Lab 3: Introduction to Rust Due: 2023-XX-XX at 23:59"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2023-fall/labs/lab3.html> <link rel=stylesheet href=/css/main.css><main><h1 id=lab-3-introduction-to-rust>Lab 3: Introduction to Rust</h1><p><strong>Due: 2023-XX-XX at 23:59</strong><section><h2 id=preliminaries>Preliminaries</h2><p>First, find a partner. You’re allowed to work by yourself, but I highly recommend working with a partner. Click on the <a href=https://example.com>assignment link</a>. One partner should create a new team. The second partner should click the link and choose the appropriate team. (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository and begin working.<p>Be sure to ask any questions on <a href=https://example.com>Piazza</a>.<h3 id=compiler-warnings-and-errors>Compiler warnings and errors</h3><p>Make sure your code compiles and passes <code class="language-plaintext highlighter-rouge">clippy</code> without errors or warnings. That is, running<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ cargo clean
$ cargo build
$ cargo clippy
</code></pre></div></div><p>should build your program without errors or warnings.<h3 id=formatting>Formatting</h3><p>Your code must be formatted by running <code class="language-plaintext highlighter-rouge">cargo fmt</code>.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Your repository should contain the following files and directory.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>repo
├── README
├── guessing_game
│&nbsp;&nbsp; ├── Cargo.lock
│&nbsp;&nbsp; ├── Cargo.toml
│&nbsp;&nbsp; └── src
│&nbsp;&nbsp;     └── main.rs
└── iteration
    ├── Cargo.lock
    ├── Cargo.toml
    └── src
        └── main.rs

</code></pre></div></div><p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>The <code class="language-plaintext highlighter-rouge">README</code> should contain the names of both partners (or just your name if you worked alone…but please don’t work alone if you can manage it).</section><section><h2 id=part-1-guessing-game-15-points>Part 1. Guessing Game (15 points)</h2><p>The first application you will write is a number guessing game.<h3 id=task-1>Task 1</h3><p>Follow the instructions given in <a href=https://rust-book.cs.brown.edu/ch02-00-guessing-game-tutorial.html>Chapter 2 of the book</a> with the following adjustments:<ul><li><p>In the section “Setting Up a New Project,” it tells you to go to a <code class="language-plaintext highlighter-rouge">projects</code> directory. Instead, <code class="language-plaintext highlighter-rouge">cd</code> into the assignment repository you cloned. You’ll create <code class="language-plaintext highlighter-rouge">guessing_game</code> in there when you run <code class="language-plaintext highlighter-rouge">cargo new guessing_game</code><p>It’s important that you do this from inside the assignment repository. Don’t run <code class="language-plaintext highlighter-rouge">cargo new guessing_game</code> and then later <code class="language-plaintext highlighter-rouge">mv</code> the directory into the assignment repo.<p>After you run <code class="language-plaintext highlighter-rouge">cargo new guessing_game</code>, open up Visual Studio Code by running<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ code guessing_game
</code></pre></div></div><p>This will open Visual Studio Code which will ask you some questions:<ol><li>Do you trust the authors of the code? Yes.<li>It detects that the containing directory is the root of a Git repository and it will ask if you want to open it. Say yes and then select the path to the assignment directory from the list displayed (there will only be one entry). Now, you can use Git directly from VS Code’s user interface.</ol><li><p>Once you have opened Visual Studio Code, it’s time to install two extensions. Click on the 4-boxes icon on the left side of the window. Enter <code class="language-plaintext highlighter-rouge">rust-analyzer</code> in the search box at the top of the left panel. Click on the <code class="language-plaintext highlighter-rouge">rust-analyzer</code> extension and then click install. Also install the <code class="language-plaintext highlighter-rouge">CodeLLDB</code> extension which will let us run the debugger!<li><p>When it tells you to run <code class="language-plaintext highlighter-rouge">cargo run</code>, you can do that from your open terminal window (after <code class="language-plaintext highlighter-rouge">cd guessing_game</code>), or you can use VS Code’s built-in terminal to run it.<p>Let’s configure VS Code to be able to build, run, and debug our code. Click on the <code class="language-plaintext highlighter-rouge">Run and Debug</code> button (shaped like a triangle with a bug on it) on the left side of the window. Click the “create a launch.json file” text. It will ask you for a debugger, select <code class="language-plaintext highlighter-rouge">LLDB</code>. This asks if you want to generate launch configurations for its targets. Say yes.<p>You can close the <code class="language-plaintext highlighter-rouge">launch.json</code> file it created and opened.<p>At this point, you can run and debug your application from VS Code.</ul><p>Once you have finished writing the <code class="language-plaintext highlighter-rouge">guessing_game</code>, you should make sure you’ve added your files to Git and committed them. You can do so either from the command line, or from within VS Code. Here are the <a href=https://code.visualstudio.com/docs/sourcecontrol/overview>docs</a> for how to do it from within VS Code.</section><section><h2 id=part-2-iteration-35-points>Part 2. Iteration (35 points)</h2><p>Iteration with iterators is a key concept in Rust. Iteration is similar to Java but has some quirks which can be quite surprising.<p>In this part, you’ll explore iterating over elements in a vector and iterating over characters in a string.<h3 id=task-21>Task 2.1</h3><p>In a shell, <code class="language-plaintext highlighter-rouge">cd</code> to your assignment repository and create a new project using <code class="language-plaintext highlighter-rouge">cargo</code> and then open it in VS Code.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ cargo new iteration
$ code iteration
</code></pre></div></div><p>Change the <code class="language-plaintext highlighter-rouge">main</code> function to<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>let</span> <span class=n>data</span> <span class=o>=</span> <span class=nd>vec!</span><span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>13</span><span class=p>];</span>

    <span class=k>for</span> <span class=n>x</span> <span class=k>in</span> <span class=n>data</span> <span class=p>{</span>
        <span class=nd>println!</span><span class=p>(</span><span class=s>"{x}"</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">vec!</code> macro creates a new <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html><code class="language-plaintext highlighter-rouge">Vec</code></a> containing the elements in the brackets. (Click the link in the previous sentence to go to the documentation for <code class="language-plaintext highlighter-rouge">Vec</code>.) <code class="language-plaintext highlighter-rouge">Vec</code> is the standard vector class in Rust: it is a growable array of elements, similar to a list in Python and an <code class="language-plaintext highlighter-rouge">ArrayList</code> in Java. The <code class="language-plaintext highlighter-rouge">vec!</code> macro here gives a result similar to this (but more efficient and easier to read).<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>let</span> <span class=k>mut</span> <span class=n>data</span> <span class=o>=</span> <span class=nn>Vec</span><span class=p>::</span><span class=nf>new</span><span class=p>();</span> <span class=c1>// Create a new Vec</span>
<span class=n>data</span><span class=nf>.push</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>  <span class=c1>// Add 2 to the end of the Vec.</span>
<span class=n>data</span><span class=nf>.push</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>  <span class=c1>// Add 3 to the end of the Vec.</span>
<span class=c1>// ...</span>
<span class=n>data</span><span class=nf>.push</span><span class=p>(</span><span class=mi>13</span><span class=p>);</span> <span class=c1>// Add 13 to the end of the Vec.</span>
</code></pre></div></div><p>Predict what the output of the code will be and then run it. If you predicted incorrectly, try to figure out why the code does what it does before moving on.<p>Now, duplicate the for loop<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>let</span> <span class=n>data</span> <span class=o>=</span> <span class=nd>vec!</span><span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>13</span><span class=p>];</span>

    <span class=k>for</span> <span class=n>x</span> <span class=k>in</span> <span class=n>data</span> <span class=p>{</span>
        <span class=nd>println!</span><span class=p>(</span><span class=s>"{x}"</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=n>x</span> <span class=k>in</span> <span class=n>data</span> <span class=p>{</span>
        <span class=nd>println!</span><span class=p>(</span><span class=s>"{x}"</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>Again, predict what the output of the code will be and then run it.<p>I suspect the results are quite surprising. You probably got an error that looks like this.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>error[E0382]: use of moved value: `data`
   --&gt; src/main.rs:8:14
    |
2   |     let data = vec![2, 3, 5, 7, 11, 13];
    |         ---- move occurs because `data` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3   |
4   |     for x in data {
    |              ---- `data` moved due to this implicit call to `.into_iter()`
...
8   |     for x in data {
    |              ^^^^ value used here after move
    |
note: `into_iter` takes ownership of the receiver `self`, which moves `data`
   --&gt; /Users/steve/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:262:18
    |
262 |     fn into_iter(self) -&gt; Self::IntoIter;
    |                  ^^^^
help: consider iterating over a slice of the `Vec&lt;i32&gt;`'s content to avoid moving into the `for` loop
    |
4   |     for x in &amp;data {
    |              +

For more information about this error, try `rustc --explain E0382`.
error: could not compile `iteration` (bin "iteration") due to previous error
</code></pre></div></div><p>This is a lot of information and it’s quite difficult to understand at first. Reading error messages takes practice. If you look carefully, you’ll notice that the error message is divided into three parts, the error, a note, and a help.<p>The error tells us that we have tried to use a moved value, namely <code class="language-plaintext highlighter-rouge">data</code> on line 8, column 14 of the file <code class="language-plaintext highlighter-rouge">src/main.rs</code>. Next, it shows that on line 2 the variable <code class="language-plaintext highlighter-rouge">data</code> has type <code class="language-plaintext highlighter-rouge">std::vec::Vec&lt;i32&gt;</code> which does not implement <code class="language-plaintext highlighter-rouge">Copy</code>. Then, on line 4, <code class="language-plaintext highlighter-rouge">data</code> was moved due an implicit call to <code class="language-plaintext highlighter-rouge">.into_iter()</code> and finally, on line 8, we tried to use <code class="language-plaintext highlighter-rouge">data</code> again.<p>We’ll talk about what this all means but basically, the first <code class="language-plaintext highlighter-rouge">for</code> loop used up our <code class="language-plaintext highlighter-rouge">Vec</code> and it no longer exists. This is <em>not</em> how we normally expect <code class="language-plaintext highlighter-rouge">for</code> loops to work. Nevertheless, this is how Rust works.<p>The note portion of the error message tells us why it was used up and shows us code from the standard library to explain why. Let’s skip this part for now.<p>Finally, the help portion offers a way to solve this problem. If we use <code class="language-plaintext highlighter-rouge">for x in &amp;data { }</code> (note the addition of the ampersand <code class="language-plaintext highlighter-rouge">&amp;</code>), this will avoid consuming <code class="language-plaintext highlighter-rouge">data</code>. Note that it suggests making this change only on the first <code class="language-plaintext highlighter-rouge">for</code> loop (which for me happens to be on line 4). By using <code class="language-plaintext highlighter-rouge">&amp;data</code> rather than <code class="language-plaintext highlighter-rouge">data</code>, we’re instructing the loop to iterate over a reference to the <code class="language-plaintext highlighter-rouge">Vec</code>, rather than the <code class="language-plaintext highlighter-rouge">Vec</code> itself. The upshot is that we can now iterate multiple times.<p>Go ahead and make that change and rerun <code class="language-plaintext highlighter-rouge">cargo run</code>. At this point, your code should print out the list twice.<h2 id=task-22>Task 2.2</h2><p>In the rest of the lab, you’re going to write some short functions dealing with vectors and strings and you’re going to write some unit tests for the functions.<p>Implement the function <code class="language-plaintext highlighter-rouge">reversed_vec</code>.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>reversed_vec</span><span class=p>(</span><span class=n>input_data</span><span class=p>:</span> <span class=o>&amp;</span><span class=p>[</span><span class=nb>i32</span><span class=p>])</span> <span class=k>-&gt;</span> <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>i32</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=k>let</span> <span class=k>mut</span> <span class=n>result</span><span class=p>:</span> <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>i32</span><span class=o>&gt;</span> <span class=o>=</span> <span class=nn>Vec</span><span class=p>::</span><span class=nf>new</span><span class=p>();</span>
    <span class=nd>todo!</span><span class=p>(</span><span class=s>"Finish this function"</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div></div><p>Two things to notice<ol><li>The input argument <code class="language-plaintext highlighter-rouge">input_data</code> is of type <code class="language-plaintext highlighter-rouge">&amp;[i32]</code>. We’ll talk more about this type later, but for now, think of this as a reference to a <code class="language-plaintext highlighter-rouge">Vec</code>. We saw this above when we wrote <code class="language-plaintext highlighter-rouge">for x in &amp;data {}</code> where <code class="language-plaintext highlighter-rouge">data</code> was a <code class="language-plaintext highlighter-rouge">Vec</code> so <code class="language-plaintext highlighter-rouge">&amp;data</code> essentially gives us a <code class="language-plaintext highlighter-rouge">&amp;[i32]</code>.<li>The <code class="language-plaintext highlighter-rouge">result</code> variable is declared mutable (with the <code class="language-plaintext highlighter-rouge">mut</code> keyword) so we can modify it by inserting elements using the <code class="language-plaintext highlighter-rouge">push()</code> function.</ol><p>Before you remove the <code class="language-plaintext highlighter-rouge">todo!()</code> and implement this function, let’s write a unit test similar to the unit tests you wrote in CSCI 151.<p>At the bottom of <code class="language-plaintext highlighter-rouge">main.rs</code>, add the following code.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nd>#[cfg(test)]</span>
<span class=k>mod</span> <span class=n>test</span> <span class=p>{</span>
    <span class=k>use</span> <span class=k>super</span><span class=p>::</span><span class=o>*</span><span class=p>;</span>

    <span class=nd>#[test]</span>
    <span class=k>fn</span> <span class=nf>reversed_vec_empty</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>let</span> <span class=n>data</span> <span class=o>=</span> <span class=nd>vec!</span><span class=p>[];</span>
        <span class=nd>assert_eq!</span><span class=p>(</span><span class=nf>reversed_vec</span><span class=p>(</span><span class=o>&amp;</span><span class=n>data</span><span class=p>),</span> <span class=nd>vec!</span><span class=p>[]);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>There’s a lot to unpack here. The first line, <code class="language-plaintext highlighter-rouge">#[cfg(test)]</code> tells the compiler that the item that follows it should only be compiled when we’re compiling tests. And that item is a <em>module</em> named <code class="language-plaintext highlighter-rouge">test</code>. (The name is arbitrary but is traditionally called <code class="language-plaintext highlighter-rouge">test</code>.) We’ll talk more about modules later.<p>The <code class="language-plaintext highlighter-rouge">use super::*;</code> line makes all of the functions in <code class="language-plaintext highlighter-rouge">main.rs</code> outside the <code class="language-plaintext highlighter-rouge">test</code> module available for use inside the <code class="language-plaintext highlighter-rouge">test</code> module.<p>Finally, each unit test we write is just a Rust function that is annotated with <code class="language-plaintext highlighter-rouge">#[test]</code>. If you omit this annotation, the function will not be treated as a test.<p>Run the command <code class="language-plaintext highlighter-rouge">$ cargo test</code>. You should see some warnings followed by a test failure (remember, we didn’t implement <code class="language-plaintext highlighter-rouge">reversed_vec()</code> so it makes sense our test should fail).<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>running 1 test
test test::reversed_vec_empty ... FAILED

failures:

---- test::reversed_vec_empty stdout ----
thread 'test::reversed_vec_empty' panicked at 'not yet implemented: Finish this function', src/main.rs:19:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test::reversed_vec_empty

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre></div></div><p>Notice that the output tells us our code panicked (i.e., failed) on line 19 of <code class="language-plaintext highlighter-rouge">main.rs</code>.<p>Before implementing <code class="language-plaintext highlighter-rouge">reversed_vec()</code>, write two more tests<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code>    <span class=nd>#[test]</span>
    <span class=k>fn</span> <span class=nf>reversed_vec_one</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>todo!</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=nd>#[test]</span>
    <span class=k>fn</span> <span class=nf>reversed_vec_three</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>todo!</span><span class=p>();</span>
    <span class=p>}</span>
</code></pre></div></div><p>that test the result of reversing a vector with 1 element and a vector with 3 elements.<p><code class="language-plaintext highlighter-rouge">$ cargo test</code> should now show three failing tests.<p>Implement the rest of <code class="language-plaintext highlighter-rouge">reversed_vec()</code>.<p><strong>Hints:</strong><ol><li>You can create an iterator over <code class="language-plaintext highlighter-rouge">input_data</code> using <code class="language-plaintext highlighter-rouge">input_data.iter()</code>. Some iterators let you create reverse iterators using the <code class="language-plaintext highlighter-rouge">rev()</code> function. In other words, given one iterator <code class="language-plaintext highlighter-rouge">it</code>, you can create a new iterator via <code class="language-plaintext highlighter-rouge">it.rev()</code> that will iterate in reverse order. So <code class="language-plaintext highlighter-rouge">for x in input_data.iter().rev() { }</code> will iterate over <code class="language-plaintext highlighter-rouge">input_data</code> in reverse order.<li>The iterator returned by <code class="language-plaintext highlighter-rouge">input_data.iter()</code> will <em>not</em> make copies of the elements in <code class="language-plaintext highlighter-rouge">input_data</code>. Instead, the value returned by the iterator will be a reference to the elements. That is, in <div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>for</span> <span class=n>x</span> <span class=k>in</span> <span class=n>input_data</span><span class=nf>.iter</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</code></pre></div></div><p>the type of <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">&amp;i32</code> and <em>not</em> <code class="language-plaintext highlighter-rouge">i32</code>. Since our <code class="language-plaintext highlighter-rouge">result</code> vector holds <code class="language-plaintext highlighter-rouge">i32</code> and not <code class="language-plaintext highlighter-rouge">&amp;i32</code>, we need to <em>dereference</em> the reference <code class="language-plaintext highlighter-rouge">x</code> to get the underlying integer. We use the <code class="language-plaintext highlighter-rouge">*</code> operator to do this. For example,<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>for</span> <span class=n>x</span> <span class=k>in</span> <span class=n>input_data</span><span class=nf>.iter</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// result.push(x); // Fails because x has type &amp;i32</span>
    <span class=n>result</span><span class=nf>.push</span><span class=p>(</span><span class=o>*</span><span class=n>x</span><span class=p>);</span> <span class=c1>// Succeeds because *x has type i32</span>
<span class=p>}</span>
</code></pre></div></div><p>shows the incorrect and correct ways to insert the element into <code class="language-plaintext highlighter-rouge">result</code>.</ol><p>Once you implement your function, run <code class="language-plaintext highlighter-rouge">$ cargo test</code> and make sure you have 3 passing tests and no failing tests.<p>You’re probably getting a warning at this point about <code class="language-plaintext highlighter-rouge">reversed_vec</code> not being used. Add the line<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nd>#![allow(dead_code)]</span>
</code></pre></div></div><p>to the very top of <code class="language-plaintext highlighter-rouge">main.rs</code> and it’ll stop warning about the functions that we’re only using in tests.<h2 id=task-23>Task 2.3</h2><p>Write a function<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>is_in_order</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=o>&amp;</span><span class=p>[</span><span class=nb>i32</span><span class=p>])</span> <span class=k>-&gt;</span> <span class=nb>bool</span> <span class=p>{</span>
    <span class=nd>todo!</span><span class=p>(</span><span class=s>"Implement me"</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div></div><p>that returns <code class="language-plaintext highlighter-rouge">true</code> if the elements of <code class="language-plaintext highlighter-rouge">data</code> are in ascending order and false otherwise.<p>Before implementing the function write some unit tests that should pass once your implement the function. Some suggestions for things to test<ol><li>Empty vectors are always in order.<li>Vectors containing a single element are always in order.<li>Vectors with multiple elements, in order.<li>Vectors with multiple elements, not in order.</ol><p>Implement <code class="language-plaintext highlighter-rouge">is_in_order</code> and make sure it passes your tests.<p>My output for <code class="language-plaintext highlighter-rouge">$ cargo test</code> looks like this.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>running 7 tests
test test::is_in_order_empty ... ok
test test::is_in_order_multiple_out_of_order ... ok
test test::reversed_vec_empty ... ok
test test::is_in_order_multiple_in_order ... ok
test test::is_in_order_one ... ok
test test::reversed_vec_one ... ok
test test::reversed_vec_three ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre></div></div><h2 id=task-24>Task 2.4</h2><p>Write a function that iterates over the elements in its argument and adds them all and returns the sum.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>manual_sum</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=o>&amp;</span><span class=p>[</span><span class=nb>i32</span><span class=p>])</span> <span class=k>-&gt;</span> <span class=nb>i32</span> <span class=p>{</span>
    <span class=k>let</span> <span class=k>mut</span> <span class=n>data_iter</span> <span class=o>=</span> <span class=n>data</span><span class=nf>.iter</span><span class=p>();</span>
    <span class=nd>todo!</span><span class=p>(</span><span class=s>"Implement me"</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div></div><p>The catch is that for this task, you may not use a <code class="language-plaintext highlighter-rouge">for</code> loop. Instead, you’ll need to work with the iterator returned by <code class="language-plaintext highlighter-rouge">data.iter()</code> directly. Iterators in Rust work similarly to iterators in Java. To implement this as a Java method using iterators rather than a <code class="language-plaintext highlighter-rouge">for</code> loop we might use something like this.<div class="language-java highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>int</span> <span class=nf>manualSum</span><span class=o>(</span><span class=nc>ArrayList</span><span class=o>&lt;</span><span class=nc>Integer</span><span class=o>&gt;</span> <span class=n>data</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=nc>Iterator</span><span class=o>&lt;</span><span class=nc>Integer</span><span class=o>&gt;</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=na>iterator</span><span class=o>();</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>iter</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>
        <span class=n>sum</span> <span class=o>+=</span> <span class=n>iter</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></div></div><p>Iterators in Rust don’t have separate <code class="language-plaintext highlighter-rouge">has_next()</code> and <code class="language-plaintext highlighter-rouge">next()</code> methods. Instead, there’s just a single <code class="language-plaintext highlighter-rouge">next()</code> method that returns an <a href=https://doc.rust-lang.org/std/option/index.html><code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code></a>. Every <code class="language-plaintext highlighter-rouge">Option</code> is either <code class="language-plaintext highlighter-rouge">None</code> or <code class="language-plaintext highlighter-rouge">Some(blah)</code> for some value <code class="language-plaintext highlighter-rouge">blah</code>. Here’s a simple example of using an <code class="language-plaintext highlighter-rouge">Option</code>.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>let</span> <span class=n>x</span> <span class=o>=</span> <span class=nf>Some</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
<span class=nd>assert!</span><span class=p>(</span><span class=n>x</span><span class=nf>.is_some</span><span class=p>());</span>
<span class=nd>assert!</span><span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=nf>.is_none</span><span class=p>());</span>
<span class=nd>assert_eq!</span><span class=p>(</span><span class=n>x</span><span class=nf>.unwrap</span><span class=p>(),</span> <span class=mi>10</span><span class=p>);</span>

<span class=k>let</span> <span class=n>y</span> <span class=o>=</span> <span class=nb>None</span><span class=p>;</span>
<span class=nd>assert!</span><span class=p>(</span><span class=n>y</span><span class=nf>.is_none</span><span class=p>());</span>
<span class=nd>assert!</span><span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=nf>.is_some</span><span class=p>());</span>
</code></pre></div></div><p>We can use <code class="language-plaintext highlighter-rouge">is_some()</code> or <code class="language-plaintext highlighter-rouge">is_none()</code> to determine if an <code class="language-plaintext highlighter-rouge">Option</code> is a <code class="language-plaintext highlighter-rouge">Some</code> or a <code class="language-plaintext highlighter-rouge">None</code>. If we have a <code class="language-plaintext highlighter-rouge">Some</code>, then we can <em>unwrap</em> it by calling <code class="language-plaintext highlighter-rouge">unwrap()</code> which returns the data. If we try calling <code class="language-plaintext highlighter-rouge">unwrap()</code> on <code class="language-plaintext highlighter-rouge">None</code>, we’ll get a runtime error.<p>Write some unit tests. Make sure you cover the edges cases like empty <code class="language-plaintext highlighter-rouge">data</code> (where the sum should be 0), and single element vectors.<p>Implement <code class="language-plaintext highlighter-rouge">manual_sum</code> by calling <code class="language-plaintext highlighter-rouge">next()</code> on <code class="language-plaintext highlighter-rouge">data_iter</code> repeatedly until the result is <code class="language-plaintext highlighter-rouge">None</code>. Unwrap all of the other values and sum them up.<p><strong>Hint:</strong> You’ll probably want a loop like this.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>loop</span> <span class=p>{</span>
    <span class=c1>// XXX: Get the next element from the iterator</span>
    <span class=k>if</span> <span class=cm>/* the element is None */</span> <span class=p>{</span>
      <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// XXX: Unwrap and add the value to the loop.</span>
</code></pre></div></div><h2 id=task-24-1>Task 2.4</h2><p>Strings in Rust are similar to vectors of characters except that, unfortunately, they’re slightly more difficult to use because text is inherently complicated than vectors.<p>The most obvious difficulty is you cannot access individual characters in the same way you’d access individual elements of a vector.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>let</span> <span class=n>x</span> <span class=o>=</span> <span class=nd>vec!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>];</span>
<span class=nd>assert_eq!</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=mi>1</span><span class=p>);</span>

<span class=k>let</span> <span class=n>y</span> <span class=o>=</span> <span class=s>"ABC"</span><span class=p>;</span>
<span class=nd>assert_eq!</span><span class=p>(</span><span class=n>y</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=sc>'A'</span><span class=p>);</span> <span class=c1>// FAILS!</span>
</code></pre></div></div><p>That last line fails because you cannot index into a string like this. The problem is that Rust stores all strings in the UTF-8 encoding. This is a variable-length encoding where different characters may take a different number of characters to encode. So if you want to get the 10 th character from a string, for example, you cannot easily figure out where in the encoded data for the string the 10 th character starts without starting at the beginning of the string.<p>This means that to work with characters, we’re going to need to use an iterator over the characters. Fortunately, the <code class="language-plaintext highlighter-rouge">chars()</code> function returns an iterator that returns each character.<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>let</span> <span class=n>example</span> <span class=o>=</span> <span class=s>"Here is my string"</span><span class=p>;</span>
<span class=k>for</span> <span class=n>ch</span> <span class=k>in</span> <span class=n>example</span><span class=nf>.chars</span><span class=p>()</span> <span class=p>{</span>
    <span class=nd>println!</span><span class=p>(</span><span class=s>"{ch}"</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></div><p>Just as we’ve made a distinction between <code class="language-plaintext highlighter-rouge">Vec&lt;i32&gt;</code> and <code class="language-plaintext highlighter-rouge">&amp;[i32]</code> where the latter is a reference to the former, in Rust we have a <a href=https://doc.rust-lang.org/std/string/struct.String.html><code class="language-plaintext highlighter-rouge">String</code></a> data type and a reference to a string <code class="language-plaintext highlighter-rouge">&amp;str</code>. When we have a function that takes a reference to a string, we use an argument of type <code class="language-plaintext highlighter-rouge">&amp;str</code>. Note that strings we create by enclosing text in quotation marks have type <code class="language-plaintext highlighter-rouge">&amp;str</code> and <em>not</em> <code class="language-plaintext highlighter-rouge">String</code>. If we have a <code class="language-plaintext highlighter-rouge">String</code> and we want to pass it to a function that takes a <code class="language-plaintext highlighter-rouge">&amp;str</code>, we get a reference to the string using <code class="language-plaintext highlighter-rouge">&amp;</code> just as we did with vectors and reference to vectors.<p>Write a function<div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>clown_case</span><span class=p>(</span><span class=n>s</span><span class=p>:</span> <span class=o>&amp;</span><span class=nb>str</span><span class=p>)</span> <span class=k>-&gt;</span> <span class=nb>String</span> <span class=p>{</span>
  <span class=nd>todo!</span><span class=p>(</span><span class=s>"Implement me"</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div></div><p>that takes a <code class="language-plaintext highlighter-rouge">&amp;str</code> as input and returns a new <code class="language-plaintext highlighter-rouge">String</code> that alternates capitalization and includes a clown emoji, 🤡, at the beginning and end of the string as long as <code class="language-plaintext highlighter-rouge">s</code> is not the empty string. If <code class="language-plaintext highlighter-rouge">s</code> is the empty string, return just a single clown emoji.<p>Here are some examples. I recommend you turn them into unit tests before you implement <code class="language-plaintext highlighter-rouge">clown_case</code>.<ul><li><code class="language-plaintext highlighter-rouge">""</code> -&gt; <code class="language-plaintext highlighter-rouge">"🤡"</code><li><code class="language-plaintext highlighter-rouge">I'm just asking questions"</code> -&gt; <code class="language-plaintext highlighter-rouge">"🤡 i'M jUsT aSkInG qUeStIoNs 🤡"</code><li><code class="language-plaintext highlighter-rouge">"Μην είσαι κλόουν στα ελληνικά!"</code> -&gt; <code class="language-plaintext highlighter-rouge">"🤡 μΗν ΕίΣαΙ κΛόΟυΝ σΤα ΕλΛηΝιΚά! 🤡"</code></ul><p><strong>Hints:</strong><ol><li>If <code class="language-plaintext highlighter-rouge">ch</code> is a <code class="language-plaintext highlighter-rouge">char</code>, you can use <code class="language-plaintext highlighter-rouge">ch.is_alphabetic()</code> to decide if you want to lowercase or uppercase the letter or just include it in the result unchanged. I.e., only uppercase/lowercase the characters for which <code class="language-plaintext highlighter-rouge">ch.is_alphabetic()</code> returns true.<li>If <code class="language-plaintext highlighter-rouge">ch</code> is a <code class="language-plaintext highlighter-rouge">char</code>, then <code class="language-plaintext highlighter-rouge">ch.to_lowercase()</code> and <code class="language-plaintext highlighter-rouge">ch.to_uppercase()</code> return iterators to <code class="language-plaintext highlighter-rouge">char</code>s rather than a <code class="language-plaintext highlighter-rouge">char</code> itself. Why? Well, in some languages converting the case changes the number of characters. E.g, a capital <a href=https://en.wikipedia.org/wiki/%C3%9F><code class="language-plaintext highlighter-rouge">ß</code></a> is <code class="language-plaintext highlighter-rouge">SS</code>. You can add the elements of an iterator to a string using the <code class="language-plaintext highlighter-rouge">extend()</code> function. <div class="language-rust highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>let</span> <span class=k>mut</span> <span class=n>result</span> <span class=o>=</span> <span class=nn>String</span><span class=p>::</span><span class=nf>new</span><span class=p>();</span>
<span class=n>result</span><span class=nf>.extend</span><span class=p>(</span><span class=sc>'ß'</span><span class=nf>.to_uppercase</span><span class=p>());</span>
<span class=nd>assert_eq!</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=s>"SS"</span><span class=p>);</span>
</code></pre></div></div><li>You can append a <code class="language-plaintext highlighter-rouge">char</code> to a <code class="language-plaintext highlighter-rouge">String</code> by using <code class="language-plaintext highlighter-rouge">push()</code>. You can append a <code class="language-plaintext highlighter-rouge">&amp;str</code> to a <code class="language-plaintext highlighter-rouge">String</code> by using <code class="language-plaintext highlighter-rouge">push_str()</code>.</ol><p>After you have everything working, make sure you add your code, commit it, and push it to GitHub.</section></main>