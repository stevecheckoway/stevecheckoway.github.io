<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lab 2: Shell scripting</title><meta name=description content="Lab 2: Shell scripting Due: 2023-09-18 at 23:59"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2023-fall/labs/lab2.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css><main><h1 id=lab-2-shell-scripting>Lab 2: Shell scripting</h1><p><strong>Due: 2023-09-18 at 23:59</strong><section><h2 id=preliminaries>Preliminaries</h2><p>First, find a partner. You’re allowed to work by yourself, but I highly recommend working with a partner. Click on the <a href=https://example.com>assignment link</a>. One partner should create a new team. The second partner should click the link and choose the appropriate team. (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository and begin working. But before you do, read the entire assignment and be sure to check out the expected <a href=#coding-style>coding style</a>.<p>Be sure to ask any questions on <a href=https://example.com>Piazza</a>.<h3 id=coding-style>Coding style</h3><p>For all of the shell scripts you write, I recommend you follow the Google <a href=https://google.github.io/styleguide/shell.xml>Shell Style Guide</a>. Look at the section on formatting. These rules are, in many ways, arbitrary. However, it’s good to stick to one style. The guide says to use two spaces to indent. Use whatever you’d like, but be consistent.<details><summary>Hints for VS Code users</summary><p>Once you open a shell script, the bottom of the window should show something like<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>Ln 1, Col 1  Spaces: 4  UTF-8  LF  Shell Script
</code></pre></div></div><p>You can change the number of spaces by clicking on <code class="language-plaintext highlighter-rouge">Space: 4</code>, then <code class="language-plaintext highlighter-rouge">Indent using spaces</code> and then select 2 (to match the Shell Style Guide).</details><details><summary>Hints for Vim users</summary><p>If you use NeoVim or Vim as your editor, you can include the line (called a modeline)<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c># vim: set sw=2 sts=2 ts=8 et:</span>
</code></pre></div></div><p>at the bottom of each of your scripts to force Vim to indent by 2 spaces and to ensure that tabs will insert spaces (to match the Shell Style Guide). This requires “modeline” support to be enabled which is disabled by default. You can enable it by adding the line<div class="language-viml highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>set</span> <span class=nb>modeline</span>
</code></pre></div></div><p>to your <code class="language-plaintext highlighter-rouge">~/.vimrc</code> file, creating it if necessary.<p>You can also set options in your <code class="language-plaintext highlighter-rouge">~/.vimrc</code> file, creating one if necessary. For example, on clyde, I have the simple <code class="language-plaintext highlighter-rouge">~/.vimrc</code>.<div class="language-viml highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>set</span> <span class=nb>background</span><span class=p>=</span><span class=nb>dark</span>
<span class=k>filetype</span> plugin <span class=nb>indent</span> <span class=k>on</span>
autocmd <span class=nb>FileType</span> <span class=k>sh</span> <span class=k>setlocal</span> <span class=nb>shiftwidth</span><span class=p>=</span><span class=m>2</span> <span class=nb>softtabstop</span><span class=p>=</span><span class=m>2</span> <span class=nb>tabstop</span><span class=p>=</span><span class=m>8</span> <span class=nb>expandtab</span>
<span class=k>set</span> <span class=nb>modeline</span>
</code></pre></div></div><p>The first line tells Vim to use colors suitable for a terminal with a dark background. The second line tells Vim to use file-type aware indenting. The third line tells Vim to set those options for shell script files. See the <a href=https://vim.fandom.com/wiki/Indenting_source_code>Vim wiki</a> for more details. And the fourth enables modelines.<p>After you write the <code class="language-plaintext highlighter-rouge">#!/bin/bash</code> line at the top of your file (or a modeline at the bottom), you’ll probably want to reopen the file so that Vim knows its a bash file and turns on the appropriate syntax highlighting and indentation.</details><p>If you use emacs, you’re kind of on your own. Feel free to ask on Piazza, search StackOverflow, and read the <a href=https://www.emacswiki.org/emacs/IndentationBasics>Emacs Wiki</a>.<p>Same with Nano. <a href=https://stackoverflow.com/questions/42584551/how-to-make-auto-indention-in-nano-while-programming-in-python-in-linux>This</a> might be useful.<h3 id=run-time-errors-and-return-values>Run time errors and return values</h3><p>For each of the parts below that ask you to print out a usage message or an error message, this message should be printed to <code class="language-plaintext highlighter-rouge">stderr</code>. You can use code like this to print a usage message.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>echo "Usage: $0 arguments" &gt;&amp;2
</code></pre></div></div><p>Any errors should cause the script to exit with a nonzero value (1 is a pretty good choice). Scripts that run successfully should exit with value 0. You can use <code class="language-plaintext highlighter-rouge">exit 1</code> to exit with the value 1.<h3 id=script-warnings-and-errors>Script warnings and errors</h3><p>Make sure your scripts pass <code class="language-plaintext highlighter-rouge">shellcheck</code> without errors or warnings. If you disable a particular warning, you must leave a comment giving a very good reason why you did so.<h3 id=executable-scripts>Executable scripts</h3><p>All of your scripts should start with the line<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>#!/bin/bash
</code></pre></div></div><p>and must be executable. Running <code class="language-plaintext highlighter-rouge">$ chmod +x</code> on each of the files before adding them to Git is sufficient.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>Your repository should contain the following files and directory.<ul><li><code class="language-plaintext highlighter-rouge">README</code><li><code class="language-plaintext highlighter-rouge">genfrac</code><li><code class="language-plaintext highlighter-rouge">shellcheckall</code><li><code class="language-plaintext highlighter-rouge">topfiletypes</code><li><code class="language-plaintext highlighter-rouge">images/</code></ul><p>It may also a <a href=https://git-scm.com/docs/gitignore><code class="language-plaintext highlighter-rouge">.gitignore</code></a> file which tells Git to ignore files matching patterns in your working directory.<p>Any additional files you have added to your repository should be removed from the <code class="language-plaintext highlighter-rouge">main</code> branch. (You’re free to make other branches, if you desire, but make sure <code class="language-plaintext highlighter-rouge">main</code> contains the version of the code you want graded.)<p>The <code class="language-plaintext highlighter-rouge">README</code> should contain<ol><li>The names of both partners (or just your name if you worked alone…but please don’t work alone if you can manage it).<li>Your answers to questions for each part and the commands you used to find them.</ol><p>Each of your scripts should contain a comment at the top of the script (below the <code class="language-plaintext highlighter-rouge">#!/bin/bash</code> line) that contains usage information plus a description of what the program does.<p>Example.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>#!/bin/bash

# Usage: shellcheckall [dir]
#
# The dir parameter should be the path to a directory. Shellcheckall will...
</code></pre></div></div></section><section><h2 id=part-1-multiple-executions-15-points>Part 1. Multiple executions (15 points)</h2><p>One of the most common tasks when working with computers is running a program multiple times with different inputs. (As just a single example, in the final project for CSCI 210, you first write a program to simulate how a part of the processor operates. You will then run this program with different options on different inputs. This is an error-prone operation. Instead, you could write a simple shell script to run the program all of the different ways you need.)<p>In this part, you will be writing a shell script to run a program (that is provided to you)<p>Clone the <a href=https://github.com/stevecheckoway/jfrac>jfrac</a> repository. This repository holds the source code for a simple program, written in Rust, that generates images of the <a href=https://en.wikipedia.org/wiki/Julia_set#Quadratic_polynomials>Julia set fractal</a>.<p>Inside the <code class="language-plaintext highlighter-rouge">jfrac</code> directory, run the following command.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ cargo run -- default.png
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">cargo</code> tool is used to building (and in this case running) software written in Rust. This will produce an image file that is 800 pixels wide and 800 pixels high named <code class="language-plaintext highlighter-rouge">default.png</code>. It looks like this.<p><img src=default.png alt="Julia set fractal" title="Default image">.<p>The matematics behind the Julia set are explained on the Wikipedia page, but are not important for us here. What <em>is</em> important is that by changing the complex number <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=application/x-tex>c</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em></span><span class=base><span class="mord mathit">c</span></span></span></span> in the equation <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi></mrow><annotation encoding=application/x-tex>f(z)=z^2 + c</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.8141079999999999em></span><span class="strut bottom" style=height:1.064108em;vertical-align:-0.25em></span><span class=base><span class="mord mathit" style=margin-right:0.10764em>f</span><span class=mopen>(</span><span class="mord mathit" style=margin-right:0.04398em>z</span><span class=mclose>)</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mrel>=</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mord><span class="mord mathit" style=margin-right:0.04398em>z</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.8141079999999999em><span style=top:-3.063em;margin-right:0.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class="mord mathit">c</span></span></span></span>, we can drastically change the output fractal. The number <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=application/x-tex>c</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em></span><span class=base><span class="mord mathit">c</span></span></span></span> is specified by passing the <code class="language-plaintext highlighter-rouge">--constant</code> option to the program. For example, the default constant is <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mo>=</mo><mo>−</mo><mn>0</mn><mi mathvariant=normal>.</mi><mn>4</mn><mo>+</mo><mn>0</mn><mi mathvariant=normal>.</mi><mn>6</mn><mi>i</mi></mrow><annotation encoding=application/x-tex>c=-0.4 + 0.6i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.65952em></span><span class="strut bottom" style=height:0.74285em;vertical-align:-0.08333em></span><span class=base><span class="mord mathit">c</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mrel>=</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mord>−</span><span class=mord>0</span><span class=mord>.</span><span class=mord>4</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>0</span><span class=mord>.</span><span class=mord>6</span><span class="mord mathit">i</span></span></span></span> so running<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ cargo run -- --constant="-0.4 + 0.6i" explicit.png
</code></pre></div></div><p>will produce the file <code class="language-plaintext highlighter-rouge">explicit.png</code> which is identical to <code class="language-plaintext highlighter-rouge">default.png</code> shown above. The strange <code class="language-plaintext highlighter-rouge">--</code> by itself is required here. Everything before the <code class="language-plaintext highlighter-rouge">--</code> is an option or argument for <code class="language-plaintext highlighter-rouge">cargo</code>. Everything after the <code class="language-plaintext highlighter-rouge">--</code> is an option or argument for the <code class="language-plaintext highlighter-rouge">jfrac</code> binary itself.<p>There’s no man page for <code class="language-plaintext highlighter-rouge">jfrac</code>, but it comes with a short help. Run<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ cargo run -- --help
</code></pre></div></div><p>to see the options.<h3 id=task-1>Task 1</h3><p>First, play around with the <code class="language-plaintext highlighter-rouge">--constant</code> option to <code class="language-plaintext highlighter-rouge">jfrac</code> to produce images with different constants. Look at the examples given in the <a href=https://en.wikipedia.org/wiki/Julia_set#Quadratic_polynomials>quadratic polynomials</a> section of Wikipedia for inspiration. You’ll likely want to select values of <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mi>i</mi></mrow><annotation encoding=application/x-tex>c = x + yi</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.65952em></span><span class="strut bottom" style=height:0.85396em;vertical-align:-0.19444em></span><span class=base><span class="mord mathit">c</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mrel>=</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class="mord mathit">x</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>+</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class="mord mathit" style=margin-right:0.03588em>y</span><span class="mord mathit">i</span></span></span></span> such that <span class=katex><span class=katex-mathml><math><semantics><mrow><mi mathvariant=normal>∣</mi><mi>x</mi><mi mathvariant=normal>∣</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>|x| &lt; 1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mord>∣</span><span class="mord mathit">x</span><span class=mord>∣</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mrel>&lt;</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mord>1</span></span></span></span> and <span class=katex><span class=katex-mathml><math><semantics><mrow><mi mathvariant=normal>∣</mi><mi>y</mi><mi mathvariant=normal>∣</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>|y| &lt; 1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em></span><span class=base><span class=mord>∣</span><span class="mord mathit" style=margin-right:0.03588em>y</span><span class=mord>∣</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mrel>&lt;</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mord>1</span></span></span></span>.<p>Find 5 values of <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=application/x-tex>c</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em></span><span class=base><span class="mord mathit">c</span></span></span></span> that you like.<p>Your task is to write a script, <code class="language-plaintext highlighter-rouge">genfrac</code> which will run the <code class="language-plaintext highlighter-rouge">jfrac</code> command several times (by using <code class="language-plaintext highlighter-rouge">cargo run</code> as shown above) using two nested <code class="language-plaintext highlighter-rouge">for</code> loops.<p>Your script (which can assume that the <code class="language-plaintext highlighter-rouge">jfrac</code> directory is in your current directory) must generate each of the 5 fractals at 3 different sizes, <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>2</mn><mn>0</mn><mn>0</mn><mo>×</mo><mn>2</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding=application/x-tex>200\times 200</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>2</span><span class=mord>0</span><span class=mord>0</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>×</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>2</span><span class=mord>0</span><span class=mord>0</span></span></span></span>, <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>4</mn><mn>0</mn><mn>0</mn><mo>×</mo><mn>4</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding=application/x-tex>400\times 400</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>4</span><span class=mord>0</span><span class=mord>0</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>×</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>4</span><span class=mord>0</span><span class=mord>0</span></span></span></span>, and <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>0</mn><mo>×</mo><mn>8</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding=application/x-tex>800\times 800</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>8</span><span class=mord>0</span><span class=mord>0</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>×</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>8</span><span class=mord>0</span><span class=mord>0</span></span></span></span>.<p>Each file should be named <code class="language-plaintext highlighter-rouge">Julia set (constant) size.png</code>. For example, using the default constant and default size, you would produce the file named <code class="language-plaintext highlighter-rouge">Julia set (-0.4 + 0.6i) 800x800.png</code>.<p>You should have 15 generated images in total. Add those images to your repository in an <code class="language-plaintext highlighter-rouge">images</code> directory.</section><section><h2 id=part-2-simple-pipeline-5-points>Part 2. Simple pipeline (5 points)</h2><p>For several subsequent parts of this lab, you’re going to need to run the scrips you write on a large code base. We’re going to use the source code for the Linux kernel. You’re going to write a one-line shell script that downloads and decompresses the source code.<h3 id=task-2>Task 2</h3><p>Write a one-line script that will uses <code class="language-plaintext highlighter-rouge">curl</code> to download the compressed Linux source code and pipes it to <code class="language-plaintext highlighter-rouge">tar</code> which extracts the source code into the current directory. The Linux source code is available at this URL.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>https://github.com/torvalds/linux/archive/refs/tags/v6.4.tar.gz
</code></pre></div></div><p>Your command should be structured as follow.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ curl ARGS | tar ARGS
</code></pre></div></div><p>After you run the command, you should have a new directory named <code class="language-plaintext highlighter-rouge">linux-6.4</code> which contains the source code to version 6.4 of Linux.<p>Write the pipeline command you come up with in your <code class="language-plaintext highlighter-rouge">README</code>. <strong>You do not need a separate file for this one-line command. Just put it in the <code class="language-plaintext highlighter-rouge">README</code>.</strong><p><strong>Hints:</strong><ol><li>If you run <code class="language-plaintext highlighter-rouge">curl https://github.com/torvalds/linux/archive/refs/tags/v6.4.tar.gz</code> with no other options, no output is printed. That’s because GitHub, like many websites will redirect the browser to different URLs. The way this works technically is to use a <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages>redirection HTTP status</a> with a <code class="language-plaintext highlighter-rouge">Location</code> header. Search the <code class="language-plaintext highlighter-rouge">curl</code> man page to figure out which option to use to get <code class="language-plaintext highlighter-rouge">curl</code> to follow the redirection specified in the <code class="language-plaintext highlighter-rouge">Location</code> header.<li>The <code class="language-plaintext highlighter-rouge">tar</code> command, like many (but sadly not all) command-line utilities that operates on files, will accept a single <code class="language-plaintext highlighter-rouge">-</code> as the name of the file to mean read from <code class="language-plaintext highlighter-rouge">stdin</code> rather than reading from the file (and for output, write to <code class="language-plaintext highlighter-rouge">stdout</code> rather than writing to a file). (Some commands, like <code class="language-plaintext highlighter-rouge">cat</code> read from <code class="language-plaintext highlighter-rouge">stdin</code> if no files are given, <code class="language-plaintext highlighter-rouge">tar</code> isn’t one of those.)</ol></section><section><h2 id=part-3-shell-script-hygiene-25-points>Part 3. Shell script hygiene (25 points)</h2><p>Shell scripting is a powerful tool that is used in many areas of software development, including build scripts (that build the software), test scripts (that test the software), and conformance checking scripts (that check things like formatting conventions). An example of a conformance checking script might be one that is run on every <code class="language-plaintext highlighter-rouge">git commit</code> to check that the files being changed have no errors or warnings according to some tool.<p>You’re going to write a conformance checking script that checks if all of the shell scripts in a directory pass <code class="language-plaintext highlighter-rouge">shellcheck</code>.<p>To find all of the shell scripts in a directory, you will use the <code class="language-plaintext highlighter-rouge">find</code> command. Conceptually, we want to loop over all of the files that have a particular extension and do something with them. For example, if we want to print the paths of every text file in a directory whose path is stored in the <code class="language-plaintext highlighter-rouge">dir</code> variable, we’d like to be able to do something like this:<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>for </span>file <span class=k>in</span> <span class=si>$(</span>find <span class=s2>"</span><span class=k>${</span><span class=nv>dir</span><span class=k>}</span><span class=s2>"</span> <span class=nt>-name</span> <span class=s1>'*.txt'</span><span class=si>)</span><span class=p>;</span> <span class=k>do
  </span><span class=nb>echo</span> <span class=s2>"</span><span class=k>${</span><span class=nv>file</span><span class=k>}</span><span class=s2>"</span>
<span class=k>done</span>
</code></pre></div></div><p><strong>Unfortunately, this doesn’t work!</strong> If we run <a href=https://shellcheck.net>shellcheck</a> on this we get a warning<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>for file in $(find "${dir}" -name '*.txt'); do
            ^-- SC2044 (warning): For loops over find output are fragile. Use find -exec or a while read loop.
</code></pre></div></div><p>The problem here is that file names can contain spaces (and even newline characters!) The shellcheck wiki page for error <a href=https://www.shellcheck.net/wiki/SC2044>SC2044</a> gives example code to make this work. It would look something like<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>while </span><span class=nv>IFS</span><span class=o>=</span> <span class=nb>read</span> <span class=nt>-r</span> <span class=nt>-d</span> <span class=s1>''</span> file<span class=p>;</span> <span class=k>do 
  </span><span class=nb>echo</span> <span class=s2>"</span><span class=k>${</span><span class=nv>file</span><span class=k>}</span><span class=s2>"</span>
<span class=k>done</span> &lt; &lt;<span class=o>(</span>find <span class=s2>"</span><span class=k>${</span><span class=nv>dir</span><span class=k>}</span><span class=s2>"</span> <span class=nt>-name</span> <span class=s1>'*.txt'</span> <span class=nt>-print0</span><span class=o>)</span>
</code></pre></div></div><p>Note carefully the space after the <code class="language-plaintext highlighter-rouge">=</code> and the space between the two <code class="language-plaintext highlighter-rouge">&lt;</code> characters!<p>What this arcane construction is doing is it’s first running<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>find "${dir}" -name '*.txt' -print0
</code></pre></div></div><p>which is the same as the previous <code class="language-plaintext highlighter-rouge">find</code> command except that rather than printing the matching paths separated by a newline (which, as mentioned, is a valid character in a file name), it separates the output with a <code class="language-plaintext highlighter-rouge">0</code> byte. (Not the character <code class="language-plaintext highlighter-rouge">0</code> which is a byte with integer value 48, but the byte with value 0.)<p>The output of the <code class="language-plaintext highlighter-rouge">find</code> command becomes the standard input for the<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>while IFS= read -r -d '' file; do ... done
</code></pre></div></div><p>loop. The loop is going to read from <code class="language-plaintext highlighter-rouge">stdin</code> (from the <code class="language-plaintext highlighter-rouge">read</code> command) and split up the input by 0 bytes (which, conveniently, is what the <code class="language-plaintext highlighter-rouge">-print0</code> argument to <code class="language-plaintext highlighter-rouge">find</code> produced).<p>Each time through the body of the loop, the <code class="language-plaintext highlighter-rouge">file</code> variable will be set the path of one of the files that <code class="language-plaintext highlighter-rouge">find</code> found.<h3 id=task-3>Task 3</h3><p>Write a shell script called <code class="language-plaintext highlighter-rouge">shellcheckall</code> which takes zero or one parameters. The parameter, if given, should be a path to a directory. If no parameters are given, it should act on the current directory. If two or more parameters are given, output usage information to <code class="language-plaintext highlighter-rouge">stderr</code>, and exit with return value 1. If the supplied parameter is not a directory, output an error message (on <code class="language-plaintext highlighter-rouge">stderr</code>) and exit with return value 1.<p>The script should search the given directory (and any directories inside of it) to find all of the files with the extension <code class="language-plaintext highlighter-rouge">.sh</code>. It should run <code class="language-plaintext highlighter-rouge">shellcheck</code> on each file and count how many scripts pass out of the total number of shell scripts. See the examples below.<p>Make sure you handle files with spaces in the name. Make sure the script works correctly when run on an empty directory and one that contains no shell scripts (see the examples below).<p>How many shell scripts in the entire <code class="language-plaintext highlighter-rouge">linux-6.4</code> pass <code class="language-plaintext highlighter-rouge">spellcheck</code>? Write your answer in your <code class="language-plaintext highlighter-rouge">README</code>.<p>Write a for-loop that runs <code class="language-plaintext highlighter-rouge">shellcheckall</code> on each directory in <code class="language-plaintext highlighter-rouge">linux-6.4</code>. It should print out the name of the directory, a colon, a space, and then the output from <code class="language-plaintext highlighter-rouge">shellcheckall</code>. Your loop should probably start like this.<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>for </span><span class=nb>dir </span><span class=k>in </span>linux-6.4/<span class=k>*</span>/<span class=p>;</span> <span class=k>do</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">/</code> after the <code class="language-plaintext highlighter-rouge">*</code> means the glob will only match directories. You’ll want to use <code class="language-plaintext highlighter-rouge">echo -n</code> to print text without a trailing newline. See the final example below.<p>Put your for-loop and the output in your <code class="language-plaintext highlighter-rouge">README</code>.<p><strong>Examples.</strong><div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ ./shellcheckall too many args
Usage: ./shellcheckall [dir]
$ echo $?
1

$ ./shellcheckall linux-6.4/tools/perf
6 of 74 shell scripts passed shellcheck
$ echo $?
1

$ ./shellcheckall empty-directory
0 of 0 shell scripts passed shellcheck
$ echo $?
0
</code></pre></div></div><p>For the for loop,<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ for dir in linux-6.4/*/; do ...; done
linux-6.4/Documentation/: 1 of 9 shell scripts passed shellcheck
linux-6.4/LICENSES/: 0 of 0 shell scripts passed shellcheck
linux-6.4/arch/: 15 of 39 shell scripts passed shellcheck
...
</code></pre></div></div></section><section><h2 id=part-4-top-file-types-20-points>Part 4. Top file types (20 points)</h2><p>In this part, you’re going to write a complex pipeline to answer a simple question: What are the top 8 file types in the Linux 6.4 source code. We’re going to use a file’s extension to determine what type of file it is. We’re going to ignore any files that don’t have extensions.<h3 id=task-4>Task 4</h3><p>Write a script <code class="language-plaintext highlighter-rouge">topfiletypes</code> to answer this question. Your script should consist of a single complex pipeline. Put the output of your script in your <code class="language-plaintext highlighter-rouge">README</code>.<p>The structure of the pipeline will look like this<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>while </span><span class=nv>IFS</span><span class=o>=</span> <span class=nb>read</span> <span class=nt>-r</span> file<span class=p>;</span> <span class=k>do</span> ...<span class=p>;</span> <span class=k>done</span> &lt;<span class=o>(</span>find linux-6.4 <span class=nt>-name</span> <span class=s1>'*.*'</span><span class=o>)</span> | ... | ... | ... | ...
</code></pre></div></div><p>Notice how the output from the <code class="language-plaintext highlighter-rouge">while</code> loop is passed as standard input to the next command in the pipeline.<p>Your output should look like this.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ ./topfiletypes
  32459 c
  23737 h
   3488 yaml
...
</code></pre></div></div><p><strong>Hints:</strong><ol><li>The <code class="language-plaintext highlighter-rouge">while</code> loop given here is slightly different from the one you used before (no <code class="language-plaintext highlighter-rouge">-d ''</code> or <code class="language-plaintext highlighter-rouge">-print0</code> options). Most filenames don’t actually have newlines in them so we can use this technique to read one line at a time from the output of the <code class="language-plaintext highlighter-rouge">find</code> command rather than reading up to a 0 byte.<li>Bash supports a lot of convenient <a href=https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html>variable expansions</a>. You want to read the section of that page that describes <code class="language-plaintext highlighter-rouge">${parameter##word}</code>. Here are some examples: <div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ x=foo.bar.baz
$ echo "${x##*.}"
baz

$ y=linux-6.4/mm/mempool.c
$ echo "${y##*.}"
c
</code></pre></div></div><p>You can use this inside your <code class="language-plaintext highlighter-rouge">while</code> loop to print the extension of the file.<li>The <code class="language-plaintext highlighter-rouge">sort</code> command can be used to sort lines of input. For example, given the file <code class="language-plaintext highlighter-rouge">example</code><div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>foo
bar
foo
foo
cat
cat
foo
</code></pre></div></div><p>if we run <code class="language-plaintext highlighter-rouge">sort</code> on <code class="language-plaintext highlighter-rouge">example</code>, we get<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>bar
cat
cat
foo
foo
foo
foo
</code></pre></div></div><li>The <code class="language-plaintext highlighter-rouge">uniq</code> command can be used to compress identical, consecutive lines of input into a single line of output. <code class="language-plaintext highlighter-rouge">sort</code> and <code class="language-plaintext highlighter-rouge">uniq</code> are frequently used together as <code class="language-plaintext highlighter-rouge">sort | uniq</code> to read lines of input, sort them, and then only output the unique lines. Running <code class="language-plaintext highlighter-rouge">uniq</code> on <code class="language-plaintext highlighter-rouge">example</code> produces <div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>foo
bar
foo
cat
foo
</code></pre></div></div><p>Running <code class="language-plaintext highlighter-rouge">sort example | uniq</code> gives<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>bar
cat
foo
</code></pre></div></div><li><code class="language-plaintext highlighter-rouge">The </code>uniq<code class="language-plaintext highlighter-rouge"> command can take an argument to print out the __count__ of each line. Here's </code>sort example | uniq -c`. <div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>      1 bar
      2 cat
      4 foo
</code></pre></div></div><li><code class="language-plaintext highlighter-rouge">sort</code> can sort in <em>reverse</em> as well as performing a <em>numeric</em> sort (i.e., sort numbers in the usual way so that 9 comes before 10).<li>The <code class="language-plaintext highlighter-rouge">head</code> command can be used to print the first several lines of a file. Look up the options to print the first 8 rather than the default 10.<li>In the loop, print out the extension of the path in the <code class="language-plaintext highlighter-rouge">file</code> variable. Use a combination of <code class="language-plaintext highlighter-rouge">sort</code>, <code class="language-plaintext highlighter-rouge">uniq</code>, and <code class="language-plaintext highlighter-rouge">head</code> in the pipeline to produce the final result. You’ll want to use <code class="language-plaintext highlighter-rouge">sort</code> multiple times.<li>You can write this all as a single line. Don’t do that. Use <code class="language-plaintext highlighter-rouge">\\</code> at the end of each command to continue on the next line. <div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>while </span><span class=nv>IFS</span><span class=o>=</span> <span class=nb>read</span> <span class=nt>-r</span> file<span class=p>;</span> <span class=k>do
  </span><span class=nb>echo</span> ...
<span class=k>done</span> &lt; &lt;<span class=o>(</span>find linux-6.4 <span class=nt>-name</span> <span class=s1>'*.*'</span><span class=o>)</span> <span class=se>\</span>
  | ... <span class=se>\</span>
  | ... <span class=se>\</span>
  | ... |
  | ...
</code></pre></div></div></ol></section></main>