I"öD<h1 id="homework-6-huffman-compression">Homework 6: Huffman compression</h1>
<p><strong>Due: TDB at TBD</strong></p>

<h2 id="preliminaries">Preliminaries</h2>
<p>First, find a partner. Youâ€™re allowed to work by yourself, but I highly
recommend working with a partner. Click on the <a href="">assignment
link</a>. One partner should create a
new team. The second partner should click the link and choose the appropriate
team. (Please donâ€™t choose the wrong team, thereâ€™s a maximum of two people and
if you join the wrong one, youâ€™ll prevent the correct person from joining.)</p>

<p>Once you have accepted the assignment and created/joined a team, you can clone
the repository on clyde and begin working. But before you do, read the entire
assignment.</p>

<p>Be sure to ask any questions on
<a href="">Piazza</a>.</p>

<h3 id="submission">Submission</h3>
<p>To submit your homework, you must commit and push to GitHub before the
deadline.</p>

<p>The <code class="highlighter-rouge">README.md</code> should contain</p>
<ul>
  <li>The names of both partners (or just your name if you worked aloneâ€¦but
please donâ€™t work alone if you can manage it).</li>
</ul>

<p>You should not include any compiled files (either object files, the library,
or the programs).</p>

<h2 id="part-0">Part 0</h2>
<p>Youâ€™re going to write a <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman
encoder/decoder</a> that can be
used for simple file compression/decompression. This homework is trickier than
the previous ones; however, it builds upon several of the previous ones.</p>

<p>The construction proceeds in parts. Itâ€™s not required that you complete them
in order; however, tests for later parts depend on earlier parts.</p>

<p>Take a look through the code. There are multiple directories. For ease of
exposition, I will refer to the repository directory as <code class="highlighter-rouge">repo</code>. The code is
structured as a library, <code class="highlighter-rouge">libhuffman</code>, and two programs <code class="highlighter-rouge">encode</code> and <code class="highlighter-rouge">decode</code>
which depend on the library.</p>

<p>The first directory to examine is <code class="highlighter-rouge">repo/libhuffman</code> which is where all of the
library code and tests reside. <code class="highlighter-rouge">repo/libhuffman/include</code> contains the header
<code class="highlighter-rouge">huffman.h</code> which is what the two applications will include. The remainder of
the library code is in source and header files in <code class="highlighter-rouge">repo/libhuffman</code> and unit
tests are in <code class="highlighter-rouge">repo/libhuffman/tests</code>.</p>

<p>Tests for <code class="highlighter-rouge">encode</code> and <code class="highlighter-rouge">decode</code> reside in <code class="highlighter-rouge">repo/tests</code>.</p>

<p>In this assignment, donâ€™t make any assumptions about how many bits comprise a
byte. Use <code class="highlighter-rouge">CHAR_BIT</code>.</p>

<h3 id="file-formats">File formats</h3>
<p>The input to the <code class="highlighter-rouge">encode</code> program is a file which youâ€™ll treat as a sequence
of <code class="highlighter-rouge">CHAR_BIT</code> bytes. The end result of encoding a file is a (hopefully)
compressed output file. Unlike the input, the compressed file is a stream of
bits (that are packed into bytes).</p>

<p>The compressed file starts with a canonical representation of the Huffman
<a href="https://en.wikipedia.org/wiki/Trie">trie</a>. To do this, you will do a
pre-order traversal of the trie using a 0-bit to indicate that it is an
internal node and therefore has left and right children, or a 1-bit to
indicate that it is a leaf node. Immediately following the 1-bit you will
write the <code class="highlighter-rouge">CHAR_BIT</code> bits from most to least significant that make up the
value of the character at that location in the tree.</p>

<p>Immediately following the pre-order traversal of the tree, you will write the
code word representing <code class="highlighter-rouge">EOF</code>. (You will later use that to find the leaf
that represents <code class="highlighter-rouge">EOF</code> and correct the value there.)</p>

<p>After the code word for <code class="highlighter-rouge">EOF</code>, you should output the code words that are
needed to represent the input file. Youâ€™ll have to buffer the bits until you
get <code class="highlighter-rouge">CHAR_BIT</code> of them and then output it. (The most significant bit is the
first bit, and then they progress downward.)</p>

<p>Finally, write the code word for <code class="highlighter-rouge">EOF</code> to mark the end of the file followed by
as many <code class="highlighter-rouge">0</code> bits as necessary to fill out the final byte.</p>

<h3 id="encoding">Encoding</h3>
<p>The process for encoding involves two passes over the data. The first pass
is for counting how often each character appears in the file and the second
is for performing the encoding and writing the output.</p>

<p>Youâ€™re going to build the trie by constructing a list of trees and iteratively
combining them until a single tree remains. To do this, youâ€™re going to use a
node that has a pointer to the next tree in the list and also two pointers for
the left and right children. See <code class="highlighter-rouge">repo/libhuffman/huffman_list.h</code>.</p>

<p>The steps are the following.</p>
<ol>
  <li>Read the whole data and count how often each character appears;</li>
  <li>Create a linked consisting of a single node with a <code class="highlighter-rouge">count</code> of 1 and a <code class="highlighter-rouge">ch</code>
of <code class="highlighter-rouge">EOF</code> (see <code class="highlighter-rouge">repo/libhuffman/huffman_list.h</code>);</li>
  <li>For each character with a nonzero count from the file, create a new node
with the corresponding <code class="highlighter-rouge">ch</code> and <code class="highlighter-rouge">count</code> and insert it into the list as you
would do with <a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion
sort</a>. Insert before nodes
with equal <code class="highlighter-rouge">count</code>s.</li>
  <li>While there are two or more nodes in the list, remove the first two nodes
from the list and create a new node with the two nodes as the left and
right children. Insert the node into the list, maintaining sorted order as
in step 3.</li>
</ol>

<p>Once there is only a single tree in the list, it is the Huffman trie.</p>

<p>The code word for each byte, and for <code class="highlighter-rouge">EOF</code>, can be recovered by walking from
the root to each leaf. Going left corresponds to a <code class="highlighter-rouge">0</code> bit and going right
corresponds to a <code class="highlighter-rouge">1</code> bit.</p>

<h3 id="sample-run">Sample run</h3>
<p><strong>Input:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cheese
</code></pre></div></div>

<p><strong>Frequency Counts:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-1     EOF     1
10     \n      1
99     c       1
101    e       3
104    h       1
115    s       1
</code></pre></div></div>

<p><strong>Linked List (initial):</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s(1) -&gt; h(1) -&gt; c(1) -&gt; \n(1) -&gt; EOF(1) -&gt; e(3)
</code></pre></div></div>

<p><strong>First pass:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c(1) -&gt; \n(1) -&gt; EOF(1) -&gt; (2) -&gt; e(3)
                          /   \
                      s(1)     h(1)    
</code></pre></div></div>

<p><strong>Second pass:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EOF(1) -&gt; (2)   --&gt;   (2) -&gt; e(3)
         /   \       /   \
      c(1)  \n(1)  s(1)   h(1)    
</code></pre></div></div>

<p><strong>Third pass:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   (2)  ------&gt;  (3)  ---&gt; e(3)
  /   \         /   \
s(1)   h(1) EOF(1)  (2)
                   /   \
                 c(1) \n(1)
</code></pre></div></div>

<p><strong>Fourth pass:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e(3) -----------&gt; (5)
               /       \
           (2)           (3)
          /   \         /   \
        s(1)   h(1) EOF(1)  (2)
                           /   \
                         c(1) \n(1)
</code></pre></div></div>

<p><strong>Fifth (and final) pass:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         (8)
    /           \
e(3)              (5)
               /       \
           (2)           (3)
          /   \         /   \
        s(1)   h(1) EOF(1)  (2)
                           /   \
                         c(1) \n(1)
</code></pre></div></div>

<p><strong>Code words:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char      code words
----      ----------
 -1  EOF  110
 10  \n   1111
 99  c    1110
101  e    0
104  h    101
115  s    100
</code></pre></div></div>

<p><strong>Trie representation (with added spaces for clarity):</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 01100101 0 0 1 01110011 1 01101000 0 1 11111111 0 1 01100011 1 00001010
</code></pre></div></div>

<p><strong>EOF:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>110
</code></pre></div></div>

<p><strong>Remainder of file (spaces added, includes <code class="highlighter-rouge">EOF</code>):</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1110 101 0 0 100 0 1111 110
</code></pre></div></div>

<p><strong>Remainder is padding to make it a full char:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000000
</code></pre></div></div>

<p>You can also use some Unix tools to examine your output files:</p>

<p><strong>File passed through <code class="highlighter-rouge">xxd</code>:</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000: 594b 9da1 ff58 e15b a91f 80              YK...X.[...
</code></pre></div></div>

<p><strong>File passed through <code class="highlighter-rouge">xxd -b</code> (bits):</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000: 01011001 01001011 10011101 10100001 11111111 01011000  YK...X
0000006: 11100001 01011011 10101001 00011111 10000000           .[...
</code></pre></div></div>

<h3 id="decoding">Decoding</h3>
<p>To decode the file,  read in the pre-order traversal of the tree, assembling it
as you go. A <code class="highlighter-rouge">0</code> bit indicates an internal node which has both a left and right
child. A <code class="highlighter-rouge">1</code> bit indicates it is a leaf and the next <code class="highlighter-rouge">CHAR_BIT</code> bits represent the
value at that node from MSB to LSB. (I found a recursive function to work
nicely for this.)</p>

<p>Now you need to fix the value of <code class="highlighter-rouge">EOF</code> in the tree. Switch over to a bitwise
read/tree traversal routing where <code class="highlighter-rouge">0</code> indicates to go left and <code class="highlighter-rouge">1</code> indicates to go
right. Once you hit the first leaf, you now have the location for the actual
<code class="highlighter-rouge">EOF</code> marker and you should update the value there accordingly.</p>

<p>Now you continue with a bitwise read/tree traversal routine and use those to
determine if you should go left on <code class="highlighter-rouge">0</code> or right on <code class="highlighter-rouge">1</code> in the tree. Once you
reach a leaf, you should be at a letter. Output it and move back to the root.
When you reach the <code class="highlighter-rouge">EOF</code> code word you should stop reading/printing. Nothing is
printed for the <code class="highlighter-rouge">EOF</code> code word.</p>

<h2 id="part-1-counting">Part 1. Counting</h2>

<p>This is the easiest part. Look in <code class="highlighter-rouge">repo/libhuffman/counts.[hc]</code>. Implement the
function by reading characters and updating the counts in the passed in array.
This is similar to <a href="hw2.html">homework 2</a>. Make sure
<code class="highlighter-rouge">repo/libhuffman/tests/test_counts</code> succeeds before moving on.</p>

<h2 id="part-2-bit-stream">Part 2. Bit stream</h2>

<p>Look in <code class="highlighter-rouge">repo/libhuffman/bit_stream.[hc]</code>. Implement the functions in these
files to read and write bits to the underlying <code class="highlighter-rouge">FILE *</code> stream.</p>

<p>When writing bits, buffer the bits until <code class="highlighter-rouge">CHAR_BIT</code> bits have been added at
which point a byte should be written to the underlying stream.</p>

<p>When reading bits, read bits one byte at a time from the underlying stream and
buffer them.</p>

<p>You should implement <code class="highlighter-rouge">bit_stream_put()</code> and <code class="highlighter-rouge">bit_stream_get()</code> first and write
the rest of the functions in terms of those.</p>

<p>Make sure you correctly handle <code class="highlighter-rouge">EOF</code> being returned from
<code class="highlighter-rouge">fputc(3)</code>/<code class="highlighter-rouge">fgetc(3)</code> as well as returning the appropriate values from the
functions.</p>

<p>Make sure <code class="highlighter-rouge">repo/libhuffman/tests/test_bit_stream</code> passes before moving on.</p>

<h2 id="part-3-huffman-list">Part 3. Huffman list</h2>
<p>Implement the basic functions for creating and freeing <code class="highlighter-rouge">huffman_node</code>s. In
addition, implement the insertion function which inserts a node into a linked
list in sorted order.</p>

<p>Make sure <code class="highlighter-rouge">repo/libhuffman/tests/test_list</code> passes before moving on.</p>

<h2 id="part-4-encoding">Part 4. Encoding</h2>
<p>You will need parts 1â€“3 working before this so make sure you implement those
first.</p>

<p>Read the descriptions of the functions in <code class="highlighter-rouge">repo/libhuffman/huffman_encode.h</code>
and <code class="highlighter-rouge">repo/libhuffman/include/huffman.h</code> carefully and implement the functions
in <code class="highlighter-rouge">repo/libhuffman/huffman_encode.c</code>. Make sure that if any of the functions
fails, any allocated memory is correctly freed.</p>

<p>When implementing <code class="highlighter-rouge">huffman_codewords</code>, youâ€™re probably going to want to
perform a recursive tree-traversal, passing the <code class="highlighter-rouge">codewords</code> and <code class="highlighter-rouge">lengths</code>
arrays as well as building up a code word (and its length). At each leaf, the
tree-traversal should set the appropriate entry in <code class="highlighter-rouge">codewords</code> and <code class="highlighter-rouge">lengths</code>.</p>

<p>Make sure <code class="highlighter-rouge">repo/libhuffman/tests/test_encode</code> passes.</p>

<h2 id="part-5-decoding">Part 5. Decoding</h2>
<p>You will need parts 2 and 3 working before this so make sure you implement
those first.</p>

<p>Read the descriptions of the functions in <code class="highlighter-rouge">repo/libhuffman/huffman_decode.h</code>
and <code class="highlighter-rouge">repo/libhuffman/include/huffman.h</code> carefully and implement the functions
in <code class="highlighter-rouge">repo/libhuffman/huffman_decode.c</code>. Make sure that if any of the functions
fails, any allocated memory is correctly freed.</p>

<p>Make sure <code class="highlighter-rouge">repo/libhuffman/tests/test_decode</code> passes.</p>

<p>You can run all of the library tests by running</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ make check
</code></pre></div></div>
<p>from the <code class="highlighter-rouge">repo/libhuffman</code> directory.</p>

<h2 id="part-6-programs">Part 6. Programs</h2>
<p>Youâ€™ll need to have parts 4 and 5 finished before you can test these.</p>

<p>Implement <code class="highlighter-rouge">repo/encode</code> and <code class="highlighter-rouge">repo/decode</code>. They should each take two
arguments.</p>

<p>The <code class="highlighter-rouge">Makefile</code> has <code class="highlighter-rouge">-Ilibhuffman/include</code> in the <code class="highlighter-rouge">CFLAGS</code> so make sure youâ€™re
including <code class="highlighter-rouge">huffman.h</code> appropriately. (If you donâ€™t recall what <code class="highlighter-rouge">-I</code> means,
check out the <code class="highlighter-rouge">gcc(1)</code> man page.)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./encode
Usage: ./encode input output
$ ./decode
Usage: ./decode input output
</code></pre></div></div>

<p>Make sure they exit with zero on success and nonzero on error. You should
print out an error message on <code class="highlighter-rouge">stderr</code> if there is an error such as not being
able to open a file or when you canâ€™t decompress.</p>

<p>Make sure all of the tests pass by running</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ make check
</code></pre></div></div>
<p>from the <code class="highlighter-rouge">repo</code> directory.</p>
:ET