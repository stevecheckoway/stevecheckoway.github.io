I"Å<h1 id="lecture-4--feb-10th-2020">Lecture 4 ‚Äì Feb 10th, 2020</h1>

<p>This exercise is designed to give you hands-on experience with Bash‚Äôs
expansion.</p>

<h2 id="setup">Setup</h2>
<ol>
  <li>Log on to clyde: <code class="highlighter-rouge">ssh user@clyde.cs.oberlin.edu</code>.</li>
  <li>Create a directory with whatever name you like and <code class="highlighter-rouge">cd</code> into it.</li>
  <li>Run <code class="highlighter-rouge">$ cp ~steve/ex/args .</code> (note the trailing dot!) to copy the <code class="highlighter-rouge">args</code>
program to your directory.</li>
</ol>

<h2 id="task">Task</h2>
<ol>
  <li>
    <p>Either run <code class="highlighter-rouge">$ cat args</code> to print the contents of <code class="highlighter-rouge">args</code> or open <code class="highlighter-rouge">args</code> in
an editor (e.g., <code class="highlighter-rouge">$ nvim args</code> or <code class="highlighter-rouge">$ emacs args</code>). <code class="highlighter-rouge">args</code> is a Bash script
that will print out the command line arguments that you pass it.</p>

    <p>The <code class="highlighter-rouge">#</code> character starts a comment, just like Python. Later in this course,
we‚Äôll learn what all of this is, but for now, you can probably see the
structure of the program. There‚Äôs a <code class="highlighter-rouge">num</code> variable that is incremented each
time through the <code class="highlighter-rouge">for</code> loop. The <code class="highlighter-rouge">echo</code> line produces the output and you
can see <code class="highlighter-rouge">${num}</code> and <code class="highlighter-rouge">${arg}</code> which will expand to the command line
argument number (it‚Äôs position in the list) and the command line argument
itself.</p>

    <p>The most mysterious part is the <code class="highlighter-rouge">"$@"</code> which tells the <code class="highlighter-rouge">for</code> loop to loop
over the command line arguments, setting <code class="highlighter-rouge">arg</code> to each one in turn.</p>
  </li>
  <li>Splitting input into words. Run the <code class="highlighter-rouge">args</code> program several times with
different command line arguments such as
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args
$ ./args aa bb    cc
$ ./args -a --version foo bar
</code></pre></div>    </div>
    <p>Try adding more or less space characters between each argument. Does it
have any impact on what arguments the <code class="highlighter-rouge">args</code> script receives?</p>
  </li>
  <li>Try to construct a command line argument that contains spaces. (Hint: the
<code class="highlighter-rouge">args</code> program itself shows how to do that.) Test that you‚Äôre correct by
running <code class="highlighter-rouge">args</code> with the appropriate command line argument.</li>
  <li>There are 3 different ways we can get spaces in the command line arguments:
single quotes, double quotes, and a backslash before each space. Run the
following and compare the output.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args '  foo  bar  ' "aaa bbb" this\ is\ one\ arg
</code></pre></div>    </div>
    <p>There should be exactly three command line arguments printed out.</p>
  </li>
  <li>Now try putting backslashes inside single or double quotes.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args 'foo\\bar' "foo\\bar" "foo\bar" foo\\bar foo\bar
</code></pre></div>    </div>
    <p>If you look carefully at that, you‚Äôll see that inside single quotes a
backslash is treated literally (indeed <em>everything</em> inside single quotes is
treated literally). Inside double quotes (or outside quotes), the backslash
acts as an escape so <code class="highlighter-rouge">"\\"</code> produces just a single slash. Since <code class="highlighter-rouge">\b</code>
doesn‚Äôt mean anything to Bash, the backslash doesn‚Äôt act as an escape.</p>

    <p>As a final step of input processing, Bash removes unquoted (and unescaped)
quotation marks and backslashes. This explains why we don‚Äôt see any
quotation marks in the arguments and why the backslash disappeared from
<code class="highlighter-rouge">foo\bar</code>.</p>
  </li>
  <li>Brace expansion. Try the following examples.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args {foo,bar,baz}.mp3
$ ./args before{X,Y,,Z}after # the ,, isn't a typo
$ ./args {a,b{c,d},e}{f,g}
</code></pre></div>    </div>
    <p>Notice how Bash (recursively) expands each comma-separated string inside
the braces into its own argument, prepending the stuff before it and
appending the stuff after it.</p>
  </li>
  <li>
    <p>Try adding quotes (single and double) outside some of the braces. Try
inside some of the braces. Try adding a space to one of the comma-separated
items</p>

    <p>These are instructive.</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args before{X,Y, ,Z}after
$ ./args before{X,Y,' ',Z}after
</code></pre></div>    </div>
  </li>
  <li>
    <p>Tilde expansion. <code class="highlighter-rouge">~</code> expands to your home directory, <code class="highlighter-rouge">~foo</code> expands to user
<code class="highlighter-rouge">foo</code>‚Äôs home directory. Try it out using <code class="highlighter-rouge">~steve</code> to get my home directory.
(Notice how we used this in the setup to copy <code class="highlighter-rouge">args</code> from my home
directory.)</p>

    <p>Try adding quotes or a backslash in front of the <code class="highlighter-rouge">~</code>. Try putting the <code class="highlighter-rouge">~</code>
in the middle of the word like <code class="highlighter-rouge">foo~bar</code>. What happens?</p>
  </li>
  <li>Parameter (variable) expansion. This is the most useful one of all! Define
a new Bash variable <code class="highlighter-rouge">class</code> by entering the following.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ class='CS 241'
</code></pre></div>    </div>
    <p>Note carefully that the <code class="highlighter-rouge">=</code> must not have spaces on either side of it.</p>

    <p>First, let‚Äôs echo (i.e., print out) the value of the <code class="highlighter-rouge">class</code> variable.</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo ${class}
</code></pre></div>    </div>
    <p>That should print out <code class="highlighter-rouge">CS 241</code>.</p>
  </li>
  <li>Now try passing the <code class="highlighter-rouge">class</code> variable to the <code class="highlighter-rouge">args</code> program.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args ${class}
$ ./args '${class}'
$ ./args "${class}"
</code></pre></div>    </div>

    <p>Note carefully the difference between these: <code class="highlighter-rouge">"${class}"</code> expanded to a
single argument whereas <code class="highlighter-rouge">${class}</code> expanded to multiple arguments. What
happens is after doing parameter expansion (and several other expansions),
Bash splits the result into multiple words by splitting (by default) at
whitespace.</p>

    <p><strong>You will never want this behavior.</strong> You can avoid it by putting double
quotes around any use of variables.</p>
  </li>
  <li>Read the slides discussing Bash expansion, in particular command
substitution and quote removal. Play around with some of the examples on
the slides. For example, compare
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./args $(echo hi there)
$ ./args "$(echo hi there)"
</code></pre></div>    </div>
  </li>
</ol>
:ET