I"KU<h1 id="homework-4-maze-generation">Homework 4: Maze Generation</h1>
<p><strong>Due: TDB at 23:59</strong></p>

<h2 id="preliminaries">Preliminaries</h2>
<p>First, find a partner. You’re allowed to work by yourself, but I highly
recommend working with a partner. Click on the <a href="">assignment
link</a>. One partner should create a
new team. The second partner should click the link and choose the appropriate
team. (Please don’t choose the wrong team, there’s a maximum of two people and
if you join the wrong one, you’ll prevent the correct person from joining.)</p>

<p>Once you have accepted the assignment and created/joined a team, you can clone
the repository on clyde and begin working. But before you do, read the entire
assignment and be sure to check out the expected <a href="#coding-style">coding style</a>.</p>

<p>Be sure to ask any questions on
<a href="">Piazza</a>.</p>

<h3 id="coding-style">Coding style</h3>
<p>See <a href="hw2.html#coding-style">homework 2’s coding style</a>.</p>

<p>You should run <code class="highlighter-rouge">clang-format</code> on each of the C source and header files you
write. This will format all of your files consistently.</p>

<h3 id="code-warnings-and-errors">Code warnings and errors</h3>
<p>Your code must compile without error or warning when compiled with <code class="highlighter-rouge">-std=c11
-Wall</code>.</p>

<h3 id="submission">Submission</h3>
<p>To submit your homework, you must commit and push to GitHub before the
deadline.</p>

<p>Your repository should not contain any programs, object files, or dependency
files (the dependency files are the ones ending in <code class="highlighter-rouge">.Td</code> or <code class="highlighter-rouge">.d</code>.</p>

<p>The <code class="highlighter-rouge">README.md</code> should contain</p>
<ul>
  <li>An image link showing the Travis CI build status (see part 0)</li>
  <li>The names of both partners (or just your name if you worked alone…but
please don’t work alone if you can manage it).</li>
  <li>An estimate of the amount of time it took to complete each part.</li>
  <li>Any known bugs or incomplete functions.</li>
  <li>Any interesting design decisions you’d like to share.</li>
</ul>

<p>Each of your source files with a <code class="highlighter-rouge">main</code> function should contain a comment at the top of the file
that contains usage information plus a description of what the program does.</p>

<h2 id="part-0-makefile-testing-and-travis-ci">Part 0. Makefile, testing, and Travis CI</h2>
<h3 id="makefile">Makefile</h3>
<p>Unlike previous assignments, this one comes with a full-featured <code class="highlighter-rouge">Makefile</code>.
If you add additional source files, you should add them to the appropriate
<code class="highlighter-rouge">_srcs</code> variable. Dependencies should be computed automatically.</p>

<p>The <code class="highlighter-rouge">all</code> target should depend on all of the programs you write.</p>

<p>The <code class="highlighter-rouge">clean</code> target should delete all of the programs you write and all of the
object files.</p>

<h3 id="testing">Testing</h3>
<p>The assignment code also comes with a set of unit tests in the <code class="highlighter-rouge">tests</code>
directory. You can run them by running <code class="highlighter-rouge">$ make check</code>.</p>

<p>There are several tests in the <code class="highlighter-rouge">tests</code> directory. These consist of the ones I
found useful for writing my solutions. You may choose to add to them when
testing your own code, although you aren’t required to in this assigment.</p>

<p>As you work through the parts below, run <code class="highlighter-rouge">$ make check</code> frequently to make
sure that you haven’t broken any code you previously had working.</p>

<h3 id="travis-ci">Travis CI</h3>
<p>This homework also uses the <a href="https://travis-ci.com/">Travis CI</a> continuous
integration service. Each time you push your code to GitHub, Travis will
download the latest version, build your program and then run the tests.</p>

<p>You should be able to see the status of your latest commit by logging in to
<a href="https://travis-ci.com">Travis CI</a> using your GitHub account. You can also see
the latest status from Travis by clicking on the <code class="highlighter-rouge">1 branch</code> link near the top
of the GitHub page for your repository which has URL
<code class="highlighter-rouge">https://github.com/systems-programming/${repo_name}/branches</code>. You should see
either a green check mark if all tests passed or a red X if one or more tests
failed.</p>

<p>You should add a build status image to your <code class="highlighter-rouge">README.md</code> by following the
<a href="https://docs.travis-ci.com/user/status-images/">instructions</a> to get the
Markdown code to paste into <code class="highlighter-rouge">README.md</code>.</p>

<h3 id="overview">Overview</h3>
<p>In CS 151, you probably had to implement a maze solving function using stacks
or queues. In this assignment, you’re going to generate rectangular mazes.</p>

<p>A $m\times n$ maze contains $m$ rows of $n$ columns of rooms. Each room has
0–4 walls: up, down, left, and right. The rooms on the edges of the maze must
contain walls along the edge. For example, the room at $(0,0)$ (the top-left
corner of the maze) <em>must</em> have the top and left walls. Adjacent rooms must
have consistent walls. For example, if the room at $(1,3)$ has walls to the
right and down, then the room at $(2,3)$ must have an up wall and the room at
$(1,4)$ must have a left wall.</p>

<p>Inside <code class="highlighter-rouge">maze.h</code>, there is an <code class="highlighter-rouge">enum</code> that defines four values that can be ORed
together to specify the possible walls. E.g., <code class="highlighter-rouge">WALL_UP | WALL_RIGHT</code>.</p>

<p>Since we’re going to be building the maze, one room at a time, there is an
additional value <code class="highlighter-rouge">WALL_NOT_SET</code> that represents the fact that the walls have
not been set for the room yet.</p>

<p>The first structure you’re going to work with is <code class="highlighter-rouge">RoomCoords</code> defined in
<code class="highlighter-rouge">roomcoords.h</code>. To ease the construction of these, there’s a <code class="highlighter-rouge">ROOM(row, col)</code>
macro. I found this macro incredibly helpful when writing my solution. There’s
a special <code class="highlighter-rouge">RoomCoords</code> value <code class="highlighter-rouge">UNDEFINED_ROOM_COORDS</code> that is used in several
places.</p>

<p>The other main structure is the <code class="highlighter-rouge">Maze</code> structure. <code class="highlighter-rouge">maze.h</code> declares this as an
opaque structure. That is, it doesn’t actually define the structure. You will
have to define the structure yourself in <code class="highlighter-rouge">maze.c</code>. The idea behind an opaque
structure is that all of the code will work with a <code class="highlighter-rouge">Maze</code> using the functions
defined in <code class="highlighter-rouge">maze.h</code> rather than interact with the <code class="highlighter-rouge">Maze</code> members directly. The
only code that should interact with the <code class="highlighter-rouge">Maze</code> members is in <code class="highlighter-rouge">maze.c</code>.</p>

<p>As you’re implementing the code, you should not change the function signatures
(the names, parameter numbers and types, and return types) for any function
declared in a header file. Doing so will break the game code.</p>

<h2 id="part-1-basic-maze-manipulation-functions-10-points">Part 1. Basic maze manipulation functions (10 points)</h2>
<p>The first task is to define the <code class="highlighter-rouge">Maze</code> structure. Each maze will need to keep
track of</p>
<ol>
  <li>the number of rows,</li>
  <li>the number of columns,</li>
  <li>the starting room coordinates,</li>
  <li>the ending room coordinates, and</li>
  <li>the data representing the rooms themselves.</li>
</ol>

<p>Start by removing the dummy member from <code class="highlighter-rouge">Maze</code>, and add the appropriate
members. You’ll need to decide how you want to represent the 2D array of
rooms.</p>

<p>One possibility is keeping track of the walls for each room.
Thus, if room $(r,c)$ has left and right walls, you’ll want to store
<code class="highlighter-rouge">WALL_LEFT | WALL_RIGHT</code>. In this case, you’ll need to ensure that $(r,c-1)$
has a right wall, $(r,c+1)$ has a left wall, $(r-1,c)$ doesn’t have a down
wall, and $(r+1,c)$ doesn’t have an up wall.</p>

<p>A second possibility is to only keep track of the left and up walls for each
room. To determine if room $(r,c)$ has a right wall, you need to check
if room $(r,c+1)$ has a left wall (or it’s on the right edge of the maze) and
to determine if it has a down wall, you need to check if room $(r+1,c)$ has an
up wall (or it’s on the bottom edge of the map). In this way, it’s not
possible for the walls to become inconsistent but the logic becomes a little
more tricky.</p>

<p>In either case, a single <code class="highlighter-rouge">unsigned char</code> is sufficient for each room. This
includes keeping track of whether a particular room’s walls have been set.</p>

<p>You’re free to use another representation of your maze. (The nice thing about
having an opaque <code class="highlighter-rouge">Maze</code> type from the perspective of the rest of the code is
that your internal representation doesn’t matter.)</p>

<p>Look at the descriptions of the functions in <code class="highlighter-rouge">maze.h</code>, and implement these
functions.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Maze</span> <span class="o">*</span><span class="nf">maze_new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cols</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">maze_free</span><span class="p">(</span><span class="n">Maze</span> <span class="o">*</span><span class="n">maze</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">maze_get_rows</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">maze_get_cols</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">);</span>
<span class="n">bool</span> <span class="nf">maze_in_bounds</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">coords</span><span class="p">);</span>
<span class="n">RoomCoords</span> <span class="nf">maze_get_start</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">maze_set_start</span><span class="p">(</span><span class="n">Maze</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">coords</span><span class="p">);</span>
<span class="n">RoomCoords</span> <span class="nf">maze_get_end</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">maze_set_end</span><span class="p">(</span><span class="n">Maze</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">coords</span><span class="p">);</span>
</code></pre></div></div>

<p>Make sure that when you create a new <code class="highlighter-rouge">Maze</code>, you set the members of the maze
such that the various maze getter functions return the correct values.</p>

<p>I recommend making liberal use of <code class="highlighter-rouge">assert(3)</code> to check for programmer errors.</p>

<p>Run <code class="highlighter-rouge">$ make check</code> to make sure that the checks related to those functions
pass (but you should expect most of the checks to fail).</p>

<h2 id="part-2-getting-and-setting-walls-30-points">Part 2. Getting and setting walls (30 points)</h2>
<p>This is probably the trickiest portion of this assignment.</p>

<p>Implement the functions to get and set the walls for a given room.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">maze_get_walls</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">coords</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">maze_set_walls</span><span class="p">(</span><span class="n">Maze</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">coords</span><span class="p">,</span> <span class="kt">int</span> <span class="n">walls</span><span class="p">);</span>
</code></pre></div></div>

<p>When setting walls, make sure your maze is consistent as described in <a href="#overview">Part
0</a>. Furthermore, make sure that setting the walls for one room does
not make an adjacent room whose walls haven’t been set lose that property.
(I.e., if <code class="highlighter-rouge">maze_get_walls(maze, ROOM(r, c))</code> returns <code class="highlighter-rouge">WALL_NOT_SET</code>, then
after setting an adjacent room’s wall’s, <code class="highlighter-rouge">maze_get_walls(maze, ROOM(r, c))</code>
should still return <code class="highlighter-rouge">WALL_NOT_SET</code>.</p>

<p>Walls for a room may be set multiple times but a room’s walls can never become
unset.</p>

<p>Check that all of the tests in <code class="highlighter-rouge">tests/test_maze.c</code> pass except for
<code class="highlighter-rouge">test_first_unset()</code>.</p>

<p>Finally, implement</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RoomCoords</span> <span class="nf">maze_get_first_unset</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">);</span>
</code></pre></div></div>
<p>by using the functions you’ve already implemented. (I.e., there is no real
need for this function to be in this file, but it doesn’t obviously belong
anywhere else.)</p>

<p>Now when you run <code class="highlighter-rouge">$ make check</code>, all of the tests in <code class="highlighter-rouge">test_maze</code> should pass.</p>

<h2 id="part-3-reading-and-writing-mazes-15-points">Part 3. Reading and writing mazes (15 points)</h2>
<p>In this part, you’ll implement the functions necessary to read a maze from a
<code class="highlighter-rouge">FILE *</code> and write a maze to a <code class="highlighter-rouge">FILE *</code>.</p>

<p>The structure of the maze file is described in <code class="highlighter-rouge">mazeio.h</code>. There is an example
in that file and there are more in the <code class="highlighter-rouge">mazes</code> directory.</p>

<p>Implement the following functions.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Maze</span> <span class="o">*</span><span class="nf">maze_new_from_stream</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">maze_write_to_stream</span><span class="p">(</span><span class="n">Maze</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div></div>

<p>When running <code class="highlighter-rouge">$ make check</code>, <code class="highlighter-rouge">tests/test_mazeio</code> should pass all tests.</p>

<p>At this point, you should be able to run <code class="highlighter-rouge">mazegame</code>. You can pass it the path
of a maze (e.g., one of the mazes in <code class="highlighter-rouge">mazes</code>) to play that maze. (It’s
possible this code is buggy, it’s much harder to test than the rest of the
assignment. If you happen to get it to crash, let me know!)</p>

<p>You can also have it solve a maze by giving it the <code class="highlighter-rouge">-s</code> option.</p>

<h2 id="part-4-random-walk-30-points">Part 4. Random walk (30 points)</h2>
<p>The procedure you’re going to use to generate a random maze sounds
complicated, but it’s actually pretty straight forward using <a href="https://en.wikipedia.org/wiki/Random_walk">random
walks</a>.</p>

<p>A random walk is a sequence of room coordinates such that each room is
adjacent to the room before it and the room after it in the sequence. For
example, each room in this sequence $(2,2)$, $(2,3)$, $(1,3)$, $(2,3)$,
$(3,3)$, $(3,4)$, $(2,4)$, $(2,3)$, $(1,3)$, $(1,2)$ is adjacent to the rooms
before and after it in the sequence. Notice that several rooms are repeated in
the sequence. That’s okay.</p>

<p>You’re going to create a random walk starting from a room whose walls have not
been set. Each step of the random walk will move to the room above, below,
left, or right of the current room, each with equal probability. Any step
that would take the walk out side of the bounds of the maze’s grid is simply
ignored and a new direction is chosen at random. The walk stops once it
encounters a room in the maze whose walls have been set. Thus, if the above
sequence of rooms were the outcome of a random walk, then room $(1,2)$ would
have the walls set but none of the others would. See <code class="highlighter-rouge">randomwalk.h</code> for the
specifics.</p>

<p>The next step is to erase the loops in the random walk. This gives you a
<a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk">loop-erased random
walk</a>. The procedure
for doing this is described in <code class="highlighter-rouge">randomwalk.h</code>.</p>

<p>Finally, you’re going to add the loop-erased random walk to the maze,
constructing a new corridor in the maze where the start is a dead end and the
end is where it connects with the rest of the maze. See <code class="highlighter-rouge">randomwalk.h</code> for
details and <code class="highlighter-rouge">tests/test_walk.c</code>’s <code class="highlighter-rouge">test_add_path()</code> function for an
illustration of adding four paths to a maze.</p>

<p>Implement the three random walk functions.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RoomCoords</span> <span class="o">*</span><span class="nf">random_walk</span><span class="p">(</span><span class="n">Maze</span> <span class="k">const</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">walk_size</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">erase_loops</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">walk</span><span class="p">[</span><span class="n">size</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">add_path_to_maze</span><span class="p">(</span><span class="n">Maze</span> <span class="o">*</span><span class="n">maze</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="k">const</span> <span class="n">walk</span><span class="p">[</span><span class="n">size</span><span class="p">]);</span>
</code></pre></div></div>

<p>At this point, all of the tests in <code class="highlighter-rouge">tests/test_walk</code> should pass.</p>

<h2 id="part-5-generating-a-maze-15-points">Part 5. Generating a maze (15 points)</h2>
<p>The final step of maze generation is to put everything together and actually
generate some mazes. The complete algorithm is described in <code class="highlighter-rouge">generate.c</code>, so
take a look and implement the function.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Maze</span> <span class="o">*</span><span class="nf">generate_maze</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cols</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">start</span><span class="p">,</span> <span class="n">RoomCoords</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>

<p>After this, <code class="highlighter-rouge">tests/test_generate</code> should pass.</p>

<p>At this point, <code class="highlighter-rouge">mazegen</code> should be usable to generate some mazes. Run
<code class="highlighter-rouge">$ mazegen -h</code> to see how to use it.</p>
:ET