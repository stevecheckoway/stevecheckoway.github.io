<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Homework 6: Huffman compression</title><meta name=description content="Homework 6: Huffman compression Due: TDB at TBD"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2020-spring/homeworks/hw6.html> <link rel=stylesheet href=/css/main.css><main><h1 id=homework-6-huffman-compression>Homework 6: Huffman compression</h1><p><strong>Due: TDB at TBD</strong><h2 id=preliminaries>Preliminaries</h2><p>First, find a partner. You’re allowed to work by yourself, but I highly recommend working with a partner. Click on the <a href>assignment link</a>. One partner should create a new team. The second partner should click the link and choose the appropriate team. (Please don’t choose the wrong team, there’s a maximum of two people and if you join the wrong one, you’ll prevent the correct person from joining.)<p>Once you have accepted the assignment and created/joined a team, you can clone the repository on clyde and begin working. But before you do, read the entire assignment.<p>Be sure to ask any questions on <a href>Piazza</a>.<h3 id=submission>Submission</h3><p>To submit your homework, you must commit and push to GitHub before the deadline.<p>The <code class=highlighter-rouge>README.md</code> should contain<ul><li>The names of both partners (or just your name if you worked alone…but please don’t work alone if you can manage it).</ul><p>You should not include any compiled files (either object files, the library, or the programs).<h2 id=part-0>Part 0</h2><p>You’re going to write a <a href=https://en.wikipedia.org/wiki/Huffman_coding>Huffman encoder/decoder</a> that can be used for simple file compression/decompression. This homework is trickier than the previous ones; however, it builds upon several of the previous ones.<p>The construction proceeds in parts. It’s not required that you complete them in order; however, tests for later parts depend on earlier parts.<p>Take a look through the code. There are multiple directories. For ease of exposition, I will refer to the repository directory as <code class=highlighter-rouge>repo</code>. The code is structured as a library, <code class=highlighter-rouge>libhuffman</code>, and two programs <code class=highlighter-rouge>encode</code> and <code class=highlighter-rouge>decode</code> which depend on the library.<p>The first directory to examine is <code class=highlighter-rouge>repo/libhuffman</code> which is where all of the library code and tests reside. <code class=highlighter-rouge>repo/libhuffman/include</code> contains the header <code class=highlighter-rouge>huffman.h</code> which is what the two applications will include. The remainder of the library code is in source and header files in <code class=highlighter-rouge>repo/libhuffman</code> and unit tests are in <code class=highlighter-rouge>repo/libhuffman/tests</code>.<p>Tests for <code class=highlighter-rouge>encode</code> and <code class=highlighter-rouge>decode</code> reside in <code class=highlighter-rouge>repo/tests</code>.<p>In this assignment, don’t make any assumptions about how many bits comprise a byte. Use <code class=highlighter-rouge>CHAR_BIT</code>.<h3 id=file-formats>File formats</h3><p>The input to the <code class=highlighter-rouge>encode</code> program is a file which you’ll treat as a sequence of <code class=highlighter-rouge>CHAR_BIT</code> bytes. The end result of encoding a file is a (hopefully) compressed output file. Unlike the input, the compressed file is a stream of bits (that are packed into bytes).<p>The compressed file starts with a canonical representation of the Huffman <a href=https://en.wikipedia.org/wiki/Trie>trie</a>. To do this, you will do a pre-order traversal of the trie using a 0-bit to indicate that it is an internal node and therefore has left and right children, or a 1-bit to indicate that it is a leaf node. Immediately following the 1-bit you will write the <code class=highlighter-rouge>CHAR_BIT</code> bits from most to least significant that make up the value of the character at that location in the tree.<p>Immediately following the pre-order traversal of the tree, you will write the code word representing <code class=highlighter-rouge>EOF</code>. (You will later use that to find the leaf that represents <code class=highlighter-rouge>EOF</code> and correct the value there.)<p>After the code word for <code class=highlighter-rouge>EOF</code>, you should output the code words that are needed to represent the input file. You’ll have to buffer the bits until you get <code class=highlighter-rouge>CHAR_BIT</code> of them and then output it. (The most significant bit is the first bit, and then they progress downward.)<p>Finally, write the code word for <code class=highlighter-rouge>EOF</code> to mark the end of the file followed by as many <code class=highlighter-rouge>0</code> bits as necessary to fill out the final byte.<h3 id=encoding>Encoding</h3><p>The process for encoding involves two passes over the data. The first pass is for counting how often each character appears in the file and the second is for performing the encoding and writing the output.<p>You’re going to build the trie by constructing a list of trees and iteratively combining them until a single tree remains. To do this, you’re going to use a node that has a pointer to the next tree in the list and also two pointers for the left and right children. See <code class=highlighter-rouge>repo/libhuffman/huffman_list.h</code>.<p>The steps are the following.<ol><li>Read the whole data and count how often each character appears;<li>Create a linked consisting of a single node with a <code class=highlighter-rouge>count</code> of 1 and a <code class=highlighter-rouge>ch</code> of <code class=highlighter-rouge>EOF</code> (see <code class=highlighter-rouge>repo/libhuffman/huffman_list.h</code>);<li>For each character with a nonzero count from the file, create a new node with the corresponding <code class=highlighter-rouge>ch</code> and <code class=highlighter-rouge>count</code> and insert it into the list as you would do with <a href=https://en.wikipedia.org/wiki/Insertion_sort>insertion sort</a>. Insert before nodes with equal <code class=highlighter-rouge>count</code>s.<li>While there are two or more nodes in the list, remove the first two nodes from the list and create a new node with the two nodes as the left and right children. Insert the node into the list, maintaining sorted order as in step 3.</ol><p>Once there is only a single tree in the list, it is the Huffman trie.<p>The code word for each byte, and for <code class=highlighter-rouge>EOF</code>, can be recovered by walking from the root to each leaf. Going left corresponds to a <code class=highlighter-rouge>0</code> bit and going right corresponds to a <code class=highlighter-rouge>1</code> bit.<h3 id=sample-run>Sample run</h3><p><strong>Input:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>cheese
</code></pre></div></div><p><strong>Frequency Counts:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>-1     EOF     1
10     \n      1
99     c       1
101    e       3
104    h       1
115    s       1
</code></pre></div></div><p><strong>Linked List (initial):</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>s(1) -&gt; h(1) -&gt; c(1) -&gt; \n(1) -&gt; EOF(1) -&gt; e(3)
</code></pre></div></div><p><strong>First pass:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>c(1) -&gt; \n(1) -&gt; EOF(1) -&gt; (2) -&gt; e(3)
                          /   \
                      s(1)     h(1)    
</code></pre></div></div><p><strong>Second pass:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>EOF(1) -&gt; (2)   --&gt;   (2) -&gt; e(3)
         /   \       /   \
      c(1)  \n(1)  s(1)   h(1)    
</code></pre></div></div><p><strong>Third pass:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>   (2)  ------&gt;  (3)  ---&gt; e(3)
  /   \         /   \
s(1)   h(1) EOF(1)  (2)
                   /   \
                 c(1) \n(1)
</code></pre></div></div><p><strong>Fourth pass:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>e(3) -----------&gt; (5)
               /       \
           (2)           (3)
          /   \         /   \
        s(1)   h(1) EOF(1)  (2)
                           /   \
                         c(1) \n(1)
</code></pre></div></div><p><strong>Fifth (and final) pass:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>         (8)
    /           \
e(3)              (5)
               /       \
           (2)           (3)
          /   \         /   \
        s(1)   h(1) EOF(1)  (2)
                           /   \
                         c(1) \n(1)
</code></pre></div></div><p><strong>Code words:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>char      code words
----      ----------
 -1  EOF  110
 10  \n   1111
 99  c    1110
101  e    0
104  h    101
115  s    100
</code></pre></div></div><p><strong>Trie representation (with added spaces for clarity):</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>0 1 01100101 0 0 1 01110011 1 01101000 0 1 11111111 0 1 01100011 1 00001010
</code></pre></div></div><p><strong>EOF:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>110
</code></pre></div></div><p><strong>Remainder of file (spaces added, includes <code class=highlighter-rouge>EOF</code>):</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>1110 101 0 0 100 0 1111 110
</code></pre></div></div><p><strong>Remainder is padding to make it a full char:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>000000
</code></pre></div></div><p>You can also use some Unix tools to examine your output files:<p><strong>File passed through <code class=highlighter-rouge>xxd</code>:</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>0000000: 594b 9da1 ff58 e15b a91f 80              YK...X.[...
</code></pre></div></div><p><strong>File passed through <code class=highlighter-rouge>xxd -b</code> (bits):</strong><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>0000000: 01011001 01001011 10011101 10100001 11111111 01011000  YK...X
0000006: 11100001 01011011 10101001 00011111 10000000           .[...
</code></pre></div></div><h3 id=decoding>Decoding</h3><p>To decode the file, read in the pre-order traversal of the tree, assembling it as you go. A <code class=highlighter-rouge>0</code> bit indicates an internal node which has both a left and right child. A <code class=highlighter-rouge>1</code> bit indicates it is a leaf and the next <code class=highlighter-rouge>CHAR_BIT</code> bits represent the value at that node from MSB to LSB. (I found a recursive function to work nicely for this.)<p>Now you need to fix the value of <code class=highlighter-rouge>EOF</code> in the tree. Switch over to a bitwise read/tree traversal routing where <code class=highlighter-rouge>0</code> indicates to go left and <code class=highlighter-rouge>1</code> indicates to go right. Once you hit the first leaf, you now have the location for the actual <code class=highlighter-rouge>EOF</code> marker and you should update the value there accordingly.<p>Now you continue with a bitwise read/tree traversal routine and use those to determine if you should go left on <code class=highlighter-rouge>0</code> or right on <code class=highlighter-rouge>1</code> in the tree. Once you reach a leaf, you should be at a letter. Output it and move back to the root. When you reach the <code class=highlighter-rouge>EOF</code> code word you should stop reading/printing. Nothing is printed for the <code class=highlighter-rouge>EOF</code> code word.<h2 id=part-1-counting>Part 1. Counting</h2><p>This is the easiest part. Look in <code class=highlighter-rouge>repo/libhuffman/counts.[hc]</code>. Implement the function by reading characters and updating the counts in the passed in array. This is similar to <a href=hw2.html>homework 2</a>. Make sure <code class=highlighter-rouge>repo/libhuffman/tests/test_counts</code> succeeds before moving on.<h2 id=part-2-bit-stream>Part 2. Bit stream</h2><p>Look in <code class=highlighter-rouge>repo/libhuffman/bit_stream.[hc]</code>. Implement the functions in these files to read and write bits to the underlying <code class=highlighter-rouge>FILE *</code> stream.<p>When writing bits, buffer the bits until <code class=highlighter-rouge>CHAR_BIT</code> bits have been added at which point a byte should be written to the underlying stream.<p>When reading bits, read bits one byte at a time from the underlying stream and buffer them.<p>You should implement <code class=highlighter-rouge>bit_stream_put()</code> and <code class=highlighter-rouge>bit_stream_get()</code> first and write the rest of the functions in terms of those.<p>Make sure you correctly handle <code class=highlighter-rouge>EOF</code> being returned from <code class=highlighter-rouge>fputc(3)</code>/<code class=highlighter-rouge>fgetc(3)</code> as well as returning the appropriate values from the functions.<p>Make sure <code class=highlighter-rouge>repo/libhuffman/tests/test_bit_stream</code> passes before moving on.<h2 id=part-3-huffman-list>Part 3. Huffman list</h2><p>Implement the basic functions for creating and freeing <code class=highlighter-rouge>huffman_node</code>s. In addition, implement the insertion function which inserts a node into a linked list in sorted order.<p>Make sure <code class=highlighter-rouge>repo/libhuffman/tests/test_list</code> passes before moving on.<h2 id=part-4-encoding>Part 4. Encoding</h2><p>You will need parts 1–3 working before this so make sure you implement those first.<p>Read the descriptions of the functions in <code class=highlighter-rouge>repo/libhuffman/huffman_encode.h</code> and <code class=highlighter-rouge>repo/libhuffman/include/huffman.h</code> carefully and implement the functions in <code class=highlighter-rouge>repo/libhuffman/huffman_encode.c</code>. Make sure that if any of the functions fails, any allocated memory is correctly freed.<p>When implementing <code class=highlighter-rouge>huffman_codewords</code>, you’re probably going to want to perform a recursive tree-traversal, passing the <code class=highlighter-rouge>codewords</code> and <code class=highlighter-rouge>lengths</code> arrays as well as building up a code word (and its length). At each leaf, the tree-traversal should set the appropriate entry in <code class=highlighter-rouge>codewords</code> and <code class=highlighter-rouge>lengths</code>.<p>Make sure <code class=highlighter-rouge>repo/libhuffman/tests/test_encode</code> passes.<h2 id=part-5-decoding>Part 5. Decoding</h2><p>You will need parts 2 and 3 working before this so make sure you implement those first.<p>Read the descriptions of the functions in <code class=highlighter-rouge>repo/libhuffman/huffman_decode.h</code> and <code class=highlighter-rouge>repo/libhuffman/include/huffman.h</code> carefully and implement the functions in <code class=highlighter-rouge>repo/libhuffman/huffman_decode.c</code>. Make sure that if any of the functions fails, any allocated memory is correctly freed.<p>Make sure <code class=highlighter-rouge>repo/libhuffman/tests/test_decode</code> passes.<p>You can run all of the library tests by running<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ make check
</code></pre></div></div><p>from the <code class=highlighter-rouge>repo/libhuffman</code> directory.<h2 id=part-6-programs>Part 6. Programs</h2><p>You’ll need to have parts 4 and 5 finished before you can test these.<p>Implement <code class=highlighter-rouge>repo/encode</code> and <code class=highlighter-rouge>repo/decode</code>. They should each take two arguments.<p>The <code class=highlighter-rouge>Makefile</code> has <code class=highlighter-rouge>-Ilibhuffman/include</code> in the <code class=highlighter-rouge>CFLAGS</code> so make sure you’re including <code class=highlighter-rouge>huffman.h</code> appropriately. (If you don’t recall what <code class=highlighter-rouge>-I</code> means, check out the <code class=highlighter-rouge>gcc(1)</code> man page.)<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./encode
Usage: ./encode input output
$ ./decode
Usage: ./decode input output
</code></pre></div></div><p>Make sure they exit with zero on success and nonzero on error. You should print out an error message on <code class=highlighter-rouge>stderr</code> if there is an error such as not being able to open a file or when you can’t decompress.<p>Make sure all of the tests pass by running<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ make check
</code></pre></div></div><p>from the <code class=highlighter-rouge>repo</code> directory.</main>