<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 13</title><meta name=description content="Lecture 13 – Mar 2nd, 2020"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2020-spring/exercises/Lecture-13.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css><main><h1 id=lecture-13--mar-2nd-2020>Lecture 13 – Mar 2nd, 2020</h1><h2 id=setup>Setup</h2><ol><li>Log in to clyde.<li>Create a directory and <code class="language-plaintext highlighter-rouge">cd</code> into it.</ol><h2 id=task>Task</h2><ol><li>Implement a function in C that returns the value of the most significant bit of an <code class="language-plaintext highlighter-rouge">unsigned int</code> using <code class="language-plaintext highlighter-rouge">CHAR_BIT</code> (defined in <code class="language-plaintext highlighter-rouge">limits.h</code>) and <code class="language-plaintext highlighter-rouge">sizeof(unsigned int)</code> to figure out how many bits are in an <code class="language-plaintext highlighter-rouge">unsigned int</code>. <div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>msb</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
  <span class=cm>/* ... */</span>
<span class=p>}</span>
</code></pre></div></div><p>I recommend creating a constant <code class="language-plaintext highlighter-rouge">NUM_BITS</code> defined in terms of <code class="language-plaintext highlighter-rouge">CHAR_BIT</code> and <code class="language-plaintext highlighter-rouge">sizeof(unsigned int)</code> that is the number of bits in an <code class="language-plaintext highlighter-rouge">unsigned int</code>.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#define NUM_BITS (</span><span class=cm>/* ... */</span><span class=cp>)
</span></code></pre></div></div><li>Test your implementation by printing out the result of <code class="language-plaintext highlighter-rouge">msb(0)</code>, <code class="language-plaintext highlighter-rouge">msb(1)</code>, <code class="language-plaintext highlighter-rouge">msb(-1)</code>. [Fun fact: Because clyde, like all modern machines, uses two’s complement integers, converting a signed integer like <code class="language-plaintext highlighter-rouge">-1</code> to an unsigned integer does not change the bit pattern, instead negative integers become large positive integers.]<li>Implement a function that extracts the least significant <code class="language-plaintext highlighter-rouge">n</code> bits of an <code class="language-plaintext highlighter-rouge">unsigned int x</code>. <div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>extract_lsbs</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=cm>/* ... */</span>
<span class=p>}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">assert(3)</code> is defined in <code class="language-plaintext highlighter-rouge">assert.h</code>.<li>Test <code class="language-plaintext highlighter-rouge">extract_lsbs</code> by printing out the result of extracting a few different numbers of bits (printing hex using <code class="language-plaintext highlighter-rouge">printf</code>’s <code class="language-plaintext highlighter-rouge">%x</code> specifier is by far the easiest way to see this). E.g., <code class="language-plaintext highlighter-rouge">extract_lsbs(0x378, 5)</code> should return <code class="language-plaintext highlighter-rouge">0x18</code>.<li>Implement a function that returns a bit field—a contiguous sequence of bits—from <code class="language-plaintext highlighter-rouge">x</code> that starts at <code class="language-plaintext highlighter-rouge">start</code> and is <code class="language-plaintext highlighter-rouge">n</code> bits long. <div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>extract_field</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span>
                           <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span>
                           <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>start</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span> <span class=o>-</span> <span class=n>start</span><span class=p>);</span>
  <span class=cm>/* ... */</span>
<span class=p>}</span>
</code></pre></div></div><li>Test <code class="language-plaintext highlighter-rouge">extract_field</code>. E.g., <code class="language-plaintext highlighter-rouge">extract_field(0x11223344, 17, 9)</code> should return <code class="language-plaintext highlighter-rouge">0x91</code>.<li><p>That second assert in task 5 is unusual looking, but correct. The more natural looking assertion, <code class="language-plaintext highlighter-rouge">assert(n + start &lt; NUM_BITS)</code> is <em>incorrect</em>.<p>Find unsigned integers <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">n</code> such that calling the following function with them causes the program to abort, but only on the marked line.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>crash_me</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>start</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=n>start</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span><span class=p>);</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>NUM_BITS</span> <span class=o>-</span> <span class=n>start</span><span class=p>);</span> <span class=c1>// Abort on this line.</span>
<span class=p>}</span>
</code></pre></div></div><p>When it crashes, it should look like this (although file names and line numbers may differ).<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>a.out: bit_fields.c:27: void crash_me(unsigned int, unsigned int): Assertion `n &lt; NUM_BITS - start' failed.
Aborted (core dumped)
</code></pre></div></div></ol></main>