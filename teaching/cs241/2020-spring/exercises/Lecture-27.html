<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 27</title><meta name=description content="Lecture 27 – Apr 17th, 2020"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2020-spring/exercises/Lecture-27.html> <link rel=stylesheet href=/css/main.css><main><h1 id=lecture-27--apr-17th-2020>Lecture 27 – Apr 17th, 2020</h1><h2 id=setup>Setup</h2><ol><li>Log in to clyde.</ol><h2 id=task>Task</h2><ol><li><p><a href=Lecture-26.html>Last time</a>, you wrote two versions of a program to compute a 1-byte checksum. If you completed them, you may use those programs. Otherwise, you can copy <code class="language-plaintext highlighter-rouge">~steve/ex/checksum-v2</code> to your home directory and use my solutions.<p>If you use your own, edit the <code class="language-plaintext highlighter-rouge">Makefile</code> to change <code class="language-plaintext highlighter-rouge">-fsanitize=address,undefined</code> to <code class="language-plaintext highlighter-rouge">-fsanitize=undefined</code> in both the <code class="language-plaintext highlighter-rouge">CFLAGS</code> and <code class="language-plaintext highlighter-rouge">LDFLAGS</code>. Run <code class="language-plaintext highlighter-rouge">$ make clean</code> and then <code class="language-plaintext highlighter-rouge">$ make</code> to rebuild without the Address Sanitizer.<li>You can time how long a Bash command takes to run but prefixing the command with <code class="language-plaintext highlighter-rouge">time</code>. Time how long <code class="language-plaintext highlighter-rouge">checksum</code> and <code class="language-plaintext highlighter-rouge">checksum2</code> take to run on themselves: <div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ time ./checksum checksum checksum2
$ time ./checksum2 checksum checksum2
</code></pre></div></div><p>Time will print out three numbers, the total (<code class="language-plaintext highlighter-rouge">real</code>) time it took to run the command and how much of that was spent in your code (<code class="language-plaintext highlighter-rouge">user</code>) versus the kernel (<code class="language-plaintext highlighter-rouge">sys</code>).<p>You probably saw that <code class="language-plaintext highlighter-rouge">checksum</code> spent significantly more time in the kernel than <code class="language-plaintext highlighter-rouge">checksum2</code>.<p>Let’s figure out why that is.<li>You’re going to use <code class="language-plaintext highlighter-rouge">strace(1)</code> to trace the system calls made by a program. We’re interested in file operations since that’s what the difference between the two programs are. We can use the <code class="language-plaintext highlighter-rouge">-e</code> option to limit the set of system calls <code class="language-plaintext highlighter-rouge">strace(1)</code> prints out. To make things shorter, let’s run the checksum programs on the <code class="language-plaintext highlighter-rouge">Makefile</code>. <div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace -e trace=open,openat,close,read,write ./checksum Makefile
$ strace -e trace=open,openat,close,read,write ./checksum2 Makefile
</code></pre></div></div><p>In both cases, it will open, read from, and close files you don’t care about. You can ignore those lines of output and just focus on the ones where it’s opening and reading from the <code class="language-plaintext highlighter-rouge">Makefile</code>. I.e., focus on the lines starting with<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>openat(AT_FDCWD, "Makefile", O_RDONLY)  = 3
</code></pre></div></div><p>(<code class="language-plaintext highlighter-rouge">openat(2)</code> is a system call like <code class="language-plaintext highlighter-rouge">open(2)</code> except it takes the path to be relative to a directory. You can read about its operation in its man page, if you like.)<p>Why did <code class="language-plaintext highlighter-rouge">checksum</code> take so much more time than <code class="language-plaintext highlighter-rouge">checksum2</code>? Next time you find yourself writing code to read and write from files, think carefully about whether you want to use a <code class="language-plaintext highlighter-rouge">FILE *</code> or a file descriptor.<li><p>In Bash, we can redirect output of an arbitrary command to a file like this <code class="language-plaintext highlighter-rouge">$ cmd &gt;output.txt</code>.<p>Let’s figure out how Bash does that using <code class="language-plaintext highlighter-rouge">strace(1)</code>. Bash’s <code class="language-plaintext highlighter-rouge">-c</code> option takes a string to run as input. E.g., if we run<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ bash -c '/bin/echo hello &gt;output.txt'
</code></pre></div></div><p>in Bash, then this will start a new instance of Bash which will run the command in quotes and then exit.<p>We can use strace’s <code class="language-plaintext highlighter-rouge">-f</code> option to trace children processes (remember, Bash will first <code class="language-plaintext highlighter-rouge">fork(2)</code> and then use <code class="language-plaintext highlighter-rouge">execve(2)</code> to transform the child process into <code class="language-plaintext highlighter-rouge">/bin/echo</code>.<p>Run this command.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ strace -o syscalls.txt -f bash -c '/bin/echo hello &gt;output.txt'
</code></pre></div></div><p>Passing <code class="language-plaintext highlighter-rouge">-o file</code> to <code class="language-plaintext highlighter-rouge">strace(1)</code> causes it to write its output to <code class="language-plaintext highlighter-rouge">file</code> rather than <code class="language-plaintext highlighter-rouge">stderr</code>.<li><p>Open <code class="language-plaintext highlighter-rouge">syscalls.txt</code> in an editor (Vim will highlight the <code class="language-plaintext highlighter-rouge">strace(1)</code> output by default. There’s an Emacs mode that will do it too, but it doesn’t appear to be installed on Clyde.) There’s a lot of output here. The number preceding each line is the process id (PID) of the process that made the system call.<p>Let’s find the <code class="language-plaintext highlighter-rouge">fork(2)</code> in the output. Interestingly, Linux doesn’t use a <code class="language-plaintext highlighter-rouge">fork</code> system call. Instead, it uses <code class="language-plaintext highlighter-rouge">clone</code> which is more general. When I did this, I got the line<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>8038  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f76f75c2a10) = 8039
</code></pre></div></div><p>which tells me that the Bash with PID 8038 forked and the child had PID 8039. The next few lines of <code class="language-plaintext highlighter-rouge">rt_sig...</code> system calls are changing signal handling masks, we’ll talk about this next time.<p>There’s also a <code class="language-plaintext highlighter-rouge">getpid(2)</code> and <code class="language-plaintext highlighter-rouge">wait4(2)</code>. The latter is just like <code class="language-plaintext highlighter-rouge">wait(2)</code> but with more options.<p>Finally, there’s an <code class="language-plaintext highlighter-rouge">openat(2)</code> which opens <code class="language-plaintext highlighter-rouge">output.txt</code> for writing, creating it if it doesn’t already exist, and truncating the file if it does.<p>Starting with the <code class="language-plaintext highlighter-rouge">openat(2)</code> and going up to the system call just before the <code class="language-plaintext highlighter-rouge">execve("/bin/echo", ...)</code> is the sequence of system calls that Bash made to perform the redirection. There’s only one new one there. Read its corresponding man page.<li>Copy <code class="language-plaintext highlighter-rouge">~steve/ex/redir</code> to your directory. Modify <code class="language-plaintext highlighter-rouge">redir.c</code> such that when you run <code class="language-plaintext highlighter-rouge">$ ./redir -o file command arguments</code> it runs <code class="language-plaintext highlighter-rouge">command arguments</code> with <code class="language-plaintext highlighter-rouge">stdout</code> redirected to <code class="language-plaintext highlighter-rouge">file</code>. You only need to add some lines inside the <code class="language-plaintext highlighter-rouge">if</code> statement to open the file and perform the redirection. You can make a similar set of system calls that Bash did to perform the redirection.</ol></main>