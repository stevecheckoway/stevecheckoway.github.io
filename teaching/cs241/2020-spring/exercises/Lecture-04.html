<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 4</title><meta name=description content="Lecture 4 – Feb 10th, 2020"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2020-spring/exercises/Lecture-04.html> <link rel=stylesheet href=/css/main.css><main><h1 id=lecture-4--feb-10th-2020>Lecture 4 – Feb 10th, 2020</h1><p>This exercise is designed to give you hands-on experience with Bash’s expansion.<h2 id=setup>Setup</h2><ol><li>Log on to clyde: <code class=highlighter-rouge>ssh user@clyde.cs.oberlin.edu</code>.<li>Create a directory with whatever name you like and <code class=highlighter-rouge>cd</code> into it.<li>Run <code class=highlighter-rouge>$ cp ~steve/ex/args .</code> (note the trailing dot!) to copy the <code class=highlighter-rouge>args</code> program to your directory.</ol><h2 id=task>Task</h2><ol><li><p>Either run <code class=highlighter-rouge>$ cat args</code> to print the contents of <code class=highlighter-rouge>args</code> or open <code class=highlighter-rouge>args</code> in an editor (e.g., <code class=highlighter-rouge>$ nvim args</code> or <code class=highlighter-rouge>$ emacs args</code>). <code class=highlighter-rouge>args</code> is a Bash script that will print out the command line arguments that you pass it.<p>The <code class=highlighter-rouge>#</code> character starts a comment, just like Python. Later in this course, we’ll learn what all of this is, but for now, you can probably see the structure of the program. There’s a <code class=highlighter-rouge>num</code> variable that is incremented each time through the <code class=highlighter-rouge>for</code> loop. The <code class=highlighter-rouge>echo</code> line produces the output and you can see <code class=highlighter-rouge>${num}</code> and <code class=highlighter-rouge>${arg}</code> which will expand to the command line argument number (its position in the list) and the command line argument itself.<p>The most mysterious part is the <code class=highlighter-rouge>"$@"</code> which tells the <code class=highlighter-rouge>for</code> loop to loop over the command line arguments, setting <code class=highlighter-rouge>arg</code> to each one in turn.<li>Splitting input into words. Run the <code class=highlighter-rouge>args</code> program several times with different command line arguments such as <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args
$ ./args aa bb    cc
$ ./args -a --version foo bar
</code></pre></div></div><p>Try adding more or less space characters between each argument. Does it have any impact on what arguments the <code class=highlighter-rouge>args</code> script receives?<li>Try to construct a command line argument that contains spaces. (Hint: the <code class=highlighter-rouge>args</code> program itself shows how to do that.) Test that you’re correct by running <code class=highlighter-rouge>args</code> with the appropriate command line argument.<li>There are 3 different ways we can get spaces in the command line arguments: single quotes, double quotes, and a backslash before each space. Run the following and examine the output (you’ll probably want to copy and paste rather than type this in). <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args '  foo  bar  ' "aaa bbb" this\ is\ one\ arg
</code></pre></div></div><p>There should be exactly three command line arguments printed out.<li>Now try putting backslashes inside single or double quotes. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args 'foo\\bar' "foo\\bar" "foo\bar" foo\\bar foo\bar
</code></pre></div></div><p>If you look carefully at that, you’ll see that inside single quotes a backslash is treated literally (indeed <em>everything</em> inside single quotes is treated literally). Inside double quotes (or outside quotes), the backslash acts as an escape so <code class=highlighter-rouge>"\\"</code> produces just a single slash. Since <code class=highlighter-rouge>\b</code> doesn’t mean anything to Bash, the backslash doesn’t act as an escape.<p>As a final step of input processing, Bash removes unquoted (and unescaped) quotation marks and backslashes. This explains why we don’t see any quotation marks in the arguments and why the backslash disappeared from <code class=highlighter-rouge>foo\bar</code>.<li>Brace expansion. Try the following examples. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args {foo,bar,baz}.mp3
$ ./args before{X,Y,,Z}after # the ,, isn't a typo
$ ./args {a,b{c,d},e}{f,g}
</code></pre></div></div><p>Notice how Bash (recursively) expands each comma-separated string inside the braces into its own argument, prepending the stuff before it and appending the stuff after it.<li><p>Try adding quotes (single and double) outside some of the braces. Try inside some of the braces. Try adding a space to one of the comma-separated items<p>These are instructive.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args before{X,Y, ,Z}after
$ ./args before{X,Y,' ',Z}after
</code></pre></div></div><li><p>Tilde expansion. <code class=highlighter-rouge>~</code> expands to your home directory, <code class=highlighter-rouge>~foo</code> expands to user <code class=highlighter-rouge>foo</code>’s home directory. Try it out using <code class=highlighter-rouge>~steve</code> to get my home directory. (Notice how we used this in the setup to copy <code class=highlighter-rouge>args</code> from my home directory.)<p>Try adding quotes or a backslash in front of the <code class=highlighter-rouge>~</code>. Try putting the <code class=highlighter-rouge>~</code> in the middle of the word like <code class=highlighter-rouge>foo~bar</code>. What happens?<li>Parameter (variable) expansion. This is the most useful one of all! Define a new Bash variable <code class=highlighter-rouge>class</code> by entering the following. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ class='CS 241'
</code></pre></div></div><p>Note carefully that the <code class=highlighter-rouge>=</code> must not have spaces on either side of it.<p>First, let’s echo (i.e., print out) the value of the <code class=highlighter-rouge>class</code> variable.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ echo ${class}
</code></pre></div></div><p>That should print out <code class=highlighter-rouge>CS 241</code>.<li>Now try passing the <code class=highlighter-rouge>class</code> variable to the <code class=highlighter-rouge>args</code> program. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args ${class}
$ ./args '${class}'
$ ./args "${class}"
</code></pre></div></div><p>Note carefully the difference between these: <code class=highlighter-rouge>"${class}"</code> expanded to a single argument whereas <code class=highlighter-rouge>${class}</code> expanded to multiple arguments. What happens is after doing parameter expansion (and several other expansions), Bash splits the result into multiple words by splitting (by default) at whitespace.<p><strong>You will never want this behavior.</strong> You can avoid it by putting double quotes around any use of variables.<li>Read the slides discussing Bash expansion, in particular command substitution and quote removal. Play around with some of the examples on the slides. For example, compare <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ./args $(echo hi there)
$ ./args "$(echo hi there)"
</code></pre></div></div></ol></main>