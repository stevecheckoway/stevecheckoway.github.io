<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 3</title><meta name=description content="Lecture 3 – Feb 7th, 2020"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2020-spring/exercises/Lecture-03.html> <link rel=stylesheet href=/css/main.css><main><h1 id=lecture-3--feb-7th-2020>Lecture 3 – Feb 7th, 2020</h1><h2 id=setup>Setup</h2><ol><li>Log on to clyde: <code class=highlighter-rouge>ssh user@clyde.cs.oberlin.edu</code>.<li>Create a directory with whatever name you like and <code class=highlighter-rouge>cd</code> into it.</ol><h2 id=task>Task</h2><ol><li>The command <code class=highlighter-rouge>$ ls /bin /usr/bin</code> will print out a list of all the files in <code class=highlighter-rouge>/bin</code> and <code class=highlighter-rouge>/usr/bin</code>. Each of these is a program you can run, but there are likely too many to display in your terminal. So run the command again, but redirect the output to a file called <code class=highlighter-rouge>binaries</code>.<li>Run <code class=highlighter-rouge>$ wc -l binaries</code> to see how many lines are in the file.<li>Open the file with your favorite command line editor (e.g., <code class=highlighter-rouge>nvim</code>, <code class=highlighter-rouge>vim</code>, <code class=highlighter-rouge>emacs</code>, <code class=highlighter-rouge>nano</code>) and take a look at the output. Is the number you printed out in step 2 the actual number of binaries? Hint: Look closely at the first line.<li>One thing to notice is the output from <code class=highlighter-rouge>ls</code> is different when directed to a file than it is when it goes to the terminal. It turns out that programs can detect if their <code class=highlighter-rouge>stdout</code> is connected to a terminal or not. Some programs use this ability to change their output, some do not. Run <code class=highlighter-rouge>$ man isatty</code> and take a look at the manual page for the <code class=highlighter-rouge>isatty()</code> function. This is a C function and we’ll get to programming in C soon enough. For now, it’s enough to know that <code class=highlighter-rouge>stdout</code> is file descriptor <code class=highlighter-rouge>1</code> so the function call <code class=highlighter-rouge>isatty(1)</code> tells the program if <code class=highlighter-rouge>stdout</code> is a terminal or not.<li>Let’s figure out how many binaries start with the letter <code class=highlighter-rouge>z</code> by using <code class=highlighter-rouge>grep</code>. Recall <code class=highlighter-rouge>grep</code> reads files (or <code class=highlighter-rouge>stdin</code>) and prints lines matching a pattern. Run <code class=highlighter-rouge>$ grep z binaries</code>. Notice that it prints out all lines containing a <code class=highlighter-rouge>z</code>. That’s not what we want, but we’re close.<li>Grep interprets the <code class=highlighter-rouge>^</code> character to mean “match the beginning of the line” so <code class=highlighter-rouge>$ grep ^z binaries</code> should do what we want. Run that and look at the output.<li><p>Let’s figure out how many of them there are. Rerun that <code class=highlighter-rouge>grep</code> command and redirect <code class=highlighter-rouge>stdout</code> to a file <code class=highlighter-rouge>zfiles</code>. Run the appropriate <code class=highlighter-rouge>wc</code> command to figure out how many there are.<p>To recap what we’ve done so far, we created a file containing a list of all of the binaries in <code class=highlighter-rouge>/bin</code> and <code class=highlighter-rouge>/usr/bin</code>. We used <code class=highlighter-rouge>grep</code> to extract just those that start with <code class=highlighter-rouge>z</code> and stored that in a file. Finally, we ran <code class=highlighter-rouge>wc</code> on that to figure out how many there are. Pretty simple but we had to create two files for it that we don’t really care about if our goal was just to figure out that final number.<li><p>We can skip the creation of the first file by <em>piping</em> the output of <code class=highlighter-rouge>ls</code> to <code class=highlighter-rouge>grep</code> and storing the result to a file. Explicitly,<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span><span class=nb>ls</span> /bin /usr/bin | <span class=nb>grep</span> <span class=s1>'^z'</span> <span class=o>&gt;</span>zfiles1
</code></pre></div></div><p>Notice that we don’t specific a file name for <code class=highlighter-rouge>grep</code>. When we omit it, it reads from <code class=highlighter-rouge>stdin</code>.<li><p>Let’s check that the two files we just created are identical by using the <code class=highlighter-rouge>diff</code> program to print out the differences between two files. Run<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>diff <span class=nt>-u</span> zfiles zfiles1
</code></pre></div></div><p>Nothing should be printed when you do that because the files should be the same.<li>Append a line of text (anything you want) to <code class=highlighter-rouge>zfiles1</code> using <code class=highlighter-rouge>echo</code> with an append redirection (<code class=highlighter-rouge>&gt;&gt;</code>).<li>Rerun the <code class=highlighter-rouge>diff</code> command from step 9. You should see some output. (Diffing files is extremely useful. We’ll see more of this later and you’ll see a lot of it as you program more.)<li>Enough <code class=highlighter-rouge>diff</code> for now. In step 8, we skipped the creation of one file by using a pipe but we still created a second file. Construct a new command piping the output of <code class=highlighter-rouge>ls</code> to <code class=highlighter-rouge>grep</code> and piping that output to <code class=highlighter-rouge>wc</code>. You should get exactly the output you got in step 7.<li>We actually did more work than we needed to. Remember that the shell will expand wildcards that match file names. For example, <code class=highlighter-rouge>/bin/z*</code> will be expanded to the paths of all of the files that match that pattern. Run <code class=highlighter-rouge>$ echo /bin/z*</code> to see the result.<li><p>Using <code class=highlighter-rouge>ls</code> rather than <code class=highlighter-rouge>echo</code> (because <code class=highlighter-rouge>echo</code> prints a single line and we want multiple lines) and the appropriate patterns, construct a pipeline to count all of the binaries starting with <code class=highlighter-rouge>z</code> again. That is, fill in the missing bits in<div class="language-sh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span><span class=nb>ls</span> <span class=o>[</span>...] | <span class=nb>wc</span> <span class=nt>-l</span>
</code></pre></div></div><li>That’s enough for today. You can delete the directory you created.</ol></main>