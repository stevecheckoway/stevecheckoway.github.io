<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lecture 30</title><meta name=description content="Lecture 30 – Nov 20th, 2019"> <link rel=canonical href=https://checkoway.net/teaching/cs241/2020-spring/exercises/Lecture-30.html> <link rel=stylesheet href=/css/main.css><main><h1 id=lecture-30--nov-20th-2019>Lecture 30 – Nov 20th, 2019</h1><h2 id=setup>Setup</h2><ol><li>Log in to clyde.<li>Copy <code class=highlighter-rouge>~steve/ex/dynamiclib</code> to your home directory.</ol><h2 id=task>Task</h2><ol><li><p>We’re going to build a dynamic library <code class=highlighter-rouge>libgreeting</code> and an application to link to it (and also do some bug fixes).<p>Start by reading the library source which consists of just a single <code class=highlighter-rouge>.c</code> file in <code class=highlighter-rouge>libgreeting</code> and a header file in <code class=highlighter-rouge>libgreeting/include/greeting</code>. (We’ll fix the typo later.)<li>Compile <code class=highlighter-rouge>hello.c</code>. To do this, we’re going to need to tell the compiler to compile it as position independent code and we also need to tell the compiler where the header files are (it’s common to separate out the header files which will be installed from source files). <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ clang -Wall -std=c11 -fPIC -Iinclude -c -o hello.o hello.c
</code></pre></div></div><li>Next, we need to build our library. Since this is the first version of our library, we’re going to use an ABI version of 1. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ clang -fPIC -shared -Wl,-soname=libgreeting.so.1 -o libgreeting.so.1.0.0 hello.o
</code></pre></div></div><li>Step 3 should have created the file <code class=highlighter-rouge>libgreeting.so.1.0.0</code>. If you run <code class=highlighter-rouge>$ file libgreeting.so.1.0.0</code> it should tell you that it’s a shared object (along with some other interesting things). If you run <code class=highlighter-rouge>$ nm libgreeting.so.1.0.0 | grep hello</code> you can see where our <code class=highlighter-rouge>hello()</code> function is defined in the library.<li><p>Next, we’re going to “install” the library and its header files for our program to use.<p>Copy <code class=highlighter-rouge>libgreeting/libgreeting.so.1.0.0</code> into the <code class=highlighter-rouge>lib</code> directory.<p>Copy <code class=highlighter-rouge>libgreeting/include/greeting</code> into the <code class=highlighter-rouge>include</code> directory.<p>Inside <code class=highlighter-rouge>lib</code>, we need to make two symlinks.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ ln -s libgreeting.so.1.0.0 libgreeting.so
$ ln -s libgreeting.so.1.0.0 libgreeting.so.1
</code></pre></div></div><li><p>Our library is installed, so it’s time to build our application which is in the <code class=highlighter-rouge>src</code> directory.<p>The first step is to compile the source files to object files (this could be omitted, especially since it’s just a single file for the program, but we’re going to do it here).<p>We need to tell <code class=highlighter-rouge>clang</code> where to find the header files.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ clang -Wall -std=c11 -I../include -c -o main.o main.c
</code></pre></div></div><li>Now we want to link our application together. We need to inform <code class=highlighter-rouge>clang</code> which library we want (namely <code class=highlighter-rouge>libgreeting.so</code>) and in which directory to look for it. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ clang -L../lib -o prog main.o -lgreeting
</code></pre></div></div><li>Great, now let’s run the program: <code class=highlighter-rouge>$./prog</code>.<li>Well that didn’t work. The problem is the dynamic linker doesn’t know to look in that directory. We can tell it where to look by using an environment variable. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ LD_LIBRARY_PATH=../lib ./prog
</code></pre></div></div><li>Using <code class=highlighter-rouge>LD_LIBRARY_PATH</code> isn’t great (you can search the Internet for the downsides). Instead, let’s tell the linker to include a runtime path in the binary. This will instruct the linker to check that path for libraries. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ clang -L../lib -Wl,-rpath='$ORIGIN/../lib' -o prog main.o -lgreeting
</code></pre></div></div><li>Now when we run the program normally, it will do the right thing as long as the path to the library from the directory of the binary is <code class=highlighter-rouge>../lib</code>. Let’s “install” the binary into the <code class=highlighter-rouge>bin</code> directory. (Just move or copy it there.)<li>Let’s fix the typo in the library. Edit the library source and fix “lirbary.”<li><p>Build a new version of the library. Make sure you rebuild the object file!<p>Since this version is compatible with the existing version, use the same soname of <code class=highlighter-rouge>libgreeting.so.1</code> but change the output file to <code class=highlighter-rouge>libgreeting.so.1.0.1</code>.<li>“Install” <code class=highlighter-rouge>libgreeting.so.1.0.1</code> in the <code class=highlighter-rouge>lib</code> directory and change the symlinks to point to the new version. You can leave the old version in place or remove it as you desire.<li><p>Run the program which should still be in <code class=highlighter-rouge>bin</code>: <code class=highlighter-rouge>$ bin/prog</code>.<p>If all has gone well, then without needing any changes to the binary, it should be using the new version of the dynamic library.<li>Rerun the command from step 10 to build the program, but this time run it under <code class=highlighter-rouge>strace</code>. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ strace -o syscalls -f -e openat clang -L../lib -Wl,-rpath='$ORIGIN/../lib' -o prog main.o -lgreeting
</code></pre></div></div><p>This will write the trace to the <code class=highlighter-rouge>syscalls</code> file, trace the children of <code class=highlighter-rouge>clang</code> (because <code class=highlighter-rouge>clang</code> will be invoking the linker), and only trace the <code class=highlighter-rouge>openat</code> system call.<p>Open <code class=highlighter-rouge>syscalls</code> up in an editor and search for <code class=highlighter-rouge>greeting</code>. Which file did it open?<li>Run <code class=highlighter-rouge>prog</code> under <code class=highlighter-rouge>strace</code>. <div class=highlighter-rouge><div class=highlight><pre class=highlight><code>$ strace -e openat ./prog
</code></pre></div></div><p>Which of the <code class=highlighter-rouge>libgreeting.so</code> files did it open? How did it know to open that one when the one opened by the linker in the previous step was different?</ol></main>