<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Lab 8: Floating Point</title><meta name=description content="Lab 8: Floating Point Due: Sunday, January 2 at 23:59"> <link rel=canonical href=https://checkoway.net/teaching/cs210/2021-fall/labs/lab8.html> <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css integrity=sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei crossorigin=anonymous> <link rel=stylesheet href=/css/main.css><style>span.not{border-top:1px solid black}.implement-box{border:1px dashed black;padding-left:4px;padding-right:4px;background-color:lightyellow}</style><main><h1 id=lab-8-floating-point>Lab 8: Floating Point</h1><p><strong>Due: Sunday, January 2 at 23:59</strong><section><p>In this lab, you will implement part of the <em>IEEE 754 Standard for Floating-Point Arithmetic</em>. In particular, you will implement single precision (32-bit) floating point addition and multiplication.<h2 id=preliminaries>Preliminaries</h2><p><strong>You may discuss your implementation with a partner; however, each of you needs to write and submit your own code. So no copying and pasting, but you should feel free to work together on a solution and to debug.</strong><p><strong>Click on the <a href=#>assignment link</a>.</strong><p>Once you have accepted the assignment, you can clone the repository on your computer by following the instruction and begin working.<p>Be sure to ask any questions on <a href=https://piazza.com/oberlin/fall2021/cs210>Piazza</a>.</section><section><h2 id=program-specification>Program Specification</h2><p>In the assignment repo, you’ll find a single Java file, <code class="language-plaintext highlighter-rouge">Xfloat.java</code> which defines an <code class="language-plaintext highlighter-rouge">Xfloat</code> class. This class represents a single-precision floating point number with the following members.<div class="language-java highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kd>private</span> <span class=kt>byte</span> <span class=n>sign</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>byte</span> <span class=n>exponent</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>significand</span><span class=o>;</span>
</code></pre></div></div><p>Of course, these represent the three fields of a floating point number.<p>The file also contains a <code class="language-plaintext highlighter-rouge">main</code> method that takes two floats as command-line arguments and prints them out along with the product and sum of the numbers. For example, running the program with floats <code class="language-plaintext highlighter-rouge">2.5</code> and <code class="language-plaintext highlighter-rouge">7.25</code> gives this output.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ java Xfloat 2.5 7.25
x:   40200000 (0 10000000 01000000000000000000000) sign: 0 exp: 80 sig: 200000 2.5
y:   40E80000 (0 10000001 11010000000000000000000) sign: 0 exp: 81 sig: 680000 7.25
x*y: 00000000 (0 00000000 00000000000000000000000) sign: 0 exp: 00 sig: 000000 0.0
x+y: 00000000 (0 00000000 00000000000000000000000) sign: 0 exp: 00 sig: 000000 0.0
</code></pre></div></div><p>The first 8 hex-digit number corresponds to the bits of the actual IEEE floating point number. The binary representation follows, separated into sign, exponent and significand fields. Next are the corresponding <code class="language-plaintext highlighter-rouge">Xfloat</code> fields in hex. Note that the significand field requires only 6 hex digits since only 23 of the 32 bits are actually used.<p>You only need to implement two methods.<dl class=implement-box><dt><code class="language-plaintext highlighter-rouge">public static Xfloat xadd(Xfloat x, Xfloat y)</code><dd>Add <code class="language-plaintext highlighter-rouge">Xfloat</code>s <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> together and return the result.<dt><code class="language-plaintext highlighter-rouge">public static Xfloat xmult(Xfloat x, Xfloat y)</code><dd>Multiply <code class="language-plaintext highlighter-rouge">Xfloat</code>s <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> together and return the result.</dl><p>You must implement the methods by performing the addition/multiplication by operating on the three fields of each <code class="language-plaintext highlighter-rouge">Xfloat</code>.<p>You should not modify any other methods.<p>You may ignore <a href=https://en.wikipedia.org/wiki/Subnormal_number>subnormal numbers</a>, infinities, and NaN, but you must properly handle <code class="language-plaintext highlighter-rouge">0.0</code>.<p>You must use bit masking and shifting to manipulate bits. In particular, you are not allowed to convert your integers to strings.<h2 id=hints>Hints</h2><ul><li><p>When implementing <code class="language-plaintext highlighter-rouge">xadd</code>, you’ll need to shift the significand of the number with the smaller magnitude so that the two numbers have the same exponent. However, if the number of bits you need to shift by is greater than 31, you should just set the significand to rather than trying to shift by more than 31. This is because <code class="language-plaintext highlighter-rouge">val &gt;&gt; 32</code> in Java is the same thing as <code class="language-plaintext highlighter-rouge">val</code> and <code class="language-plaintext highlighter-rouge">val &gt;&gt; 33</code> is the same as <code class="language-plaintext highlighter-rouge">val &gt;&gt; 1</code>. In general if <code class="language-plaintext highlighter-rouge">shamt &gt;= 32</code>, then <code class="language-plaintext highlighter-rouge">val &gt;&gt; shamt</code> is the same as <code class="language-plaintext highlighter-rouge">val &gt;&gt; (shamt % 32)</code> which can lead to surprising results.<p>For example, when adding <code class="language-plaintext highlighter-rouge">0.000000237</code> and <code class="language-plaintext highlighter-rouge">234624.0</code>, the exponent for the first is <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>−</mo><mn>2</mn><mn>3</mn></mrow><annotation encoding=application/x-tex>-23</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>−</span><span class=mord>2</span><span class=mord>3</span></span></span></span> and the exponent for the second is 17. To make the first have the same exponent as the second, we’d need to shift the first’s significand right by <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mn>7</mn><mo>−</mo><mo>−</mo><mn>2</mn><mn>3</mn><mo>=</mo><mn>4</mn><mn>0</mn></mrow><annotation encoding=application/x-tex>17 - -23 = 40</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em></span><span class=base><span class=mord>1</span><span class=mord>7</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mbin>−</span><span class="mord rule" style=margin-right:0.2222222222222222em></span><span class=mord>−</span><span class=mord>2</span><span class=mord>3</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mrel>=</span><span class="mord rule" style=margin-right:0.2777777777777778em></span><span class=mord>4</span><span class=mord>0</span></span></span></span>. In this case, the final result should be <code class="language-plaintext highlighter-rouge">234624.0</code>.<li>When implementing <code class="language-plaintext highlighter-rouge">xmult</code>, you’ll need to multiply the significands. You should perform the following steps. <ol><li>Convert the significands to 64-bit <code class="language-plaintext highlighter-rouge">long</code>s;<li>Use <code class="language-plaintext highlighter-rouge">Xfloat.HIDDEN_BIT</code> to add the hidden bit to the significands;<li>Multiply the two 64-bit significands;<li>Shift the result appropriately (making necessary adjustments to the exponent); and<li>Cast the significand back to 32 bits and remove the implicit 1.</ol><li>The various <code class="language-plaintext highlighter-rouge">XXX_MASK</code> constants defined in <code class="language-plaintext highlighter-rouge">Xfloat</code> may be helpful.<li>In Java, the unsigned right shift operator is <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>.<li>Because Java only uses signed numbers, you may want to use types that are larger than the ones you need. For example, you will probably want to work with the exponents by assigning them to <code class="language-plaintext highlighter-rouge">int</code>s before working with them. Something like <div class="language-java highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>int</span> <span class=n>e</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>exponent</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=o>;</span>
</code></pre></div></div><p>will give you <code class="language-plaintext highlighter-rouge">x</code>’s exponent as an integer in the range [0, 255]. If you omit the <code class="language-plaintext highlighter-rouge">&amp; 0xFF</code>, then any <code class="language-plaintext highlighter-rouge">x.exponent</code> that’s larger than 127 will give you a negative number.<li>Check out the page of <a href=fp.html>worked examples</a>.</ul><h2 id=submission>Submission</h2><p>Submit the lab by committing your code and pushing it to your GitHub repository.</section></main>