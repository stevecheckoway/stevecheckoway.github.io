<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Project 3: Reverse Engineering</title><meta name=description content="Project 3: Reverse Engineering"> <link rel=stylesheet href=/css/main.css> <script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-34500030-2","auto"),ga("send","pageview");</script><main><h1 id=project-3-reverse-engineering>Project 3: Reverse Engineering</h1><p><strong>Due:</strong> Thursday, December 1, 2016, 23:59<h2 id=goal>Goal</h2><p>Unlike the previous project where you were given access to the source code of the target programs, for this project, you will have to find the vulnerabilities using only the binary, <a href=https://www.hex-rays.com/products/ida/support/download_freeware.shtml>IDA Pro</a> (or <a href=https://binary.ninja/demo.html>BinaryNinja</a> or <a href=http://www.radare.org/r/>radare2</a>), and gdb.<p>All work in this project must be done on bertvm or ernievm.<p>You are given a single <code class=highlighter-rouge>server</code> binary which is a very simple webserver. The <code class=highlighter-rouge>server</code> program takes an optional argument specifying the port it listens to. It defaults to port 80 which will not work because it requires root privileges.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span><span class=nb>cd </span>webroot
<span class=nv>$ </span>./server &lt;PORT&gt;
</code></pre></div></div><p>Select a value for <code class=highlighter-rouge>&lt;PORT&gt;</code> that’s greater than 1024. See <a href=#the-environment>below</a> for details on how to run the binaries on bertvm and ernievm.<p>Your goal is to write two exploit programs: <code class=highlighter-rouge>fixed.py</code> and <code class=highlighter-rouge>randomized.py</code> to exploit the webserver and launch a bind shell.<ul><li>For <code class=highlighter-rouge>fixed.py</code>, you will run the server using the <a href=http://man7.org/linux/man-pages/man8/setarch.8.html title="setarch(8) man page">setarch(8)</a> binary to disable address space layout randomization (ASLR).<li>For <code class=highlighter-rouge>randomized.py</code>, you will run the server normally (i.e., <code class=highlighter-rouge>$ ./server &lt;PORT&gt;</code>).</ul><p>The initial code in <code class=highlighter-rouge>fixed.py</code> and <code class=highlighter-rouge>randomized.py</code> will download the file <code class=highlighter-rouge>/index.html</code> and print it to the screen.<h2 id=the-environment>The Environment</h2><p>The <code class=highlighter-rouge>server</code> binary was compiled for a 32-bit system without “large file support.” Normally, this would not be an issue since we’re not dealing with files larger than 2 GB. However, it turns out that the NFS home directory mount on bertvm and ernievm has more than 2 billion <a href=https://en.wikipedia.org/wiki/Inode title="inode Wikipedia article">inodes</a>. As a consequence, the server fails with a <a href=https://www.gnu.org/software/coreutils/faq/coreutils-faq.html#Value-too-large-for-defined-data-type>cryptic error message</a>.<p>The upshot is that to run the server on bertvm and ernievm, you’ll need to copy the <code class=highlighter-rouge>webroot</code> directory to a directory in <code class=highlighter-rouge>/tmp</code>. I recommend you create a directory <code class=highlighter-rouge>$ mkdir /tmp/&lt;username&gt;</code> and copy <code class=highlighter-rouge>webroot</code> there.<h2 id=getting-started-with-ida>Getting started (with IDA)</h2><ol><li><p>Open the server binary in IDA.<p><img src=load.png alt="Loading the binary in IDA Pro"><li><p>With the main window selected, press spacebar to toggle between graph view and linear view.<li><p>In the <code class=highlighter-rouge>Functions window</code>, double clicking on the name of a function jumps the main window to that function.<li><p>Double click on <code class=highlighter-rouge>start</code> to move to the <code class=highlighter-rouge>start</code> function.<p><img src=start.png alt="The start function"><li><p>The first argument to <code class=highlighter-rouge>__libc_start_main</code> is the main function.<li><p>Select <code class=highlighter-rouge>sub_8049DCB</code> by clicking on it. Let’s name it <code class=highlighter-rouge>main</code> by pressing <code class=highlighter-rouge>n</code> to rename it.<li><p>This has updated our functions list in the <code class=highlighter-rouge>Functions window</code>. Examine the main function by double clicking on its name, either in the <code class=highlighter-rouge>Functions window</code> or in the assembly listing.<li><p>If you are not currently in the graph view, press the spacebar to enter it. Scroll around the control flow graph either by clicking and dragging in the graph overview window or in the space between functions in the main window. The colored arrows have the following meanings:<ul><li>Blue: unconditional jump<li>Green: conditional jump taken<li>Red: conditional jump not taken</ul><li><p>Let’s take a look at the code surrounding the call to <code class=highlighter-rouge>_socket</code>.<p><img src=socket.png alt="The socket call"><p>We can immediately see that the assembly was produced from code similar to the following:<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>sock</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>sock</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>perror</span><span class=p>(</span><span class=s>"sock = socket(PF_INET, SOCK_STREAM, 0)"</span><span class=p>);</span>
	<span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></div><p>Notice that the error message contains the symbolic constants used although the code only contains the numeric values.<li><p>If we are so inclined, we can have IDA replace the numeric values with the constants. First, select the <code class=highlighter-rouge>domain</code> parameter, 2, by clicking on it. Right clicking opens a contextual menu. Select <code class=highlighter-rouge>Use standard symbolic constant</code> and then select <code class=highlighter-rouge>PF_INET</code> from the list. Similarly, select <code class=highlighter-rouge>SOCK_STREAM</code> for the <code class=highlighter-rouge>type</code> parameter. In general, we won’t have error messages that tell us what the constants we want are. In that case, we can look through the manual page for a given function to see in which system header file it is defined and then look through the header file to find the value of the constant. IDA does a good job of only suggesting constants with the appropriate numerical value, most of the time.<li><p>Identify the loop in the main function. Loops can easily be identified in the graph view by arrows that point toward earlier blocks of code. Clicking on a jump target will also highlight the label.<p>In addition to calling standard library functions, each pass through the loop calls a function in the server binary. Since this is a webserver, we can surmise that this function is responsible for handling web clients (i.e., browsers). Rename this function from <code class=highlighter-rouge>sub_...</code> to <code class=highlighter-rouge>handle_client</code> the same way we did with <code class=highlighter-rouge>main</code>.<li><p>Let’s identify the two arguments to <code class=highlighter-rouge>handle_client</code>. Start by selecting <code class=highlighter-rouge>ebx</code> in the <code class=highlighter-rouge>mov [esp], ebx</code> instruction just before call <code class=highlighter-rouge>handle_client</code>. All instances of <code class=highlighter-rouge>ebx</code> are highlighted in the assembly. Looking up the code, we see that <code class=highlighter-rouge>ebx</code> is set most recently by the return value of the accept function. By checking the manual page for <a href=http://man7.org/linux/man-pages/man2/accept.2.html title="accept(2) man page">accept(2)</a>, we see that it returns a file descriptor (an integer) corresponding to the newly opened socket. So the first argument to <code class=highlighter-rouge>handle_client</code> is the socket, which makes sense.<p>The second argument to <code class=highlighter-rouge>handle_client</code>, which is passed in <code class=highlighter-rouge>[esp+4]</code>, comes from <code class=highlighter-rouge>esi</code>. By selecting <code class=highlighter-rouge>esi</code>, we see that it is used in several places but it is only assigned once via the <code class=highlighter-rouge>lea</code> instruction following the call to <a href=http://man7.org/linux/man-pages/man2/listen.2.html title="listen(2) man page">listen(2)</a>. <code class=highlighter-rouge>esi</code> is set to an address on the stack, namely <code class=highlighter-rouge>esp+28h</code>. We see that this address is passed as the <code class=highlighter-rouge>buf</code> argument to <a href=http://man7.org/linux/man-pages/man3/inet_ntop.3.html title="inet_ntop(3) man page">inet_ntop(3)</a>. The manual page reveals that <a href=http://man7.org/linux/man-pages/man3/inet_ntop.3.html title="inet_ntop(3) man page">inet_ntop(3)</a> writes a string containing the address to the <code class=highlighter-rouge>buf</code> argument.<p>Slightly more cryptically, but if <a href=http://man7.org/linux/man-pages/man3/inet_ntop.3.html title="inet_ntop(3) man page">inet_ntop(3)</a> does not return 0, then the 4~byte word <code class=highlighter-rouge>0x0000002D</code> is written to the first word of <code class=highlighter-rouge>buf</code>. Recall that x86 is little endian so this is stored as <code class=highlighter-rouge>0x2D</code>, <code class=highlighter-rouge>0x00</code>, <code class=highlighter-rouge>0x00</code>, <code class=highlighter-rouge>0x00</code> in memory. By selecting the <code class=highlighter-rouge>2Dh</code> and pressing <code class=highlighter-rouge>r</code>, we see that <code class=highlighter-rouge>0x2D</code> is the hyphen character <code class=highlighter-rouge>-</code>. Thus if <a href=http://man7.org/linux/man-pages/man3/inet_ntop.3.html title="inet_ntop(3) man page">inet_ntop(3)</a> does not return 0, then the address is set to be <code class=highlighter-rouge>"-"</code>.<li><p>Finally, double click on <code class=highlighter-rouge>handle_client</code>. At the beginning of the function, IDA has declared a bunch of symbols like <code class=highlighter-rouge>var_1120</code>. These are what IDA thinks are local variables on the stack. Some of them have names already corresponding to arguments of standard library functions that IDA knows about. We can change these names as we see fit by clicking on them and pressing <code class=highlighter-rouge>n</code>.<p>In addition to local variables, IDA can deduce information about function arguments. In particular, it knows that <code class=highlighter-rouge>handle_client</code> takes two arguments, but it thinks both are <code class=highlighter-rouge>int</code>s. We can change this by selecting <code class=highlighter-rouge>handle_client</code> and pressing <code class=highlighter-rouge>y</code> and giving <code class=highlighter-rouge>handle_client</code> the prototype:<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=n>handle_client</span><span class=p>(</span><span class=kt>int</span> <span class=n>sock</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>address</span><span class=p>)</span>
</code></pre></div></div><p>After doing this, notice that the arguments have been named <code class=highlighter-rouge>sock</code> and <code class=highlighter-rouge>address</code>, similar to the local variables.</ol><h2 id=finding-a-vulnerability>Finding a vulnerability</h2><p>We could, if we wanted, spend a lot of time working out how each function works but our goal is not to understand the complete inner workings of the program. Rather, our goal is to find a way to exploit it.<ol><li><p>Let’s begin by finding usage of functions which are prone to errors. Let’s start by finding all instances of <a href=http://man7.org/linux/man-pages/man3/strcpy.3.html title="strcpy(3) man page">strcpy(3)</a>. In the <code class=highlighter-rouge>Functions window</code>, double click on <code class=highlighter-rouge>_strcpy</code>. (As an aside, what IDA calls <code class=highlighter-rouge>_strcpy</code> is what gdb calls <code class=highlighter-rouge>strcpy@plt</code>. We’ll come back to this later.) If you are in “graph view,” press the spacebar to return to “text view.” From the comment <code class=highlighter-rouge>CODE XREF: sub_8049214+33</code>, we can see that <a href=http://man7.org/linux/man-pages/man3/strcpy.3.html title="strcpy(3) man page">strcpy(3)</a> is called from exactly one location.<p><img src=strcpy.png alt=strcpy><li><p>Double click on <code class=highlighter-rouge>sub_8049214</code> to be taken to that function. We can see that the destination argument to <a href=http://man7.org/linux/man-pages/man3/strcpy.3.html title="strcpy(3) man page">strcpy(3)</a> comes from the return value of <code class=highlighter-rouge>sub_8048EF9</code> and by tracing the source argument back, we see that it is the first (and only) argument to <code class=highlighter-rouge>sub_8049214</code>.<li><p>Examine function <code class=highlighter-rouge>sub_8048EF9</code>. From a quick inspection, it should be clear that this function calls <a href=http://man7.org/linux/man-pages/man3/malloc.3.html title="malloc(3) man page">malloc(3)</a>, passing its only argument and then asserts that the returned value is not <code class=highlighter-rouge>NULL</code>. From the argument to the <code class=highlighter-rouge>__assert_fail</code> function, we can see that <code class=highlighter-rouge>sub_8048EF9</code> is actually named <code class=highlighter-rouge>xmalloc</code>. Rename <code class=highlighter-rouge>sub_8048EF9</code> to <code class=highlighter-rouge>xmalloc</code>. This way, if we see it again, we’ll immediately remember what it does.<li><p>Go back to <code class=highlighter-rouge>sub_8049214</code> (by pressing <code class=highlighter-rouge>esc</code> or by hitting the back arrow in the toolbar). At this point, it’s clear that the function argument is a string that gets copied to some memory allocated on the heap. Furthermore, we can tell that a pointer to this memory is returned. All that remains is to figure out if it’s allocating enough memory to hold the entire string. The few instructions before and after the <code class=highlighter-rouge>repne scasb</code> are actually computing the length of the string plus 1 and passing that to <a href=http://man7.org/linux/man-pages/man3/malloc.3.html title="malloc(3) man page">malloc(3)</a>. To see that, look up the definition of <code class=highlighter-rouge>scasb</code>, <code class=highlighter-rouge>repne</code>, and <code class=highlighter-rouge>not</code> and recall that integers are stored in twos complement.<p>Since enough space is allocated to hold the contents of the string and <a href=http://man7.org/linux/man-pages/man3/malloc.3.html title="malloc(3) man page">malloc(3)</a> is asserted to not return <code class=highlighter-rouge>NULL</code>, this <a href=http://man7.org/linux/man-pages/man3/strcpy.3.html title="strcpy(3) man page">strcpy(3)</a> does not appear to be exploitable.<li><p>It’s worth noting that this function behaves very similar to the standard library function <a href=http://man7.org/linux/man-pages/man3/strdup.3.html title="strdup(3) man page">strdup(3)</a> in that it takes a string as an argument and then creates a copy of it, returning the copy. Rename the function <code class=highlighter-rouge>xstrdup</code> (by analogy with <code class=highlighter-rouge>xmalloc</code>).<li><p>Follow the same procedures to check for the presence of other potentially exploitable functions such as <a href=http://man7.org/linux/man-pages/man3/memcpy.3.html title="memcpy(3) man page">memcpy(3)</a> or <a href=http://man7.org/linux/man-pages/man3/strcat.3.html title="strcat(3) man page">strcat(3)</a>. By default IDA only displays 2 cross references. It’s helpful to increase this number. Look in <code class=highlighter-rouge>Options &gt; General... &gt; Cross-references</code> and increase the number of displayed xrefs to 200. This should be far more than we need.<li><p>You should be able to find several buffer overflows on the stack. Which functions have overflows and what input do we need to send over the socket to trigger them?<p>Since the stack is not executable, we are not able to inject code onto the stack. We will need to try something else.</ol><p><strong>Before continuing on, you should follow all of the steps above and make sure you can find the buffer overflows.</strong><h2 id=writing-the-first-exploit-fixedpy>Writing the first exploit (<code class=highlighter-rouge>fixed.py</code>)</h2><p>We’re going to perform a return-into-libc attack by smashing the stack in one of the error handling functions. From the last section, you should have discovered a buffer overflow on the stack when handling an incorrect HTTP version (as well as a few other places).<ol><li><p>Run the server using <a href=http://man7.org/linux/man-pages/man8/setarch.8.html title="setarch(8) man page">setarch(8)</a> to disable ASLR.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>setarch i686 <span class=nt>-R</span> ./server &lt;PORT&gt;
</code></pre></div></div><li><p>A valid HTTP request line looks like:<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>GET /path/to/file HTTP/1.1\r\n
</code></pre></div></div><p>Modify <code class=highlighter-rouge>fixed.py</code> to hard code a request for an arbitrary file (you can use <code class=highlighter-rouge>/</code> for the file, if you’d like) and a short, invalid HTTP version string. When the program is run, what is the result? What about a long, invalid HTTP version string?<li><p>Compute the distance on the stack from the saved instruction pointer to the location where the version is written to the stack. This can be computed directly from the disassembly or you can use gdb.<li><p>Produce a request string that overwrites the saved <code class=highlighter-rouge>eip</code> on the stack with an arbitrary value.<li><p>Find the address of the <a href=http://man7.org/linux/man-pages/man3/exit.3.html title="exit(3) man page">exit(3)</a> function in libc (gdb works nicely here) and craft input that will overwrite the saved <code class=highlighter-rouge>eip</code> with that address.<li><p>When you run the exploit, the server will likely crash before it returns to <a href=http://man7.org/linux/man-pages/man3/exit.3.html title="exit(3) man page">exit(3)</a>. Look carefully at the what happens after you overwrite the saved <code class=highlighter-rouge>eip</code>. In particular, some other values that are subsequently used as pointers are overwritten as well. Modify your exploit to overwrite those values with valid addresses. Addresses on the stack work very well.<li><p>Find the address of the <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a> function in libc. Modify the exploit such that instead of returning to <a href=http://man7.org/linux/man-pages/man3/exit.3.html title="exit(3) man page">exit(3)</a>, it returns to <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a>. The argument to <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a> should be a pointer to a string that contains:<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code>bash <span class=nt>-c</span> <span class=s1>'coproc p { /bin/bash 2&gt;&amp;1; }; nc -l 127.0.0.1 &lt;LISTEN_PORT&gt; &lt;&amp;${p[0]} &gt;&amp;${p[1]}'</span>
</code></pre></div></div><p>where <code class=highlighter-rouge>&lt;LISTEN_PORT&gt;</code> was the second argument to <code class=highlighter-rouge>fixed.py</code>.<p>This confusing command will create two processes, <code class=highlighter-rouge>bash</code> and <code class=highlighter-rouge>nc</code>. <code class=highlighter-rouge>nc</code> will open a socket on port <code class=highlighter-rouge>&lt;LISTEN_PORT&gt;</code>. The <code class=highlighter-rouge>coproc</code> command and the various redirections ensure that <code class=highlighter-rouge>nc</code>’s standard in is the standard out and standard error from <code class=highlighter-rouge>bash</code> and <code class=highlighter-rouge>nc</code>’s stdard out is the standard in to <code class=highlighter-rouge>bash</code>.<p>Since you don’t know exactly where on the stack this string will live, you can prepend it with a large number of spaces, similar to a <code class=highlighter-rouge>nop</code> sled. Take care that any text after the string is ignored. If you get an error message about bad redirections, you probably did not heed this advice.<p>After <code class=highlighter-rouge>fixed.py</code> sends the exploit string to the server, it should close the socket, sleep for a second (just to give the server process time to run and launch <code class=highlighter-rouge>nc</code>), open a new socket and connect to <code class=highlighter-rouge>127.0.0.1:&lt;LISTEN_PORT&gt;</code> and finally pass that to the <code class=highlighter-rouge>console</code> function in <code class=highlighter-rouge>console.py</code><p>At this point, <code class=highlighter-rouge>fixed.py</code> should make one connection to the server to send a string to cause the server to return to <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a> opening a bind shell and make a second connection to the bind shell. The first connection should be to the port specified in the first argument to <code class=highlighter-rouge>fixed.py</code> whereas the second connection should be to the port specified in the second argument.<p>Now, you should be able to execute shell commands!</ol><h2 id=writing-the-second-exploit-randomizedpy>Writing the second exploit (<code class=highlighter-rouge>randomized.py</code>)</h2><p>For the second exploit, the goal is the same (get a bind shell) but this time, you’ll need to deal with address space layout randomization (ASLR).<ol><li><p>Run the server without using <a href=http://man7.org/linux/man-pages/man8/setarch.8.html title="setarch(8) man page">setarch(8)</a>.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>./server &lt;PORT&gt;
</code></pre></div></div><p>Now, if we run <code class=highlighter-rouge>fixed.py</code>, the server will crash because we relied on the address of <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a> and the address of our string on the stack. We’re going to need to perform an address disclosure attack to learn where the stack is and where libc is loaded.<li><p>Examine the four calls to <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a> in IDA, three of them have constant format strings, one does not. Start the server in gdb. Set a breakpoint just prior to the call to the <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a> that does not have a constant format string and use gdb to print the format string.<li><p>Modify <code class=highlighter-rouge>randomized.py</code> to provide input which can be used for the format string. Try giving it file paths of the form: <code class=highlighter-rouge>ZZZZ%1$08x-%2$08x-%3$08x</code> and then change the 1, 2, and 3 to 4, 5, and 6 and so on until you find the value <code class=highlighter-rouge>ZZZZ</code>. You’ll be able to see the output by watching <code class=highlighter-rouge>stdout</code> of server. Naturally, this information won’t be available to a real client, but we will deal with that later.<li><p>Double clicking on <code class=highlighter-rouge>_snprintf</code> in IDA shows the implementation in the plt section:<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>jmp	ds:off_804B7E4
</code></pre></div></div><p>Although it may not be obvious, this is actually an indirect jump to an absolute address. That is, address <code class=highlighter-rouge>0x0804b7e4</code> contains a pointer to the actual <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a> function which is set by the dynamic linker after <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a> is called for the first time.<li><p>Modify <code class=highlighter-rouge>randomized.py</code> so that it tries to fetch a file that contains a format string exploit. This time, instead of <code class=highlighter-rouge>ZZZZ%n$08x</code> for some value of <code class=highlighter-rouge>n</code>, replace the <code class=highlighter-rouge>ZZZZ</code> with the address <code class=highlighter-rouge>0x0804b7e4</code> (in little endian) and replace the <code class=highlighter-rouge>08x</code> with <code class=highlighter-rouge>s</code>. This should cause the server to treat that address as a pointer to a string and print the string. The first four bytes of which should be the address of <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a>.<li><p>Now modify the file string to <code class=highlighter-rouge>addr%m$08x%n$s</code> where <code class=highlighter-rouge>addr</code> and <code class=highlighter-rouge>n</code> are the values from step 5 and <code class=highlighter-rouge>m</code> is chosen such that it prints out the saved frame pointer (<code class=highlighter-rouge>ebp</code>) in hex. Hint: rather than just trying value after value like we did to find the <code class=highlighter-rouge>ZZZZ</code>, look at the <code class=highlighter-rouge>lea</code> instruction just above the call to <code class=highlighter-rouge>_snprintf</code> to find the start of the buffer.<li><p>In addition to writing the connection information to <code class=highlighter-rouge>stdout</code>, the server logs the same information to <code class=highlighter-rouge>server.log</code>. Since this is written in the same directory as server, we can fetch it using a normal HTTP GET.<p>Change <code class=highlighter-rouge>randomized.py</code> to make two requests. The first exploits the format string vulnerability to write the address of the saved <code class=highlighter-rouge>ebp</code> in hex and the address of <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a> to <code class=highlighter-rouge>server.log</code> and the second fetches <code class=highlighter-rouge>/server.log</code>.<li><p>Read the fetched <code class=highlighter-rouge>server.log</code> line by line and look at the last line.<li><p>Parse the 8 byte hex string that is the saved frame pointer and the 4 byte integer that is the address of <a href=http://man7.org/linux/man-pages/man3/snprintf.3.html title="snprintf(3) man page">snprintf(3)</a> out of the last line read from the socket.<li><p>Add your exploit from <code class=highlighter-rouge>fixed.py</code> to <code class=highlighter-rouge>randomized.py</code> but make sure you adjust the address of <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a>, <a href=http://man7.org/linux/man-pages/man3/exit.3.html title="exit(3) man page">exit(3)</a>, and the pointers to the stack appropriately. Now that you know a stack address, you can compute exactly which address the argument to system should be. Remove the “space sled” that we used for <code class=highlighter-rouge>fixed.py</code> since it is unnecessary. Finally, open a new socket and connect to <code class=highlighter-rouge>127.0.0.1:&lt;LISTEN_PORT&gt;</code> and pass the socket to <code class=highlighter-rouge>console</code>.<p>At this point, <code class=highlighter-rouge>randomized.py</code> should make one connection to the server to trigger a format-string vulnerability; make a second connection to the server to fetch the log file; make a third connection to the server and, using the address from the log file, send a string to cause the server to return to <a href=http://man7.org/linux/man-pages/man3/system.3.html title="system(3) man page">system(3)</a> opening a bind shell; and make one final connection to the bind shell. The first three connections should be to the port specified in the first argument to <code class=highlighter-rouge>randomized.py</code> whereas the final connection should be to the port specified in the second argument.<li><p>You should now be able to start the server and get a bind shell by running <code class=highlighter-rouge>randomized.py</code> even though the process is protected by ASLR! Congratulations!</ol><h2 id=deliverables>Deliverables</h2><ul><li>You must include a file called <code class=highlighter-rouge>ID</code> which contains the names of all partners (or just your own if you worked by yourself).<li>You will submit using the provided <code class=highlighter-rouge>submit.sh</code> script.</ul></main>