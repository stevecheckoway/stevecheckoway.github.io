<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Using Nix on macOS</title><meta name=description content="I recently started using the Nix Package Manager on macOS and the process has been painful. In this post, I’m going to write down how I’m currently using Nix..."> <link rel=canonical href=https://checkoway.net/musings/nix/> <link rel=stylesheet href=/css/main.css><main><article class=post vocab=http://schema.org typeof=BlogPosting><div class=post-header><h1 class=post-title property=headline>Using Nix on macOS</h1><p class=post-meta><time datetime=2022-07-23T00:00:00+00:00 property=datePublished>Jul 23, 2022</time> • <span property=author typeof=Person><span property=name>Stephen Checkoway</span></span></div><div class=post-content property=articleBody><p>I recently started using the <a href=https://nixos.org/>Nix Package Manager</a> on macOS and the process has been painful. In this post, I’m going to write down how I’m currently using Nix on macOS with the Zsh shell.<p>Let me start by acknowledging Ian Henry’s wonderful series of <a href=https://ianthehenry.com/posts/how-to-learn-nix/>blog posts on Nix</a>. Nix is an extremely complex system that is poorly documented. There are many blog posts by a variety of authors about using Nix, Ian’s series is the most comprehensive (and funny) that I’ve read.<sup id=fnref:1><a href=#fn:1 class=footnote rel=footnote role=doc-noteref>1</a></sup><p>In this post, I will not discuss NixOS at all. I have no experience with NixOS (although the idea is neat). Every use of Nix below should be understood to mean using Nix to interact with the <code class="language-plaintext highlighter-rouge">nixpkgs</code> set of packages running on macOS.<p>If you’re familiar with Nix, you may be wondering, why not use <a href=https://github.com/nix-community/home-manager>Home Manager</a>? The short answer is Nix is already too complex. Adding additional tools just makes it harder to understand how Nix works and how to use it directly.<p>In this post, I’m going to stick with running standard Nix binaries and not use any additional tools (although there are two shell scripts that run Nix tools that I find useful at the end of the post). Nix has a bunch of experimental features (including the <code class="language-plaintext highlighter-rouge">nix</code> binary itself and flakes<sup id=fnref:2><a href=#fn:2 class=footnote rel=footnote role=doc-noteref>2</a></sup>). The experimental features change so I won’t discuss them at all either.<h2 id=nix-overview>Nix overview</h2><p>Nix <a href=https://nixos.org/>bills itself</a> as “a tool that takes a unique approach to package management and system configuration” that can be used “to make reproducible, declarative and reliable systems.”<p>In my mind, there are four main use cases for Nix.<ol><li>User package management;<li>Consistent developer environments;<li>One-off shells with packages installed; and<li>Building software.</ol><p>For the first use case, I mean package management in the style of Apt, MacPorts, or HomeBrew. The tool for this is called <code class="language-plaintext highlighter-rouge">nix-env</code> and it’s responsible for installing packages. It’s usually used on the command line to install packages incrementally. For example, if you want to install the excellent <a href=https://github.com/BurntSushi/ripgrep>ripgrep</a> tool, you’d use the following command.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ nix-env -iA nixpkgs.ripgrep
</code></pre></div></div><p>Like any good package manager, this will install <code class="language-plaintext highlighter-rouge">rg</code> along with any dependencies.<p>Nix also supports a declarative package management system where you put the list of packages you want in a file and then you can (for example) check that file into version control.<p>Nix’s second use case lets developers declaratively specify a (more or less) complete environment for a project in a <code class="language-plaintext highlighter-rouge">shell.nix</code> file. (E.g., a Python project may require other Python packages to be installed. These dependencies can be specified in the <code class="language-plaintext highlighter-rouge">shell.nix</code> file. All developers can use the <code class="language-plaintext highlighter-rouge">nix-shell</code> command to launch a Bash shell with the appropriate dependencies installed and available.) This use case seems more aspirational than practical since it requires all developers use Nix to get this benefit.<p>The third use case is Nix’s killer feature in my mind. Rather than install and remove packages as necessary, Nix lets you create a one-off shell that contains a set of packages. For example, if you need a shell with <code class="language-plaintext highlighter-rouge">socat</code> installed and don’t want to install it in your normal environment using <code class="language-plaintext highlighter-rouge">nix-env</code>, you would run<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ nix-shell -p socat
</code></pre></div></div><p>which would fire up a new Bash shell with <code class="language-plaintext highlighter-rouge">socat</code> installed and ready to run. Neat!<p>The last use case is similar to the second except that rather than just have the dependencies be installed and managed by Nix, the whole project is built by Nix.<p>Of these, I’m interested in declarative package management, one-off shells, and developer environments, in that order. I’m not interested in building software using Nix.<h2 id=consistent-reproducable-declarative-package-management>Consistent, reproducable, declarative package management</h2><p>My requirements for using Nix as a package management system are simple.<ul><li>It must be <em>declarative</em> in that I can write a simple file (I call mine <code class="language-plaintext highlighter-rouge">env.nix</code>) which specifies the list of packages to install;<li>It must be <em>reproducable</em> meaning that I should be able to check my <code class="language-plaintext highlighter-rouge">env.nix</code> into version control, check it out later—on another machine—and get the same set of packages installed; and<li>It must be <em>consistent</em> in the sense that if I install a package via <code class="language-plaintext highlighter-rouge">nix-env</code> (as I did above with Ripgrep), then that should be exactly the same as if I had specified it in my <code class="language-plaintext highlighter-rouge">env.nix</code> file.</ul><p>One could be forgiven for thinking consistency is a natural consequence of reproducability. In Nix, consistency requires additional work.<p>Let’s start by making a declarative list of packages. There are at least three ways of using Nix as a declarative package manager: <a href=https://ianthehenry.com/posts/how-to-learn-nix/overlays/>overlays</a>, <a href=https://ianthehenry.com/posts/how-to-learn-nix/overriding/>overrides</a>, and for lack of a better term, a package file.<p>Overlays and overrides are confusing and don’t match my mental model for how declaring a set of packages to be installed should work. And I think using them is more complex than necessary. But first, we need to talk about how Nix works.<h3 id=how-nix-works>How Nix works</h3><p>At a high level, you tell Nix to install a package (<code class="language-plaintext highlighter-rouge">$ nix-env -iA nixpkgs.fd</code> installs the excellent <code class="language-plaintext highlighter-rouge">fd</code> utility) and it figures out everything it needs to install, and then installs it.<p>In more detail, Nix reads and evaluates the “Nix expression” that says how to build software. Each expression is (usually) contained in a file somewhere that says how to build the software. <a href=https://github.com/NixOS/nixpkgs/blob/becea4604c71b6508346102bf9e3a50d449cde85/pkgs/tools/misc/fd/default.nix>This is the Nix expression</a> for building version 8.4.0 of <code class="language-plaintext highlighter-rouge">fd</code>.<p>Nix expressions are written in the Nix language which is pure, lazy, and functional (like Haskell) and the main datatype is the “attribute set” which is just a key-value map or dictionary. The Nix expression for building software evaluates to a <em>derivation</em> which is an attribute set containing a key <code class="language-plaintext highlighter-rouge">type</code> with the value <code class="language-plaintext highlighter-rouge">derivation</code>. <strong>A side effect of <code class="language-plaintext highlighter-rouge">nix-env</code> evaluating a derivation is to download and install the package described by the derivation!</strong> This is kind of shocking in a pure language.<p>Once a derivation is evaluated, the package is installed under <code class="language-plaintext highlighter-rouge">/nix</code> somewhere and symlinks are created in the user’s <em>profile</em>. A profile is just a directory containing <code class="language-plaintext highlighter-rouge">bin</code> and <code class="language-plaintext highlighter-rouge">share</code> and similar directories. There’s a symlink <code class="language-plaintext highlighter-rouge">~/.nix-profile</code> which points to the active profile.<p>Nix exposes software to a shell by creating symlinks in the profile’s <code class="language-plaintext highlighter-rouge">bin</code> directory. One of the shell’s start up files will contain code to put <code class="language-plaintext highlighter-rouge">~/.nix-profile/bin</code> in the <code class="language-plaintext highlighter-rouge">PATH</code> environment variable. (See <a href=#fixing-shell-integration>below</a> for more details.) <code class="language-plaintext highlighter-rouge">nix-shell</code>, the command for getting shells with packages installed works similarly except it also adjusts the <code class="language-plaintext highlighter-rouge">PATH</code> before invoking Bash.<p>(Nix supports multiple profiles and rolling back profiles to earlier versions. This happens by updating the <code class="language-plaintext highlighter-rouge">~/.nix-profile</code> symbolic link. I have found no use for using multiple profiles because my environment is specified declaratively by a file in Git, so I can use standard Git commands to roll back as needed.)<p>Before getting to my approach, there’s one last thing we need to discuss and that’s where does Nix get the Nix expressions that are used to build packages? The answer is complicated and is different for each Nix tool.<p>First, <code class="language-plaintext highlighter-rouge">nix-env</code> uses a “default” expression when installing, updating, and querying for available packages. (Never, ever update packages with <code class="language-plaintext highlighter-rouge">nix-env -u</code>. I have no idea what the use case is, but it does the wrong thing. Just don’t do it. Similarly, never use <code class="language-plaintext highlighter-rouge">nix-env -i</code> without also passing <code class="language-plaintext highlighter-rouge">-A</code>. It doesn’t do what you want otherwise.) The default expression is either a file or a directory named <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code>.<p>If it’s a file, then the contents of a file is the default expression which must evaluate to an attribute set (dictionary). If it’s a directory, then the name of each directory inside <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code> becomes a key in the default expression’s attribute set whose value is the result of evaluating the <code class="language-plaintext highlighter-rouge">default.nix</code> inside the directory. It’s complicated and the full details are immaterial. But as an example<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>~/.nix-defexpr
├── bar
│&nbsp;&nbsp; └── default.nix
└── foo
    └── default.nix
</code></pre></div></div><p>would create an attribute set <code class="language-plaintext highlighter-rouge">{ foo = ...; bar = ...; }</code> as the default expression where the values corresponding to <code class="language-plaintext highlighter-rouge">foo</code> and <code class="language-plaintext highlighter-rouge">bar</code> come from evaluating their <code class="language-plaintext highlighter-rouge">default.nix</code> files.<p>The traditional method of using Nix as a package manager uses <a href=https://nixos.wiki/wiki/Nix_channels>Nix channels</a> which are similar to Git branches. Each channel refers to a <a href=https://github.com/NixOS/nixpkgs/><code class="language-plaintext highlighter-rouge">nixpkgs</code></a> commit. Nix has a tool, <code class="language-plaintext highlighter-rouge">nix-channel</code>, which maintains a list of channels. It downloads a snapshot of the <code class="language-plaintext highlighter-rouge">nixpkgs</code> repository at the commit specified by the channel. This contains all of the Nix expressions used to build packages (as well as a bunch of helper Nix code). <code class="language-plaintext highlighter-rouge">$ nix-env -iA</code> can then be used to install (or update) a package.<p>Returning to my original example<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ nix-env -iA nixpkgs.ripgrep
</code></pre></div></div><p>this instructs <code class="language-plaintext highlighter-rouge">nix-env</code> to start with the “default” expression (<code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code>) which evaluates to an attribute set as described above. Next, <code class="language-plaintext highlighter-rouge">nix-env</code> will look up the key <code class="language-plaintext highlighter-rouge">nixpkgs</code> in the default expression which returns another attribute set. Then, <code class="language-plaintext highlighter-rouge">nix-env</code> will look up the key <code class="language-plaintext highlighter-rouge">ripgrep</code> in that attribute set. Since this causes the <code class="language-plaintext highlighter-rouge">ripgrep</code> derivation to be evaluated, it will install the package (and dependencies).<p>Nix channels have a problem: they’re not reproducible. You get whatever revision of <code class="language-plaintext highlighter-rouge">nixpkgs</code> happens to be current when you run <code class="language-plaintext highlighter-rouge">$ nix-channel --update</code>. As a result, Nix channels are not useful and I won’t discuss them further, but the <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code> is essential for <code class="language-plaintext highlighter-rouge">nix-env</code>. I’ll return to this below.<p>So if <code class="language-plaintext highlighter-rouge">nix-env</code> uses this default Nix expression, it stands to reason that other Nix tools like <code class="language-plaintext highlighter-rouge">nix-shell</code> do as well. Alas, no.<p>The second method Nix tools like <code class="language-plaintext highlighter-rouge">nix-shell</code> and <code class="language-plaintext highlighter-rouge">nix-build</code> use to look up Nix expressions is via the <code class="language-plaintext highlighter-rouge">NIX_PATH</code> environment variable. There are a bunch of valid formats for <code class="language-plaintext highlighter-rouge">NIX_PATH</code>, but the simplest is a colon-separated list of directories. <code class="language-plaintext highlighter-rouge">NIX_PATH</code> is used in two key places (for my purposes).<p>The first is when <code class="language-plaintext highlighter-rouge">nix-shell</code> is run on a file (<code class="language-plaintext highlighter-rouge">shell.nix</code> by default), the contents of the file is the entire Nix expression. Since these files need a way to refer to Nix packages, it’s common to see Nix files that contain a line like this.<div class="language-nix highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kr>import</span> <span class=o>&lt;</span><span class=nv>nixpkgs</span><span class=o>&gt;</span> <span class=p>{}</span>
</code></pre></div></div><p>Without delving too deeply into the Nix language, the <code class="language-plaintext highlighter-rouge">import &lt;nixpkgs&gt;</code> instructs <code class="language-plaintext highlighter-rouge">nix-shell</code> to look for a directory named <code class="language-plaintext highlighter-rouge">nixpkgs</code> in the <code class="language-plaintext highlighter-rouge">NIX_PATH</code> and load <code class="language-plaintext highlighter-rouge">nixpkgs/default.nix</code> as a Nix expression. The <code class="language-plaintext highlighter-rouge">{}</code> is an empty attribute set that is passed to the function returned by <code class="language-plaintext highlighter-rouge">import &lt;nixpkgs&gt;</code>. Why does <code class="language-plaintext highlighter-rouge">import &lt;nixpkgs&gt;</code> return a function? It does simply because the expression that was loaded from the <code class="language-plaintext highlighter-rouge">nixpkgs/default.nix</code> file is a function. This function will return an attribute set whose keys are the names of packages, more or less.<p>So we have two separate mechanisms to specify where to find a Nix expression that describes how to build a package.<p>The last thing we need is a way to specify a particular revision of the <code class="language-plaintext highlighter-rouge">nixpkgs</code> repository we want to use. There are multiple ways to do this. For <code class="language-plaintext highlighter-rouge">NIX_PATH</code>, we can use a URL like <code class="language-plaintext highlighter-rouge">NIX_PATH=nixpkgs=https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz</code> which will map <code class="language-plaintext highlighter-rouge">&lt;nixpkgs&gt;</code> to <code class="language-plaintext highlighter-rouge">nixpkgs</code> revision <code class="language-plaintext highlighter-rouge">87d9c84817d7be81850c07e8f6a362b1dfc30feb</code>.<p>For <code class="language-plaintext highlighter-rouge">nix-env</code>, there are several ways to do this, including having a single <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code> file, a <code class="language-plaintext highlighter-rouge">~/.nix-defexpr/nixpkgs.nix</code> file, or a <code class="language-plaintext highlighter-rouge">~/.nix-defexpr/nixpkgs/default.nix</code> file. I’d prefer the first option, but as we’ll see the last option works best. The contents of <code class="language-plaintext highlighter-rouge">~/.nix-defexpr/nixpkgs/default.nix</code> is a single expression that evaluates to a function which, when called, evaluates to the attribute set containing the list of packages.<div class="language-nix highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kr>import</span> <span class=p>(</span><span class=kr>fetchTarball</span> <span class=s2>"https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz"</span><span class=p>)</span>
</code></pre></div></div><p>(Note the lack of <code class="language-plaintext highlighter-rouge">{}</code> at the end of the line. This is because the contents of the file needs to evaluate to a function which is precisely what we get from the <code class="language-plaintext highlighter-rouge">import</code>. If we added the <code class="language-plaintext highlighter-rouge">{}</code>, it’d call the function and return an attribute set.)<p>At the end of the day, I want the exact same packages to be installed regardless of whether I use <code class="language-plaintext highlighter-rouge">$ nix-env -iA foo</code> or <code class="language-plaintext highlighter-rouge">nix-shell -p foo</code>, or update the list of packages in my <code class="language-plaintext highlighter-rouge">env.nix</code>. That means we’ll need <code class="language-plaintext highlighter-rouge">NIX_PATH</code> and the default Nix expression to agree on the list of packages.<sup id=fnref:3><a href=#fn:3 class=footnote rel=footnote role=doc-noteref>3</a></sup><h3 id=declarative-package-manager-implementation>Declarative package manager implementation</h3><p>With all of the preliminaries out of the way, let’s see how to set up a declarative package manager that meets my three requirements.<p>Let’s make a list of packages that works first and pin it to a specific <code class="language-plaintext highlighter-rouge">nixpkgs</code> revision afterward.<p>As discussed above, <code class="language-plaintext highlighter-rouge">nix-env</code> has a default expression it uses for installing packages. This default can be overridden using the <code class="language-plaintext highlighter-rouge">-f</code> (or <code class="language-plaintext highlighter-rouge">--file</code>) argument. We can also instruct <code class="language-plaintext highlighter-rouge">nix-env</code> to also install <em>every</em> package. I have no idea why we’d want to do that in general. However, if we specify a different default expression—one that contains just a list of the packages we want—then it’ll install all of those. So without further ado, here’s my <code class="language-plaintext highlighter-rouge">env.nix</code>.<div class="language-nix highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kn>with</span> <span class=kr>import</span> <span class=o>&lt;</span><span class=nv>nixpkgs</span><span class=o>&gt;</span> <span class=p>{};</span> <span class=p>[</span>
  <span class=nv>calc</span>
  <span class=nv>coreutils-full</span>
  <span class=nv>fd</span>
  <span class=nv>gdb</span>
  <span class=nv>jq</span>
  <span class=nv>nasm</span>
  <span class=nv>neovim</span>
  <span class=nv>nodejs</span>
  <span class=nv>pwgen</span>
  <span class=nv>python3</span>
  <span class=nv>ripgrep</span>
  <span class=nv>ruby_3_1</span>
  <span class=nv>shellcheck</span>
  <span class=nv>socat</span>
  <span class=nv>tmux</span>
  <span class=nv>tree</span>
  <span class=nv>universal-ctags</span>
  <span class=nv>zsh-syntax-highlighting</span>
<span class=p>]</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">with expr1; expr2</code> construct evaluates <code class="language-plaintext highlighter-rouge">expr1</code> to an attribute set <em>S</em> and then it evaluates <code class="language-plaintext highlighter-rouge">expr2</code> with the keys of <em>S</em> bound to their values. We can write an equivalent <code class="language-plaintext highlighter-rouge">env.nix</code> file as something like<div class="language-nix highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kd>let</span>
  <span class=nv>pkgs</span> <span class=o>=</span> <span class=kr>import</span> <span class=o>&lt;</span><span class=nv>nixpkgs</span><span class=o>&gt;</span> <span class=p>{};</span>
<span class=kn>in</span> <span class=p>[</span>
  <span class=nv>pkgs</span><span class=o>.</span><span class=nv>calc</span>
  <span class=nv>pkgs</span><span class=o>.</span><span class=nv>coreutils-full</span>
  <span class=o>...</span>
  <span class=nv>pkgs</span><span class=o>.</span><span class=nv>zsh-syntax-highlighting</span>
<span class=p>]</span>
</code></pre></div></div><p>To install all of the packages in <code class="language-plaintext highlighter-rouge">env.nix</code>, it’s sufficient to run <code class="language-plaintext highlighter-rouge">$ nix-env -irf env.nix</code>. The <code class="language-plaintext highlighter-rouge">--remove-all</code> (<code class="language-plaintext highlighter-rouge">-r</code>) flag will remove anything that was installed (e.g., by <code class="language-plaintext highlighter-rouge">nix-env -iA</code>) but isn’t in <code class="language-plaintext highlighter-rouge">env.nix</code>.<p>This satisfies my first requirement: a <em>declarative</em> package manager.<p>Note that this is essentially the solution Ian Henry <a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>arrived at</a>. All credit to him for this.<p>Notice how <code class="language-plaintext highlighter-rouge">$ nix-env -irf env.nix</code> is not using the default Nix expression, <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code>, but is instead using <code class="language-plaintext highlighter-rouge">NIX_PATH</code> by way of <code class="language-plaintext highlighter-rouge">import &lt;nixpkgs&gt;</code>. To satisfy the second requirement, <em>reproducability</em>, we need to pin <code class="language-plaintext highlighter-rouge">nixpkgs</code> to a particular revision. We can do that by setting <code class="language-plaintext highlighter-rouge">NIX_PATH=nixpkgs=https://...</code> as described above; however, there’s a better way.<p>To make this reproducable, it’s enough to check the <code class="language-plaintext highlighter-rouge">env.nix</code> and the shell dotfiles which set <code class="language-plaintext highlighter-rouge">NIX_PATH</code> into version control.<p>The final requirement is <em>consistency</em>: installing a package using any of the standard methods (<code class="language-plaintext highlighter-rouge">nix-env -iA</code>, <code class="language-plaintext highlighter-rouge">nix-env -irf env.nix</code>, <code class="language-plaintext highlighter-rouge">nix-shell -p</code>, etc.) should always give me the same package. If <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code> and <code class="language-plaintext highlighter-rouge">NIX_SHELL</code> are kept in sync, pointing to the same revision of <code class="language-plaintext highlighter-rouge">nixpkgs</code>, this will work out.<p>Unfortunately, updating the Nix expressions for a package by changing the value of the <code class="language-plaintext highlighter-rouge">NIX_PATH</code> environment variable has a few downsides. First, changing it in a dotfile like <code class="language-plaintext highlighter-rouge">~/.bash_profile</code> or <code class="language-plaintext highlighter-rouge">~/.zprofile</code> has no effect on the currently running shells meaning it’d be easy to install package in a shell that still has the old <code class="language-plaintext highlighter-rouge">NIX_PATH</code> value.<p>So that suggests that <code class="language-plaintext highlighter-rouge">NIX_PATH</code> should remain constant and only <code class="language-plaintext highlighter-rouge">~/.nix-defexpr</code> should be updated. My <code class="language-plaintext highlighter-rouge">~/.zprofile</code> contains the following line (but see <a href=#fixing-shell-integration>fixing shell integration</a> below).<div class="language-zsh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nb>export </span><span class=nv>NIX_PATH</span><span class=o>=</span><span class=s2>"</span><span class=nv>$HOME</span><span class=s2>/.nix-defexpr"</span>
</code></pre></div></div><p>Recall that if <code class="language-plaintext highlighter-rouge">NIX_PATH</code> is a colon-separated list of directories, then the Nix code <code class="language-plaintext highlighter-rouge">import &lt;foo&gt;</code> is going to look for a directory named <code class="language-plaintext highlighter-rouge">foo</code> in each of those directories. Since I’m always using <code class="language-plaintext highlighter-rouge">import &lt;nixpkgs&gt;</code> (as is everyone else), we need a <code class="language-plaintext highlighter-rouge">~/.nix-defexpr/nixpkgs</code> directory containing a <code class="language-plaintext highlighter-rouge">default.nix</code> file.<sup id=fnref:4><a href=#fn:4 class=footnote rel=footnote role=doc-noteref>4</a></sup><div class="language-nix highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kr>import</span> <span class=p>(</span><span class=kr>fetchTarball</span> <span class=s2>"https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz"</span><span class=p>)</span>
</code></pre></div></div><p>This is the only file that specifies which revision of <code class="language-plaintext highlighter-rouge">nixpkgs</code> to use and it will be used by all of the Nix tools.<p>Checking this file into version control (along with <code class="language-plaintext highlighter-rouge">nix.env</code> and the <code class="language-plaintext highlighter-rouge">~/.zprofile</code> which specifies <code class="language-plaintext highlighter-rouge">NIX_PATH</code>) satisfies all of my requirements. Yay!<h2 id=fixing-shell-integration>Fixing shell integration</h2><p>Installing Nix on macOS is a bit unpleasant. Single-user installs are no longer supported. Multi-user installs have to be used instead.<sup id=fnref:5><a href=#fn:5 class=footnote rel=footnote role=doc-noteref>5</a></sup> This goes through a complicated dance to create <code class="language-plaintext highlighter-rouge">/nix</code> and some accounts for building software not as your user.<p>One of the steps of the installer is to modify the system-wide <code class="language-plaintext highlighter-rouge">/etc/bashrc</code> and <code class="language-plaintext highlighter-rouge">/etc/zshrc</code> files to insert the lines<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c># Nix</span>
<span class=k>if</span> <span class=o>[</span> <span class=nt>-e</span> <span class=s1>'/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
  <span class=nb>.</span> <span class=s1>'/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'</span>
<span class=k>fi</span>
<span class=c># End Nix</span>
</code></pre></div></div><p>The sourced <code class="language-plaintext highlighter-rouge">nix-daemon.sh</code> starts the Nix daemon running and sets some environment variables, including <code class="language-plaintext highlighter-rouge">PATH</code>.<p>This code doesn’t belong in either of these files for two reasons: 1. They’re system-owned files. macOS <em>will</em> overwrite them when updating so you need equivalent code in your local shell start up files. 2. Setting environment variables doesn’t belong in the shell’s rc files; neither in the global ones in <code class="language-plaintext highlighter-rouge">/etc</code> nor in the dotfile ones in <code class="language-plaintext highlighter-rouge">$HOME</code>. It belongs in the local “profile” files: <code class="language-plaintext highlighter-rouge">~/.bash_profile</code> and <code class="language-plaintext highlighter-rouge">~/.zprofile</code>.<p>To elaborate on the second point, we have to look at which files are sourced when shells start and that means we have to talk about types of shells (unfortunately).<p>Every shell is either a login shell or not. Independently, every shell is either interactive or not. All four combinations are possible, although a noninteractive, login shell is uncommon.<p>A login shell is created by running <code class="language-plaintext highlighter-rouge">$ bash -l</code> or <code class="language-plaintext highlighter-rouge">$ zsh --login</code>. Otherwise, it’s not a login shell.<p>An interactive shell is one that gives you a prompt and you, well, interact with. A noninteractive shell is what you get when you run a shell script.<p>Usually, your terminal emulator will create a login shell by default when you open a new terminal window. (Apple Terminal and iTerm2 both do.) And that’s generally the only time you create a login shell.<p>When a login shell is created, it’s usually going to create its environment from scratch rather than using the environment it inherited from its parent. In contrast, since a nonlogin shell is usually created by running <code class="language-plaintext highlighter-rouge">bash</code> or <code class="language-plaintext highlighter-rouge">zsh</code> from inside another shell, it’s going to inherit its environment. This suggests that environment variables (like <code class="language-plaintext highlighter-rouge">PATH</code>) should only ever be set when login shells start. Since they’re going to be the same from shell to shell, it doesn’t make sense to set them again when starting a nonlogin shell.<p>Interactive shells, in contrast, need to be configured every time they are started. This includes setting up shell completions and command line prompts (e.g., <code class="language-plaintext highlighter-rouge">PS1</code>). We have to do this every time because these settings are not inherited by child processes.<p>To support this, shells support a dizzying array of files that get read on start up. In the interest of length, I’m going to focus on Zsh since that’s the new default macOS shell.<p>Zsh has 8 different startup files it sources, depending on whether the shell is a login shell or not and whether the shell is interactive or not. Here they are, in the order they are sourced.<ol><li><code class="language-plaintext highlighter-rouge">/etc/zshenv</code><li><code class="language-plaintext highlighter-rouge">~/.zshenv</code><li><code class="language-plaintext highlighter-rouge">/etc/zprofile</code> for a login shell<li><code class="language-plaintext highlighter-rouge">~/.zprofile</code> for a login shell<li><code class="language-plaintext highlighter-rouge">/etc/zshrc</code> for an interactive shell<li><code class="language-plaintext highlighter-rouge">~/.zshrc</code> for an interactive shell<li><code class="language-plaintext highlighter-rouge">/etc/zlogin</code> for a login shell<li><code class="language-plaintext highlighter-rouge">~/.zlogin</code> for a login shell</ol><p>If a file doesn’t exist, it is skipped. On macOS, <code class="language-plaintext highlighter-rouge">/etc/zshenv</code> and <code class="language-plaintext highlighter-rouge">/etc/zlogin</code> don’t exist so we can ignore those. I don’t use <code class="language-plaintext highlighter-rouge">~/.zlogin</code>, so we can ignore that one too.<p>This leaves <code class="language-plaintext highlighter-rouge">~/.zshenv</code>, <code class="language-plaintext highlighter-rouge">/etc/zprofile</code>, <code class="language-plaintext highlighter-rouge">~/.zprofile</code>, <code class="language-plaintext highlighter-rouge">/etc/zshrc</code>, and <code class="language-plaintext highlighter-rouge">~/.zshrc</code> to deal with.<p>“But Steve,” I hear you object, “I don’t care about any of that. I just want to put all my shell configuration in a single file and be done with it.” That’d be nice, but macOS doesn’t care what you want.<p>Here’s the problem. On macOS, <code class="language-plaintext highlighter-rouge">/etc/zprofile</code> runs <code class="language-plaintext highlighter-rouge">/usr/libexec/path_helper</code> and sets <code class="language-plaintext highlighter-rouge">PATH</code> from its output. <code class="language-plaintext highlighter-rouge">path_helper</code> constructs a <code class="language-plaintext highlighter-rouge">PATH</code> starting with the paths from <code class="language-plaintext highlighter-rouge">/etc/paths</code> and <code class="language-plaintext highlighter-rouge">/etc/paths.d</code> and appending the other directories already on <code class="language-plaintext highlighter-rouge">PATH</code>. Let’s look at an example.<p>With an empty <code class="language-plaintext highlighter-rouge">PATH</code>, <code class="language-plaintext highlighter-rouge">path_helper</code> outputs a string (which the shell will <code class="language-plaintext highlighter-rouge">eval</code>) to set a default <code class="language-plaintext highlighter-rouge">PATH</code>.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ PATH= /usr/libexec/path_helper
PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin"; export PATH;
</code></pre></div></div><p>If <code class="language-plaintext highlighter-rouge">PATH</code> contains any other directories, such as <code class="language-plaintext highlighter-rouge">~/.nix-profile/bin</code>, these will be moved to the end.<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ PATH=$HOME/.nix-profile/bin:/usr/bin /usr/libexec/path_helper
PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin:/Users/steve/.nix-profile/bin"; export PATH;
</code></pre></div></div><p>Therefore, if a new login shell is launched, your <code class="language-plaintext highlighter-rouge">PATH</code> will be rearranged!<p>To deal with this, we’ll need to treat login shell specially and reset <code class="language-plaintext highlighter-rouge">PATH</code> prior to <code class="language-plaintext highlighter-rouge">/etc/zprofile</code> being sourced.<p>This is a relatively minor issue since you don’t often run a new login shell. A bigger problem comes from interactive shells.<p>Nix’s modifications to <code class="language-plaintext highlighter-rouge">/etc/zshrc</code> will source <code class="language-plaintext highlighter-rouge">nix-daemon.sh</code> which unconditionally prepends Nix profile directories to <code class="language-plaintext highlighter-rouge">PATH</code>. So invoking <code class="language-plaintext highlighter-rouge">zsh</code> (i.e., an interactive, nonlogin shell) causes the directories to be added to the <code class="language-plaintext highlighter-rouge">PATH</code> again.<p>To summarize, if we launch a new login shell, our <code class="language-plaintext highlighter-rouge">PATH</code> is rearranged. If we launch a new interactive shell, duplicate entries are added to the path. If we launch a new interactive, login shell, we get a rearranged <code class="language-plaintext highlighter-rouge">PATH</code> with duplicate entries. Not great.<p>So here’s the solution. First, after installing Nix, undo the modifications Nix made to the files in <code class="language-plaintext highlighter-rouge">/etc</code>. The install script creates a copy of the file before modification (e.g., <code class="language-plaintext highlighter-rouge">/etc/zprofile.backup-before-nix</code>). Just rename that to <code class="language-plaintext highlighter-rouge">/etc/zprofile</code> to restore the original.<p>Second, create a <code class="language-plaintext highlighter-rouge">~/.zshenv</code> file with the following contents.<div class="language-zsh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=o>[[</span> <span class=nt>-o</span> login <span class=o>]]</span> <span class=o>&amp;&amp;</span> <span class=nb>export </span><span class=nv>PATH</span><span class=o>=</span><span class=s1>'/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin'</span>
</code></pre></div></div><p>If Zsh is launched as a login shell, then it’ll source <code class="language-plaintext highlighter-rouge">~/.zshenv</code> which will reset <code class="language-plaintext highlighter-rouge">PATH</code> to a sensible default. Next, it’ll source <code class="language-plaintext highlighter-rouge">/etc/zprofile</code> which will run <code class="language-plaintext highlighter-rouge">path_helper</code> and set up the default <code class="language-plaintext highlighter-rouge">PATH</code> according to the usual macOS rules.<p>Third, create a <code class="language-plaintext highlighter-rouge">~/.zprofile</code> file containing all of the exported environment variables you want. You should also prepend directories to <code class="language-plaintext highlighter-rouge">PATH</code> in this file. Since this is sourced after <code class="language-plaintext highlighter-rouge">path_helper</code> is run, the directories added will not be rearranged.<p>This is the (partial) contents of my <code class="language-plaintext highlighter-rouge">~/.zprofile</code>.<div class="language-zsh highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c># Environment variables.</span>
<span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s1>'nvim'</span>
<span class=nb>export </span><span class=nv>LANG</span><span class=o>=</span>en_US.UTF-8
<span class=nb>export </span><span class=nv>LC_CTYPE</span><span class=o>=</span>en_US.UTF-8
<span class=nb>export </span><span class=nv>PAGER</span><span class=o>=</span><span class=s1>'less -R'</span>
<span class=c># Other exported environment variables here.</span>

<span class=c># Add paths to PATH.</span>
<span class=k>if</span> <span class=o>[[</span> <span class=nt>-f</span> <span class=s1>'/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then
  </span><span class=nb>source</span> <span class=s1>'/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'</span>
  <span class=nb>export </span><span class=nv>NIX_PATH</span><span class=o>=</span><span class=s2>"</span><span class=nv>$HOME</span><span class=s2>/.nix-defexpr"</span>
<span class=k>fi</span>
<span class=o>[[</span> <span class=nt>-f</span> <span class=s2>"</span><span class=nv>$HOME</span><span class=s2>/.ghcup/env"</span> <span class=o>]]</span> <span class=o>&amp;&amp;</span> <span class=nb>source</span> <span class=s2>"</span><span class=nv>$HOME</span><span class=s2>/.ghcup/env"</span>
<span class=o>[[</span> <span class=nt>-f</span> <span class=s2>"</span><span class=nv>$HOME</span><span class=s2>/.cargo/env"</span> <span class=o>]]</span> <span class=o>&amp;&amp;</span> <span class=nb>source</span> <span class=s2>"</span><span class=nv>$HOME</span><span class=s2>/.cargo/env"</span>
</code></pre></div></div><p>Notice that it sets <code class="language-plaintext highlighter-rouge">NIX_PATH</code> as described above.<p>It’s important that the <code class="language-plaintext highlighter-rouge">PATH</code> clearing happen in <code class="language-plaintext highlighter-rouge">~/.zshenv</code> and not <code class="language-plaintext highlighter-rouge">~/.zprofile</code> because otherwise system directories from <code class="language-plaintext highlighter-rouge">/etc/paths</code> won’t make it into the <code class="language-plaintext highlighter-rouge">PATH</code> (or work will have to be duplicated).<p>Finally, put the per-shell configuration in <code class="language-plaintext highlighter-rouge">~/.zshrc</code>. This includes things like your prompt, shell aliases, shell completions, and so on.<p>In general, if it’s an exported environment variable, put it in <code class="language-plaintext highlighter-rouge">~/.zprofile</code>. If it’s any other configuration, put it in <code class="language-plaintext highlighter-rouge">~/.zshrc</code>.<p>With this setup, every new login shell will clear <code class="language-plaintext highlighter-rouge">PATH</code> and reset it. Nonlogin shells (interactive or not) will inherit the <code class="language-plaintext highlighter-rouge">PATH</code>.<h2 id=wrapping-up>Wrapping up</h2><p>To summarize, to use Nix on macOS in a reliable and reproducable manner,<ol><li>Undo the modifications the Nix installer made to the files in <code class="language-plaintext highlighter-rouge">/etc</code>;<li>Separate your shell configuration into <code class="language-plaintext highlighter-rouge">~/.zshenv</code>, <code class="language-plaintext highlighter-rouge">~/.zprofile</code>, and <code class="language-plaintext highlighter-rouge">~/.zshrc</code> such that exported environment variables go in <code class="language-plaintext highlighter-rouge">~/.zprofile</code>, configuration for interactive shells goes in <code class="language-plaintext highlighter-rouge">~/.zshrc</code>, and <code class="language-plaintext highlighter-rouge">~/.zshenv</code> resets <code class="language-plaintext highlighter-rouge">PATH</code> for login shells;<li>Create a <code class="language-plaintext highlighter-rouge">~/.nix-defexpr/nixpkgs/default.nix</code> file with the single line <div class="language-nix highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kr>import</span> <span class=p>(</span><span class=kr>fetchTarball</span> <span class=s2>"https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz"</span><span class=p>)</span>
</code></pre></div></div><li>Modify <code class="language-plaintext highlighter-rouge">~/.zprofile</code> to run <code class="language-plaintext highlighter-rouge">nix-daemon.sh</code> and set <code class="language-plaintext highlighter-rouge">NIX_PATH</code>; and<li>Create an <code class="language-plaintext highlighter-rouge">env.nix</code> somewhere containing your list of packages and install them with <code class="language-plaintext highlighter-rouge">$ nix-env -irf env.nix</code>.</ol><p>The only thing I haven’t touched on is how you get the revision of <code class="language-plaintext highlighter-rouge">nixpkgs</code> to use. How I do it is I run a script (which I called <code class="language-plaintext highlighter-rouge">nix-update-nixpkgs</code>) which grabs the revision for the stable Darwin (i.e., macOS) channel and uses that.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c>#!/usr/bin/env nix-shell</span>
<span class=c>#!nix-shell -i bash -p bash curl jq</span>
<span class=c># shellcheck shell=bash</span>

<span class=c># Just go with the revision that works for stable darwin. Might as well for now</span>
<span class=c># unless there's an issue.</span>

<span class=nb>set</span> <span class=nt>-euo</span> pipefail

<span class=nv>dryrun</span><span class=o>=</span>0

usage<span class=o>()</span> <span class=o>{</span>
  <span class=nb>cat</span> <span class=o>&lt;&lt;</span><span class=no>USAGEEOF</span><span class=sh>
Usage: </span><span class=nv>$0</span><span class=sh> [OPTIONS]

Options:
  -h  --help      show this help
  -n  --dry-run   do not make any changes
</span><span class=no>USAGEEOF
</span><span class=o>}</span>

<span class=k>for </span>arg <span class=k>in</span> <span class=s2>"</span><span class=nv>$@</span><span class=s2>"</span><span class=p>;</span> <span class=k>do
  case</span> <span class=k>${</span><span class=nv>arg</span><span class=k>}</span> <span class=k>in</span>
    <span class=s1>'-n'</span> <span class=p>|</span> <span class=s1>'--dry-run'</span><span class=p>)</span>
      <span class=nv>dryrun</span><span class=o>=</span>1
      <span class=p>;;</span>
    <span class=s1>'-h'</span> <span class=p>|</span> <span class=s1>'--help'</span><span class=p>)</span>
      usage
      <span class=nb>exit </span>0
      <span class=p>;;</span>
    <span class=k>*</span><span class=p>)</span>
      <span class=nb>echo</span> <span class=s2>"</span><span class=nv>$0</span><span class=s2>: Unexpected argument: </span><span class=k>${</span><span class=nv>arg</span><span class=k>}</span><span class=s2>"</span> <span class=o>&gt;</span>&amp;2
      usage <span class=o>&gt;</span>&amp;2
      <span class=nb>exit </span>1
      <span class=p>;;</span>
  <span class=k>esac</span>
<span class=k>done


</span><span class=nv>revision</span><span class=o>=</span><span class=si>$(</span>curl <span class=nt>--silent</span> <span class=nt>--show-error</span> <span class=s1>'https://monitoring.nixos.org/prometheus/api/v1/query?query=channel_revision'</span> <span class=se>\</span>
  | jq <span class=nt>-r</span> <span class=s1>'.data.result[]|select(.metric.status == "stable" and .metric.variant == "darwin").metric.revision'</span><span class=si>)</span>
<span class=nv>nixexpr</span><span class=o>=</span><span class=s2>"import (fetchTarball </span><span class=se>\"</span><span class=s2>https://github.com/NixOS/nixpkgs/archive/</span><span class=k>${</span><span class=nv>revision</span><span class=k>}</span><span class=s2>.tar.gz</span><span class=se>\"</span><span class=s2>)"</span>
<span class=nv>nixpkgsfile</span><span class=o>=</span>~/.nix-defexpr/nixpkgs/default.nix

<span class=nb>mkdir</span> <span class=nt>-p</span> <span class=s2>"</span><span class=si>$(</span><span class=nb>dirname</span> <span class=s2>"</span><span class=k>${</span><span class=nv>nixpkgsfile</span><span class=k>}</span><span class=s2>"</span><span class=si>)</span><span class=s2>"</span>
<span class=k>if</span> <span class=o>[[</span> <span class=nt>-f</span> <span class=s2>"</span><span class=k>${</span><span class=nv>nixpkgsfile</span><span class=k>}</span><span class=s2>"</span> <span class=o>]]</span> <span class=o>&amp;&amp;</span> diff <span class=nt>-q</span> <span class=s2>"</span><span class=k>${</span><span class=nv>nixpkgsfile</span><span class=k>}</span><span class=s2>"</span> - <span class=o>&lt;&lt;&lt;</span> <span class=s2>"</span><span class=k>${</span><span class=nv>nixexpr</span><span class=k>}</span><span class=s2>"</span> <span class=o>&gt;</span>/dev/null<span class=p>;</span> <span class=k>then
  </span><span class=nb>echo</span> <span class=s1>'nixpkgs already up to date'</span>
  <span class=nb>exit </span>0
<span class=k>fi

if</span> <span class=o>[[</span> <span class=k>${</span><span class=nv>dryrun</span><span class=k>}</span> <span class=nt>-ne</span> 0 <span class=o>]]</span><span class=p>;</span> <span class=k>then
  </span><span class=nb>echo</span> <span class=s2>"This would set nixpkgs to revision </span><span class=k>${</span><span class=nv>revision</span><span class=k>}</span><span class=s2>"</span>
<span class=k>else
  </span><span class=nb>echo</span> <span class=s2>"Setting nixpkgs to revision </span><span class=k>${</span><span class=nv>revision</span><span class=k>}</span><span class=s2>"</span>
  <span class=nb>echo</span> <span class=s2>"</span><span class=k>${</span><span class=nv>nixexpr</span><span class=k>}</span><span class=s2>"</span> <span class=o>&gt;</span><span class=k>${</span><span class=nv>nixpkgsfile</span><span class=k>}</span>
<span class=k>fi</span>

<span class=s2>"</span><span class=si>$(</span><span class=nb>dirname</span> <span class=s2>"</span><span class=nv>$0</span><span class=s2>"</span><span class=si>)</span><span class=s2>/nix-diff"</span> <span class=s2>"</span><span class=k>${</span><span class=nv>revision</span><span class=k>}</span><span class=s2>"</span>
<span class=c># vim: set sw=2 sts=2 ts=8 et ft=bash:</span>
</code></pre></div></div><p>The penultimate line runs my <code class="language-plaintext highlighter-rouge">nix-diff</code> script which shows the changes that would be made if <code class="language-plaintext highlighter-rouge">$ nix-env -irf env.nix</code> were run. This is based on Ian Henry’s <a href=https://github.com/ianthehenry/sd-nix/blob/master/diff>similar script</a>. Here it is.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c>#!/usr/bin/env nix-shell</span>
<span class=c>#!nix-shell -i bash -p bash jq</span>
<span class=c># shellcheck shell=bash</span>

<span class=c># Usage: nix-diff [revision]</span>
<span class=c># where revision is the full nixpkgs revision.</span>

<span class=nb>set</span> <span class=nt>-euo</span> pipefail

<span class=nb>declare</span> <span class=nt>-A</span> cur

query<span class=o>()</span> <span class=o>{</span>
  nix-env <span class=nt>--query</span> <span class=nt>--json</span> <span class=s2>"</span><span class=nv>$@</span><span class=s2>"</span> | jq <span class=nt>-r</span> <span class=s1>'.[] | .pname + " " + .version'</span>
<span class=o>}</span>

<span class=nv>query_args</span><span class=o>=()</span>

<span class=k>if</span> <span class=o>[[</span> <span class=nv>$# </span><span class=nt>-eq</span> 1 <span class=o>]]</span><span class=p>;</span> <span class=k>then
  </span><span class=nv>query_args</span><span class=o>=(</span><span class=s1>'--file'</span> <span class=s2>"https://github.com/NixOS/nixpkgs/archive/</span><span class=nv>$1</span><span class=s2>.tar.gz"</span><span class=o>)</span>
<span class=k>fi

while </span><span class=nb>read</span> <span class=nt>-r</span> name version<span class=p>;</span> <span class=k>do
  </span>cur[<span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=o>]=</span><span class=k>${</span><span class=nv>version</span><span class=k>}</span>
<span class=k>done</span> &lt; &lt;<span class=o>(</span>query <span class=s2>"</span><span class=k>${</span><span class=nv>query_args</span><span class=p>[@]</span><span class=k>}</span><span class=s2>"</span><span class=o>)</span>

<span class=nv>ret</span><span class=o>=</span>0
<span class=k>while </span><span class=nb>read</span> <span class=nt>-r</span> name version<span class=p>;</span> <span class=k>do
  if</span> <span class=o>[[</span> <span class=nt>-n</span> <span class=k>${</span><span class=nv>cur</span><span class=p>[</span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=p>]</span><span class=k>:-}</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then
    if</span> <span class=o>[[</span> <span class=s2>"</span><span class=k>${</span><span class=nv>version</span><span class=k>}</span><span class=s2>"</span> <span class=o>!=</span> <span class=s2>"</span><span class=k>${</span><span class=nv>cur</span><span class=p>[</span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=p>]</span><span class=k>}</span><span class=s2>"</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then
      </span><span class=nb>echo</span> <span class=nt>-e</span> <span class=s2>"</span><span class=se>\0</span><span class=s2>33[33mM </span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=s2> </span><span class=k>${</span><span class=nv>cur</span><span class=p>[</span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=p>]</span><span class=k>}</span><span class=s2> ➤ </span><span class=k>${</span><span class=nv>version</span><span class=k>}</span><span class=se>\0</span><span class=s2>33[0m"</span>
      <span class=nv>ret</span><span class=o>=</span>1
    <span class=k>fi
    </span><span class=nb>unset</span> <span class=s2>"cur[</span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=s2>]"</span>
  <span class=k>else
    </span><span class=nb>echo</span> <span class=nt>-e</span> <span class=s2>"</span><span class=se>\0</span><span class=s2>33[32mA </span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=s2> </span><span class=k>${</span><span class=nv>version</span><span class=k>}</span><span class=se>\0</span><span class=s2>33[0m"</span>
    <span class=nv>ret</span><span class=o>=</span>1
  <span class=k>fi
done</span> &lt; &lt;<span class=o>(</span>query <span class=nt>-af</span> <span class=s2>"</span><span class=k>${</span><span class=nv>HOME</span><span class=k>}</span><span class=s2>/.dotfiles/env.nix"</span><span class=o>)</span>

<span class=k>for </span>name <span class=k>in</span> <span class=s2>"</span><span class=k>${</span><span class=p>!cur[@]</span><span class=k>}</span><span class=s2>"</span><span class=p>;</span> <span class=k>do
  </span><span class=nb>echo</span> <span class=nt>-e</span> <span class=s2>"</span><span class=se>\0</span><span class=s2>33[31mD </span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=s2> </span><span class=k>${</span><span class=nv>cur</span><span class=p>[</span><span class=k>${</span><span class=nv>name</span><span class=k>}</span><span class=p>]</span><span class=k>}</span><span class=se>\0</span><span class=s2>33[0m"</span>
  <span class=nv>ret</span><span class=o>=</span>1
<span class=k>done

if</span> <span class=o>[[</span> <span class=k>${</span><span class=nv>ret</span><span class=k>}</span> <span class=nt>-ne</span> 0 <span class=o>]]</span><span class=p>;</span> <span class=k>then</span>
  <span class=c># Disable SC2016 (info): Expressions don't expand in single quotes, use double quotes for that.</span>
  <span class=c># shellcheck disable=SC2016</span>
  <span class=nb>echo</span> <span class=s1>'Run `nix-env -irf ~/.dotfiles/env.nix` to make these changes'</span>
<span class=k>fi

</span><span class=nb>exit</span> <span class=s2>"</span><span class=k>${</span><span class=nv>ret</span><span class=k>}</span><span class=s2>"</span>

<span class=c># vim: set sw=2 sts=2 ts=8 et ft=bash:</span>
</code></pre></div></div><p>Happy Nixing.<hr><div class=footnotes role=doc-endnotes><ol><li id=fn:1><p>Ian takes you on his journey of learning Nix by reading the Nix manual (and then the Nixpkgs manual and then some more documentation) chapter by chapter. It’s more fun than it sounds. I recommend it.&nbsp;<a href=#fnref:1 class=reversefootnote role=doc-backlink>↩</a><li id=fn:2><p><a href=https://nixos.wiki/wiki/Flakes>Flakes</a> are a new way of using Nix to specify dependencies in a declarative manner. The Nix community has been moving toward flakes, but flakes are even more complex than normal Nix packages. They require a bunch of boilerplate. They simply aren’t ready for prime time as far as I can tell.&nbsp;<a href=#fnref:2 class=reversefootnote role=doc-backlink>↩</a><li id=fn:3><p>We can, of course, use <code class="language-plaintext highlighter-rouge">fetchTarball</code> in any Nix file where we want to be explicit about the revision of <code class="language-plaintext highlighter-rouge">nixpkgs</code> used to build the software, but then updating means updating every place, including in shell scripts that use <code class="language-plaintext highlighter-rouge">nix-shell</code>, a cool use case I neglected to mention before.&nbsp;<a href=#fnref:3 class=reversefootnote role=doc-backlink>↩</a><li id=fn:4><p>It’s not clear why <code class="language-plaintext highlighter-rouge">~/.nix-defexpr/nixpkgs.nix</code> does not work but <code class="language-plaintext highlighter-rouge">import &lt;nixpkgs&gt;</code> really does want <code class="language-plaintext highlighter-rouge">nixpkgs</code> to be a directory in this case.&nbsp;<a href=#fnref:4 class=reversefootnote role=doc-backlink>↩</a><li id=fn:5><p>You <em>can</em> still do a single-user install by editing the install script, but it’s not supported so I’m not going to do it.&nbsp;<a href=#fnref:5 class=reversefootnote role=doc-backlink>↩</a></ol></div></div><div class=post-footer><p class=post-meta>Last updated <time datetime=2022-07-23T00:00:00+00:00 property=dateModified>Jul 23, 2022</time>.</div></article></main>