<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Learning how a PC actually boots up</title><meta name=description content="I’ve occasionally wondered how it is that a computer gets from its power on state to running an operating system. Today I decided to take a look at a small p..."> <link rel=canonical href=https://checkoway.net/musings/bootup/> <link rel=stylesheet href=/css/main.css><main><article class=post vocab=http://schema.org typeof=BlogPosting><div class=post-header><h1 class=post-title property=headline>Learning how a PC actually boots up</h1><p class=post-meta><time datetime=2012-05-12T00:00:00+00:00 property=datePublished>May 12, 2012</time> • <span property=author typeof=Person><span property=name>Stephen Checkoway</span></span></div><div class=post-content property=articleBody><p>I’ve occasionally wondered how it is that a computer gets from its power on state to running an operating system. Today I decided to take a look at a small piece of that puzzle by examining a bootloader for an embedded x86 system I was hoping to reverse engineer at some point in the future. This particular machine runs the pSOS real-time operating system on a 486. I had some trouble figuring out where the firmware is actually loaded into memory by cursory examination and googling so I opted to break out IDA Pro and actually take a look at what goes on.<p>I don’t have access to the BIOS, unfortunately, so I was not able to examine that piece of the puzzle. I’ll save that for a later date when I’m not trying to finish my dissertation. Fortunately, the BIOS functionality seems to be pretty standard. What follows is a lightly edited version of the notes I took while reverse engineering the bootloader.<ol><li>The BIOS loads the master boot record (MBR) (sector 1 of the internal CF flash) at <code class="language-plaintext highlighter-rouge">0000:7c00</code> and then jumps to the bootloader at <code class="language-plaintext highlighter-rouge">0000:7c00</code>.<li>The boot loader loads 16 sector starting with sector 26 to <code class="language-plaintext highlighter-rouge">0a00:0000</code> using the interrupt handler for <code class="language-plaintext highlighter-rouge">int 13h</code> set up by the BIOS. This is the root directory structure for the FAT file system.<li>It looks up the first cluster number for the <code class="language-plaintext highlighter-rouge">PSOSBOOT.SYS</code> file (cluster 2).<li>The first sector of this cluster is loaded to <code class="language-plaintext highlighter-rouge">0a00:0000</code> which overwrites the root directory.<li>Next, <code class="language-plaintext highlighter-rouge">es</code> is set to the first word of <code class="language-plaintext highlighter-rouge">0a00:0000</code> which is <code class="language-plaintext highlighter-rouge">0x07e0</code>.<li>This value is shifted left by 4 and 4 is added to it (to get <code class="language-plaintext highlighter-rouge">0x7e04</code>) which is then written to <code class="language-plaintext highlighter-rouge">0000:7d14</code>. The 4 bits that were shifted off the end of the word are written into the least significant 4 bits of <code class="language-plaintext highlighter-rouge">0000:7d16</code>. The 4 bits don’t change anything since they’re just 0 and <code class="language-plaintext highlighter-rouge">0000:7d16</code> was already 0. This is self-modifying code! The result is that the last instruction executed by the bootloader is a <code class="language-plaintext highlighter-rouge">jmp large far ptr 0010:7e04</code> (according to IDA).<li>Next, it needs to load the OS (or a tertiary bootloader) into RAM. It does this at <code class="language-plaintext highlighter-rouge">7e00:0000</code>. It already looked up the first cluster number for <code class="language-plaintext highlighter-rouge">PSOSBOOT.SYS</code>, so it can immediately load it. It loops through the clusters corresponding to this file, loading it sequentially in memory.<li>A global descriptor table is constructed at address <code class="language-plaintext highlighter-rouge">0000:5000</code>. The table is 4 entries long. The zeroth is always ignored by the processor. The first and second are set to have a base address of <code class="language-plaintext highlighter-rouge">0x00000000</code> and a limit of <code class="language-plaintext highlighter-rouge">0xffffffff</code>. The first is a data segment that is read/write whereas the second is a code segment that is execute/read. The third entry is all zeros<li>(Maskable) interrupts are disabled and the processor enables protected mode by writing a bit to the cr0 register. At this point, the /Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3: System Programming Guide/ says that “[r]andom failures can occur” if a far jump or far call is not issued immediately after setting this bit in <code class="language-plaintext highlighter-rouge">cr0</code>. This code does not do that. Instead, it performs a short jump to the following instruction and will not actually set the <code class="language-plaintext highlighter-rouge">cs</code> register until step~12.<li>The <code class="language-plaintext highlighter-rouge">ds</code>, <code class="language-plaintext highlighter-rouge">es</code>, <code class="language-plaintext highlighter-rouge">fs</code>, <code class="language-plaintext highlighter-rouge">gs</code>, and <code class="language-plaintext highlighter-rouge">ss</code> segment registers are loaded with the selector for the first (data) segment.<li><p>A sequence of 4 instructions whose purpose eludes me.<pre><code class=language-asm>mov	eax, esp
xor	bx, bx
mov	sp, bx
mov	esp, eax
</code></pre><p>As far as I can tell, the only effect this will have is to clear <code class="language-plaintext highlighter-rouge">ebx</code>. I tested it with with a simple program.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#include &lt;stdio.h&gt;
</span>    
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
        <span class=kt>int</span> <span class=n>eax</span><span class=p>;</span>
        <span class=kt>short</span> <span class=n>bx</span><span class=p>;</span>
        <span class=kt>short</span> <span class=n>sp</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>esp</span><span class=p>;</span>
    
        <span class=n>asm</span><span class=p>(</span><span class=s>"movl %%esp, %%eax</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"xorw %%bx, %%bx</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"movw %%bx, %%sp</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"movl %%eax, %%esp</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"movl %%eax, %0</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"movw %%bx, %1</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"movw %%sp, %2</span><span class=se>\n\t</span><span class=s>"</span>
            <span class=s>"movl %%esp, %3"</span>
            <span class=o>:</span> <span class=s>"=r"</span><span class=p>(</span><span class=n>eax</span><span class=p>),</span> <span class=s>"=r"</span><span class=p>(</span><span class=n>bx</span><span class=p>),</span> <span class=s>"=r"</span><span class=p>(</span><span class=n>sp</span><span class=p>),</span> <span class=s>"=r"</span><span class=p>(</span><span class=n>esp</span><span class=p>)</span>
            <span class=o>:</span>
            <span class=o>:</span> <span class=s>"eax"</span><span class=p>,</span> <span class=s>"bx"</span><span class=p>,</span> <span class=s>"esp"</span><span class=p>);</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>"eax = %08x</span><span class=se>\n</span><span class=s>"</span>
               <span class=s>"bx  =     %04hx</span><span class=se>\n</span><span class=s>"</span>
               <span class=s>"sp  =     %04hx</span><span class=se>\n</span><span class=s>"</span>
               <span class=s>"esp = %08x</span><span class=se>\n</span><span class=s>"</span><span class=p>,</span> <span class=n>eax</span><span class=p>,</span> <span class=n>bx</span><span class=p>,</span> <span class=n>sp</span><span class=p>,</span> <span class=n>esp</span><span class=p>);</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></div><p>The result is exactly what I expected, eax and esp have the same value, <code class="language-plaintext highlighter-rouge">bx</code> is zero, and <code class="language-plaintext highlighter-rouge">sp</code> is the bottom half of esp. Of course, I was not running this in a strange state between entering protected mode and before loading the <code class="language-plaintext highlighter-rouge">cs</code> register and without virtual memory and a whole host of other environmental issues such as running in ring<ol><li>If anyone has any idea why these instructions are here, I’d love to know.</ol><li>Finally, it executes a <code class="language-plaintext highlighter-rouge">far jmp to 10:7e04</code>—this is the instruction that was modified in step 6 above—which sets the <code class="language-plaintext highlighter-rouge">cs</code> register to the second segment and jumps to address <code class="language-plaintext highlighter-rouge">0x7e04</code>.\n\n</ol><p>Now I need to look at what is loaded at <code class="language-plaintext highlighter-rouge">0x7e00</code>…but that can wait for another day.</div><div class=post-footer><p class=post-meta>Last updated <time datetime=2012-05-12T00:00:00+00:00 property=dateModified>May 12, 2012</time>.</div></article></main>