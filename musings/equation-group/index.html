<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Equation Group Initial Impressions</title><meta name=description content="A group calling itself the “Shadow Brokers” claimed to have stolen some of the NSA’s “Equation Group’s” “cyber weapons.” A sample of the tools were made publ..."> <link rel=canonical href=https://checkoway.net/musings/equation-group/> <link rel=stylesheet href=/css/main.css><main><article class=post vocab=http://schema.org typeof=BlogPosting><div class=post-header><h1 class=post-title property=headline>Equation Group Initial Impressions</h1><p class=post-meta><time datetime=2016-08-17T00:00:00+00:00 property=datePublished>Aug 17, 2016</time> • <span property=author typeof=Person><span property=name>Stephen Checkoway</span></span></div><div class=post-content property=articleBody><p>A group calling itself the “Shadow Brokers” claimed to have stolen some of the NSA’s “Equation Group’s” “cyber weapons.” A sample of the tools were made publicly available with the others supposed available to the winner of an auction. The <em>Washington Post</em> is <a href="https://www.washingtonpost.com/world/national-security/powerful-nsa-hacking-tools-have-been-revealed-online/2016/08/16/bce4f974-63c7-11e6-96c0-37533479f3f5_story.html?tid=a_inl">reporting</a> that these are legitimate NSA tools.<p>I decided to take a quick look at some of the “cyber weapons” this morning and I’m pretty underwhelmed by their quality.<p>In particular, I looked at the BANANAGLEE BG2100 code for creating encryption keys (<code class="language-plaintext highlighter-rouge">keygen-2140</code>) and redirecting communications (<code class="language-plaintext highlighter-rouge">bg_redirector-2140</code>). Both of these are statically-linked Linux executables.<h2 id=keygen>Keygen</h2><p>The purpose of the keygen tool is to generate a 16-byte random number for use by the other tools. This simple task can be accomplished by reading 16 bytes from <code class="language-plaintext highlighter-rouge">/dev/urandom</code>. Here’s a one-liner to accomplish what they want.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nb>dd </span><span class=k>if</span><span class=o>=</span>/dev/urandom <span class=nv>bs</span><span class=o>=</span>16 <span class=nv>count</span><span class=o>=</span>1 2&gt;/dev/null |xxd <span class=nt>-p</span>
</code></pre></div></div><p>Instead, 16-bytes are generated by the following procedure.<ol><li>Read 32 bytes from <code class="language-plaintext highlighter-rouge">/dev/urandom</code>.<li>Use the first 4 of those bytes as an argument to <a href=https://linux.die.net/man/3/srandom><code class="language-plaintext highlighter-rouge">srandom(3)</code></a> to seed the non-cryptographic <a href=https://linux.die.net/man/3/random><code class="language-plaintext highlighter-rouge">random(3)</code></a> pseudorandom number generator.<li>Generate 20 bytes with the following procedure for each byte. <ol><li>Call <a href=https://linux.die.net/man/3/rand><code class="language-plaintext highlighter-rouge">rand(3)</code></a> and throw away the result <code class="language-plaintext highlighter-rouge">(rand() % 2931)*(rand() % 242) + 2351</code> times.<li>Call <code class="language-plaintext highlighter-rouge">rand(3)</code> again and use the least significant byte.</ol><li>Use the second 4 bytes from <code class="language-plaintext highlighter-rouge">/dev/urandom</code> as the argument to <code class="language-plaintext highlighter-rouge">srandom(3)</code> and repeat step 3 to generate another 20 bytes.<li>Compute the SHA-1 hash of the 40 bytes.<li>Output the most significant 16 bytes of the hash.</ol><p>This is ridiculous. There’s no reason to read 32 bytes from <code class="language-plaintext highlighter-rouge">/dev/urandom</code>. There’s no benefit to calling <code class="language-plaintext highlighter-rouge">rand(3)</code> so many times. (It’s a little ridiculous to be seeding with <code class="language-plaintext highlighter-rouge">srandom(3)</code> and calling <code class="language-plaintext highlighter-rouge">rand(3)</code>, but in this particular implementation, <code class="language-plaintext highlighter-rouge">rand(3)</code> does nothing but call <code class="language-plaintext highlighter-rouge">random(3)</code>.)<p>But worst of all, rather than having 2<sup>128</sup> possible 128-bit keys, this procedure can only produce 2<sup>64</sup> distinct keys!<h2 id=background-redirector>Background redirector</h2><p>The background redirector appears to listen for IP packets being sent from the “attack” host to some particular other host and instead encrypts them and sends them to a third host. It also listens for encrypted packets from the third host, decrypts them, and sends them along to the attack host.<p>As near as I can tell, the idea is to make it look like the attack host is sending data to and receiving data from the second host while actually communicating with the third. That’s kinda neat.<p>But both the code and the crypto are bad. Very bad. The code has some boring memory leaks. The protocol used for encrypted communication is much more interesting.<p>I didn’t dive into it too deeply, but it appears to be encapsulating tcp or udp packets into fragments of size 526 bytes, prepending a header, encrypting part of the whole and sending it along.<p>The header consists of a 4-byte random number (shared by each fragment corresponding to a given IP packet), an 8-byte initialization vector, a 4-byte magic number <code class="language-plaintext highlighter-rouge">0xDECAFBAD</code>, a 2-byte fragment number, a 2-byte total number of fragments, and a 2-byte size.<p>Starting with the magic number field of the header, the packet is encrypted using RC6 in <a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Output_Feedback_.28OFB.29>output feedback mode</a>. To compute the IV, a SHA-1 hash of the plain text (starting with the magic field of the header) is computed and the 8 most significant bytes form the least significant 8 bytes of the 16-byte IV. (The most significant bytes of the IV are set to 0). It’s important to note that the random value identifying the fragments is not hashed into the IV.<p>I’m no cryptographer, but this seems <em>crazy</em>. An IV should never be reused for a given key. And yet identical messages will produce identical IVs, even if the keys are different. Perhaps there’s something that guarantees a message will never be sent twice, but if I were designing this, I sure wouldn’t rely on that property.<p><strong>Update:</strong> Sean Devlin pointed out that leaking bits of the hash of the plain text is also a pretty bad idea.<h2 id=overall>Overall</h2><p>I looked at two tools and found<ul><li>128-bit keys generated using 64 bits of entropy.<li>Apparently repeated IVs.<li><strong>(Update)</strong> IV leaks bits of the hash of the plain text.<li>No authentication of the encrypted communication channel.<li>Sloppy and buggy code.</ul><p>Maybe I simply picked bad tools and the others are all fantastic, but I kind of doubt it. Overall, I’m not impressed by what I’ve seen here.</div><div class=post-footer><p class=post-meta>Last updated <time datetime=2016-08-17T00:00:00+00:00 property=dateModified>Aug 17, 2016</time>.</div></article></main>