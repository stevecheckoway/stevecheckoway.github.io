<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Return-Oriented Programming's Status is Unchanged</title><meta name=description content="Microsoft recently announced the winners of its BlueHat Prize Contest. The goal of the contest was to develop a defense against Return-Oriented Programming (..."> <link rel=canonical href=https://checkoway.net/musings/rop/> <link rel=stylesheet href=/css/main.css><main><article class=post vocab=http://schema.org typeof=BlogPosting><div class=post-header><h1 class=post-title property=headline>Return-Oriented Programming’s Status is Unchanged</h1><p class=post-meta><time datetime=2012-08-22T00:00:00+00:00 property=datePublished>Aug 22, 2012</time> • <span property=author typeof=Person><span property=name>Stephen Checkoway</span></span></div><div class=post-content property=articleBody><p>Microsoft recently announced the winners of its BlueHat Prize Contest. The goal of the contest was to develop a defense against Return-Oriented Programming (ROP). Vasilis Pappas, Ivan Fratric, and Jared DeMott won a combined total of $260,000 with Vasilis Pappas winning the lion’s share ($200,000) for his kBouncer mitigation measure. Unfortunately for Microsoft, all three of these defenses are already broken.<p>The first place winner, kBouncer [5], leverages an Intel protected-mode instruction that allows an OS kernel to extract the last several executed branches. When a user application calls into the kernel, the kernel will check that the last set of return instructions executed actually returned to a location after a call instruction. Pappas does admit that kBouncer does not protect against return-oriented programming that doesn’t use returns—a technique pioneered by Hovav Shacham and me in 2010 [3]. However, this is not the only way to defeat kBouncer.<p>As Pappas writes, “[a]nother way to evade [kBouncer] is by using ROP code to overwrite the contents of the [branch trace] registers with legitimate call-return control transfers just before performing the system call.” He continues that this would be “extremely hard to realise.” In fact, this is not true. It is not the case that a return-oriented program is limited to executing only the gadgets that make up its Turing-complete functionality. Indeed, it is entirely possible to craft a separate function call stack and execute legitimate functions in the program. When these functions return, control returns to the return-oriented program. As long as the sequence of indirect branches (in particular returns) between the function’s entry point and when it first makes a system call is sufficiently long, kBouncer will not detect the return-oriented program.<p>This is not a theoretical vulnerability, it is precisely the tack I took when crafting a voting-stealing program in my 2009 paper with Ariel J. Feldman, Brian Kantor, J. Alex Halderman, Edward W. Felten, and Hovav Shacham [2]. In a sense, this is not surprising. It is not always the case that the attacker wishes to induce entirely new behavior when exploiting a program. Often, it is sufficient to modify the behavior of the program and this can be accomplished without the need to make new system calls. (Note that I’m not claiming to have anticipated kBouncer and written an exploit to defeat it; I’m simply noting that one natural way to write ROP code defeats it as a side effect.)<p>The second place prize was claimed by Ivan Fratric for his ROPGuard. I have not yet seen the details for ROPGuard, but arstechnica is reporting that it has already been defeated [4]. It’s not clear if this is a fundamental break of the technique or simply an implementation error.<p>The third place entry was /ROP by Jared DeMott and like kBouncer only tries to defend against the original incarnation of ROP which relied on return instructions. It is also defeated by return-oriented programming without returns.<p>In the winners’ defense, their techniques do raise the bar for attackers by eliminating the easiest and most natural form of ROP.<p>In closing, I should note that Microsoft already knows a comprehensive defense against ROP and a large class of control-flow hijacking attacks. In fact, they invented the technique (at least in part)! I am, of course, referring to Control-Flow Integrity developed by Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti [1]. So with this in mind, the title of this page refers to the fact that ad hoc defenses against exploitation are still defeated and comprehensive defenses are still successful. In short, ROP’s status is unchanged.<h2 id=references>References</h2><ol><li>Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. <a href=https://research.microsoft.com/pubs/64250/ccs05.pdf>Control-Flow Integrity: Principles, Implementations, and Applications</a>. In Catherine Meadows and Ari Juels, editors, <em>Proceedings of CCS 2005</em>. ACM. November 2005.<li>Stephen Checkoway, Ariel J. Feldman, Brian Kantor, J. Alex Halderman, Edward W. Felten, and Hovav Shacham. <a href=/papers/evt2009>Can DREs Provide Long-Lasting Security? The Case of Return-Oriented Programming and the AVC Advantage</a>. In David Jefferson, Joseph Lorenzo Hall, and Tal Moran, editors, <em>Proceedings of EVT/WOTE 2009</em>. USENIX/ACCURATE/IAVoSS, August 2009.<li>Stephen Checkoway and Hovav Shacham. <a href=/papers/noret2010>Escape From Return-Oriented Programming: Return-oriented Programming without Returns (on the x86)</a>. Technical Report CS2010-0954, UC San Diego, February 2010.<li>Dan Goodin. <a href=https://arstechnica.com/security/2012/08/microsoft-defense-bypassed-in-2-weeks>Microsoft defense that fetched $50,000 prize bypassed in just 2 weeks</a>. arstechnica. August 2012.<li>Vasilis Pappas. <a href=https://web.archive.org/web/20221218080801/http://www.cs.columbia.edu/~vpappas/papers/kbouncer.pdf>kBouncer: Efficient and Transparent ROP Mitigation</a>. April 2012.</ol></div><div class=post-footer><p class=post-meta>Last updated <time datetime=2012-08-22T00:00:00+00:00 property=dateModified>Aug 22, 2012</time>.</div></article></main>