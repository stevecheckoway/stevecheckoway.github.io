<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>C enables bugs</title><meta name=description content="The C programming language is not memory safe and it is not type safe."> <link rel=canonical href=https://checkoway.net/musings/c-enables-bugs/> <link rel=stylesheet href=/css/main.css><main><article class=post vocab=http://schema.org typeof=BlogPosting><div class=post-header><h1 class=post-title property=headline>C enables bugs</h1><p class=post-meta><time datetime=2023-07-07T00:00:00+00:00 property=datePublished>Jul 7, 2023</time> • <span property=author typeof=Person><span property=name>Stephen Checkoway</span></span></div><div class=post-content property=articleBody><p>The C programming language is not <a href=https://en.wikipedia.org/wiki/Memory_safety>memory safe</a> and it is not <a href=https://en.wikipedia.org/wiki/Type_safety>type safe</a>. In practice, this means that a simple error that confuses the type of an object<sup id=fnref:1 role=doc-noteref><a href=#fn:1 class=footnote rel=footnote>1</a></sup>—or, as well see, forgets to check the type of an object—can lead to code accessing arbitrary memory. When an adversary is able to arrange for the type of one object to be confused for the another type, we call this a type confusion attack and it frequently results in complete software compromise.<p>In many cases, a modern C compiler with warnings turned on will catch simple examples of this, but there’s one programming pattern where the compiler cannot help you because the code itself is relying on type confusion enabled by guarantees in the language standard. And unlike most other modern (and even not that modern) languages rule this behavior out. That pattern is hand-rolled <a href=https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)>inheritance</a>.<p>Let’s take a look at an example. Let’s say we want to have a linked list containing multiple types of objects. Here’s one approach.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>enum</span> <span class=p>{</span>
    <span class=n>FOO_TYPE</span><span class=p>,</span>
    <span class=n>BAR_TYPE</span><span class=p>,</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=n>Foo</span> <span class=p>{</span>
    <span class=c1>// Common members.</span>
    <span class=kt>int</span> <span class=n>type</span><span class=p>;</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
    <span class=c1>// Unique members.</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=n>Bar</span> <span class=p>{</span>
    <span class=c1>// Common members.</span>
    <span class=kt>int</span> <span class=n>type</span><span class=p>;</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
    <span class=c1>// Unique members.</span>
    <span class=kt>long</span> <span class=n>x</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></div><p>Notice that both <code class="language-plaintext highlighter-rouge">struct Foo</code> and <code class="language-plaintext highlighter-rouge">struct Bar</code> have the same 3 initial members in common, a type field, and name, and a next pointer.<p>Structures in C are laid out in memory sequentially (possibly with padding for alignment reasons) <a href=https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf>C23 §6.7.2.1</a>. The upshot is that we can convert a pointer to a <code class="language-plaintext highlighter-rouge">struct Foo</code> into a pointer to a <code class="language-plaintext highlighter-rouge">struct Bar</code> and then access the members the three members in common. Here’s an example that walks such a linked list and prints out the name field of each element in the list.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>print_list</span><span class=p>(</span><span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>head_of_list</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>head_of_list</span><span class=p>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>puts</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>Notice that even if some of the members of the list are <code class="language-plaintext highlighter-rouge">struct Bar</code>, this code works correctly because the only members that are accessed are <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">next</code> and those are in the same location in <code class="language-plaintext highlighter-rouge">struct Bar</code>.<p>The problem comes in when you decide to access one of the unique members. Let’s update our <code class="language-plaintext highlighter-rouge">print_list</code> function.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>print_list</span><span class=p>(</span><span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>head_of_list</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>head_of_list</span><span class=p>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>"%s: %s</span><span class=se>\n</span><span class=s>"</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>The problem, of course, is that we’ve tried to access the <code class="language-plaintext highlighter-rouge">data</code> member of a <code class="language-plaintext highlighter-rouge">struct Bar</code>. This is type confusion. It’s undefined behavior. The compiler is free to do anything it wants with this code except that it cannot tell that the code has any bugs so it’s likely to treat the data it gets from <code class="language-plaintext highlighter-rouge">p-&gt;data</code> as a pointer to a string and then try to print it. Since <code class="language-plaintext highlighter-rouge">long</code> and <code class="language-plaintext highlighter-rouge">char *</code> usually have the same alignment and size, this means we’ll be using the <code class="language-plaintext highlighter-rouge">x</code> member of the <code class="language-plaintext highlighter-rouge">struct Bar</code> as if it were a pointer. This example is likely to crash.<p>The fix is simple: Don’t access a member unless you know the type of the structure is what you expect. Since C cannot help us here, we have to use the <code class="language-plaintext highlighter-rouge">type</code> member to disambiguate. This leads to the following correct code.<sup id=fnref:2 role=doc-noteref><a href=#fn:2 class=footnote rel=footnote>2</a></sup><div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=kt>void</span> <span class=nf>print_list</span><span class=p>(</span><span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>head_of_list</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=k>struct</span> <span class=n>Foo</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>head_of_list</span><span class=p>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>FOO_TYPE</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>printf</span><span class=p>(</span><span class=s>"%s: %s</span><span class=se>\n</span><span class=s>"</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=n>Bar</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>Bar</span> <span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>;</span>
            <span class=n>printf</span><span class=p>(</span><span class=s>"%s: 0x%lX</span><span class=se>\n</span><span class=s>"</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>Here’s a link to <a href=https://godbolt.org/z/GhzG8M5df>Compiler Explorer</a> with this code if you want to play with it.<h2 id=c-is-the-problem>C is the problem</h2><p>The root of the issue here is that C enables this style of code but provides no tools to help you use it safely. Most modern languages simply disallow it and provide users with tools to deal with it.<p>In Java, for example, we would use a base class that both <code class="language-plaintext highlighter-rouge">Foo</code> and <code class="language-plaintext highlighter-rouge">Bar</code> inherit from. And if we tried to cast an instance of <code class="language-plaintext highlighter-rouge">Foo</code> to <code class="language-plaintext highlighter-rouge">Bar</code>, we’ll get a runtime error, specifically a <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/ClassCastException.html><code class="language-plaintext highlighter-rouge">ClassCastException</code></a>.<p>In Rust, this error would be prevented at compile time. It’s simply not possible to treat at <code class="language-plaintext highlighter-rouge">Foo</code> as a <code class="language-plaintext highlighter-rouge">Bar</code> without using an <code class="language-plaintext highlighter-rouge">unsafe</code> block.<p>Even C++ provides the tools to handle this safely. It won’t stop you from casting a <code class="language-plaintext highlighter-rouge">Foo *</code> to a <code class="language-plaintext highlighter-rouge">Bar *</code> exactly as in C;<sup id=fnref:3 role=doc-noteref><a href=#fn:3 class=footnote rel=footnote>3</a></sup> however, you can use C++’s object-oriented nature to create a base class, as we do with Java, and then use <code class="language-plaintext highlighter-rouge">dynamic_cast</code> to convert from a base pointer to a <code class="language-plaintext highlighter-rouge">Foo</code> or <code class="language-plaintext highlighter-rouge">Bar</code> pointer. We don’t get an exception if this down cast fails,<sup id=fnref:4 role=doc-noteref><a href=#fn:4 class=footnote rel=footnote>4</a></sup> instead the result is <code class="language-plaintext highlighter-rouge">nullptr</code>.<p>This is not a theoretical problem, but a real one that impacts real code bases, large and small. I ran across an instance of this issue in some code using libxml2. Libxml2 takes XML or (old) HTML and produces a tree of nodes representing the documents. There are several different <a href=https://github.com/GNOME/libxml2/blob/884474477284474e0151280aaa275a18e3d7a036/include/libxml/tree.h#L159>types of nodes</a>, including element nodes, attribute nodes, and text nodes. Element nodes (and text nodes for that matter) are represented by an <code class="language-plaintext highlighter-rouge">xmlNode</code> structure where as attributes are represented by an <code class="language-plaintext highlighter-rouge">xmlAttr</code> structure. These are structured similarly to <code class="language-plaintext highlighter-rouge">struct Foo</code> and <code class="language-plaintext highlighter-rouge">struct Bar</code> above in that they have some members in common—including a type, a name, and pointers <code class="language-plaintext highlighter-rouge">children</code>, <code class="language-plaintext highlighter-rouge">last</code>, <code class="language-plaintext highlighter-rouge">parent</code>, <code class="language-plaintext highlighter-rouge">next</code>, and <code class="language-plaintext highlighter-rouge">prev</code> that point to other nodes in the tree. Other nodes like the <code class="language-plaintext highlighter-rouge">xmlDtd</code> (which comes from a <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE ...&gt;</code>) behave similarly.<p>In the case I saw, an <code class="language-plaintext highlighter-rouge">xmlAttr *</code> was being treated as an <code class="language-plaintext highlighter-rouge">xmlNode *</code> (which was fine for traversing the list of attributes on an element) but the <code class="language-plaintext highlighter-rouge">properties</code> field of an <code class="language-plaintext highlighter-rouge">xmlNode</code> was being accessed but <code class="language-plaintext highlighter-rouge">xmlAttr</code> doesn’t have a <code class="language-plaintext highlighter-rouge">properties</code> field. This type confusion was leading to crashes. The <a href=https://github.com/sparklemotion/nokogiri/pull/2924/commits/81762fa0b306a7d25ef22a303ff9dd6e9bd94ffd>fix</a> was simple (check the <code class="language-plaintext highlighter-rouge">type</code> field exactly as in my example above).<p>Note that using an <code class="language-plaintext highlighter-rouge">xmlNode *</code> to point to an <code class="language-plaintext highlighter-rouge">xmlAttr</code> is an expected use of the API. See, for example, <a href=https://github.com/GNOME/libxml2/blob/884474477284474e0151280aaa275a18e3d7a036/tree.c#L796><code class="language-plaintext highlighter-rouge">xmlSetNs</code></a> which sets a namespace on a node of type either <code class="language-plaintext highlighter-rouge">XML_ELEMENT_NODE</code> or <code class="language-plaintext highlighter-rouge">XML_ATTRIBUTE_NODE</code>. Its first argument is a pointer to an <code class="language-plaintext highlighter-rouge">xmlNode</code> so if you wish to set the namespace of an attribute node, you need to cast the address to an <code class="language-plaintext highlighter-rouge">xmlNode *</code>.<sup id=fnref:5 role=doc-noteref><a href=#fn:5 class=footnote rel=footnote>5</a></sup><h2 id=not-using-c-is-the-solution>Not using C is the solution</h2><p>We need to stop using C when we have alternatives. I see no other way.<p>To quote <a href=https://fishinabarrel.github.io/>Fish in a Barrel</a>, “Stop writing C/C++.”<hr><div class=footnotes role=doc-endnotes><ol><li id=fn:1 role=doc-endnote><p>I don’t only mean an object in the sense of <a href=https://en.wikipedia.org/wiki/Object-oriented_programming>object-oriented programming</a>, but rather the more general notion of a “region of data storage in the execution environment, the contents of which can represent values” (<a href=https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf>C23 §3.15</a>).&nbsp;<a href=#fnref:1 class=reversefootnote role=doc-backlink>↩</a><li id=fn:2 role=doc-endnote><p>It’s correct, but brittle! If we add a third type of object, then we need to identify all of the places we made a decision based on type and update them.&nbsp;<a href=#fnref:2 class=reversefootnote role=doc-backlink>↩</a><li id=fn:3 role=doc-endnote><p>As <a href=https://en.cppreference.com/w/cpp/language/dynamic_cast>cppreference.com</a> points out, “A downcast can also be performed with <code class="language-plaintext highlighter-rouge">static_cast</code>, which avoid the cost of the runtime check, but it’s only safe if the program can guarantee (through some other logic) that the object pointed to by [the argument to the <code class="language-plaintext highlighter-rouge">dynamic_cast</code>] is definitely [an object of the correct type].” One example of a code base using “some other logic” is LLVM which uses custom logic to keep track of the types of objects. See the <a href=https://llvm.org/doxygen/classllvm_1_1Type.html><code class="language-plaintext highlighter-rouge">Type</code></a> class for examples.<p>Notice how brittle this approach is. Here’s a comment from <a href=https://llvm.org/doxygen/Type_8h_source.html#l00048><code class="language-plaintext highlighter-rouge">Types.h</code></a>.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code>    <span class=c1>/// Definitions of all of the base types for the Type system.  Based on this</span>
    <span class=c1>/// value, you can cast to a class defined in DerivedTypes.h.</span>
    <span class=c1>/// Note: If you add an element to this, you need to add an element to the</span>
    <span class=c1>/// Type::getPrimitiveType function, or else things will break!</span>
    <span class=c1>/// Also update LLVMTypeKind and LLVMGetTypeKind () in the C binding.</span>
</code></pre></div></div><p><a href=#fnref:3 class=reversefootnote role=doc-backlink>↩</a><li id=fn:4 role=doc-endnote><p><code class="language-plaintext highlighter-rouge">dynamic_cast</code> on a reference can raise a <code class="language-plaintext highlighter-rouge">std::bad_cast</code> exception since it cannot return <code class="language-plaintext highlighter-rouge">nullptr</code>.&nbsp;<a href=#fnref:4 class=reversefootnote role=doc-backlink>↩</a><li id=fn:5 role=doc-endnote><p>In this particular case, the code for <code class="language-plaintext highlighter-rouge">xmlSetNs</code> doesn’t switch on the <code class="language-plaintext highlighter-rouge">type</code> member. Instead, it checks if <code class="language-plaintext highlighter-rouge">type</code> is either <code class="language-plaintext highlighter-rouge">XML_ELEMENT_NODE</code> or <code class="language-plaintext highlighter-rouge">XML_ATTRIBUTE_NODE</code> and if so, sets the <code class="language-plaintext highlighter-rouge">ns</code> member of the <code class="language-plaintext highlighter-rouge">xmlNode</code> even though <code class="language-plaintext highlighter-rouge">ns</code> isn’t one of the common members that appears in all of these structs. Instead, <code class="language-plaintext highlighter-rouge">ns</code> is the first unique member of both the <code class="language-plaintext highlighter-rouge">xmlNode</code> and <code class="language-plaintext highlighter-rouge">xmlAttr</code> structures. The location of the <code class="language-plaintext highlighter-rouge">ns</code> members relative to the start of their respective structures is an undocumented invariant. I keep writing that this style of code is brittle and this is no different.&nbsp;<a href=#fnref:5 class=reversefootnote role=doc-backlink>↩</a></ol></div></div><div class=post-footer><p class=post-meta>Last updated <time datetime=2023-07-07T00:00:00+00:00 property=dateModified>Jul 7, 2023</time>.</div></article></main>