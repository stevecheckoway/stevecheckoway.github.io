<!DOCTYPE html><html lang=en><meta http-equiv=Content-Type content="text/html;charset=utf-8"> <meta http-equiv=X-UA-Compatible content="IE=edge"> <meta name=viewport content="width=device-width, initial-scale=1"><title>Kaspersky's Analysis of Equation Group's RC6 is Wrong</title><meta name=description content="This post has been translated into Estonian by Sonja Kulmala."> <link rel=stylesheet href=/css/main.css> <script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-34500030-2","auto"),ga("send","pageview");</script><main><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class=post-header><h1 class=post-title itemprop="name headline">Kaspersky’s Analysis of Equation Group’s RC6 is Wrong</h1><p class=post-meta><time datetime=2016-08-20T00:00:00-04:00 itemprop=datePublished>Aug 20, 2016</time> • <span itemprop=author itemscope itemtype=http://schema.org/Person><span itemprop=name>Stephen Checkoway</span></span></div><div class=post-content itemprop=articleBody><p><em>This post has been translated into <a href=http://www.teileshop.de/blog/2016/11/08/research-kohtvalgustid/>Estonian</a> by Sonja Kulmala.</em><p>Kaspersky Lab recently published a blog post <a href=https://securelist.com/blog/incidents/75812/the-equation-giveaway/><em>Rare implementation of RC5/RC6 in ‘ShadowBrokers’ dump connects them to Equation malware</em></a> in which they analyze the <a href=https://en.wikipedia.org/wiki/RC6>RC6</a> block cipher implementation used in the recent ShadowBrokers release and compare it to the earlier Equation Group malware they found. They conclude that since all of the implementations they examined contain an RC6 constant in its negated form, it <em>must</em> be from the same authors since that’s so unusual. Their analysis is wrong.<p><strong>I don’t mean that their conclusion is wrong.</strong> They’re probably right. This is probably the same code. But their <em>analysis</em> is definitely wrong.<p><strong>Update:</strong> I’m not the first one to notice <a href="https://news.ycombinator.com/item?id=12301406">this</a>.<p>Kaspersky’s main claim is that since on some platforms (although they don’t say which; and this isn’t true on almost anything newer than the Z80), addition is faster than subtraction and therefore the source code for RC6 should contain the <em>addition</em> of a particular constant, <code class=highlighter-rouge>Q32</code>, in the key expansion routine. What they found in both the ShadowBrokers dump and the earlier Equation Group malware was an RC6 implementation that was subtracting <code class=highlighter-rouge>-Q32</code> rather than adding <code class=highlighter-rouge>Q32</code>. To Kaspersky, this is the smoking gun linking the two.<p>Consider a typical <a href=https://github.com/Ithamar/awutils/blob/master/rc6.c>implementation</a> of RC6. (By typical, I mean I googled for RC6 source code and selected the first implementation I found that was obviously standalone.) On lines 78–80, we see the loop in the key expansion code that Kaspersky focuses on, reproduced here.<div class="language-c highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>*</span><span class=n>rounds</span><span class=o>+</span><span class=mi>4</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
	<span class=n>s</span><span class=o>-&gt;</span><span class=n>S</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>S</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>Q32</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></div><p><code class=highlighter-rouge>Q32</code> is the constant in question and it is defined on line 37 as <code class=highlighter-rouge>0x9E3779B9</code>, which is the standard form that appears in Ron Rivest’s original <a href=http://people.csail.mit.edu/rivest/Rivest-rc5.pdf>paper</a>.<p>From a very quick analysis of the ShadowBrokers binaries, it’s clear that many of these programs were compiled using a Red Hat version of GCC 3.4.x or GCC 4.0.0. Somewhat bizarrely, the same binary will incorporate objects from several compilers. For example, <code class=highlighter-rouge>BANANAGLEE/BG2100/Install/LP/bg_redirector-2140</code> which I previously <a href=/musings/equation-group/>examined</a>, appears to contain objects compiled using four different versions of GCC.<div class="language-bash highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=nv>$ </span>strings bg_redirector-2140 |grep GCC|sort <span class=nt>-u</span>
GCC: <span class=o>(</span>GNU<span class=o>)</span> 3.4.3
GCC: <span class=o>(</span>GNU<span class=o>)</span> 4.0.0 20050314 <span class=o>(</span>Red Hat 4.0.0-0.34<span class=o>)</span>
GCC: <span class=o>(</span>GNU<span class=o>)</span> 4.0.0 20050518 <span class=o>(</span>Red Hat 4.0.0-7<span class=o>)</span>
GCC: <span class=o>(</span>GNU<span class=o>)</span> 4.0.0 20050525 <span class=o>(</span>Red Hat 4.0.0-9<span class=o>)</span>
</code></pre></div></div><p>Based on the dates and GCC versions, I installed CentOS 4.1 (which is based on Red Hat) in a VM. I downloaded the RC6 implementation linked above and compiled it with GCC 3.4.3 20050227 (Red Hat 3.4.3-22.1) which came with the OS. It’s not quite the same version of GCC, but it’s close enough. Looking at either the assembly produced by GCC or by running <code class=highlighter-rouge>objdump</code> on the object file, we see a subtraction of <code class=highlighter-rouge>0x61C88647</code> rather than an addition of <code class=highlighter-rouge>0x9E3779B9</code>. And this holds true for all optimization levels (<code class=highlighter-rouge>-O0</code> through <code class=highlighter-rouge>-O3</code> and <code class=highlighter-rouge>-Os</code>).<p><img src=/assets/posts/equation-group-rc6/rc6-compiled.png alt="Output of compiling rc6.c on CentOS"><p>Since the compiler itself is responsible for producing the subtraction instruction, its presence does not conclusively demonstrate that the Equation Group malware and the code released by the ShadowBrokers were written by the same group.<p><strong>Update 2:</strong> More evidence that Kaspersky is wrong in their analysis comes from looking at some of the other architectures. For example, in the MIPS version of SecondDate, the constant <code class=highlighter-rouge>0x9E3779B9</code> is used with <code class=highlighter-rouge>addu</code> (note the value stored into <code class=highlighter-rouge>$a1</code>).<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>Rc6_expandKey:
                lui     $v0, 0xB7E1      # Load Upper Immediate
                move    $t6, $a1
                li      $v0, 0xB7E15163  # Load Immediate
                lui     $a1, 0x9E37      # Load Upper Immediate
                move    $a3, $a0
                addiu   $sp, -0x10       # Add Immediate Unsigned
                sw      $v0, 0($t6)      # Store Word
                li      $t5, 1           # Load Immediate
                li      $a1, 0x9E3779B9  # Load Immediate
                addiu   $a0, $t6, 4      # Add Immediate Unsigned

loc_9B98:                                # CODE XREF: Rc6_expandKey+3Cj
                lw      $v0, -4($a0)     # Load Word
                addiu   $t5, 1           # Add Immediate Unsigned
                sltiu   $v1, $t5, 0x2C   # Set on Less Than Immediate Unsigned
                addu    $v0, $a1         # Add Unsigned
                sw      $v0, 0($a0)      # Store Word
                bnez    $v1, loc_9B98    # Branch on Not Zero
                addiu   $a0, 4           # Add Immediate Unsigned
</code></pre></div></div><p>In the PPC version of SecondDate, <code class=highlighter-rouge>0x9E3779B9</code> is used with <code class=highlighter-rouge>addis</code>/<code class=highlighter-rouge>addi</code>.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>loc_98AC:
                slwi      r7, r6, 2     # Shift Left Immediate
                addi      r6, r6, 1     # Add Immediate
                add       r9, r7, r4    # Add
                lwz       r10, -4(r9)   # Load Word and Zero
                addis     r8, r10, 0x9E37 # Add Immediate Shifted
                addi      r0, r8, 0x79B9 # Add Immediate
                stwx      r0, r7, r4    # Store Word Indexed
                bdnz      loc_98AC      # CTR--; branch if CTR non-zero
</code></pre></div></div><p>In the ARM version of BSecondDateCommon, <code class=highlighter-rouge>0x9E3779B9</code> is used with <code class=highlighter-rouge>add</code>.<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>loc_117BC:
                LDR             R2, [R1]
                LDR             R3, =0x9E3779B9
                ADD             R0, R0, #1
                CMP             R0, #0x2C ; ','
                ADD             R3, R2, R3
                STR             R3, [R1,#4]!
                BNE             loc_117BC
                MOV             R4, #0
</code></pre></div></div><p>On x86, for some reason, GCC decides to go with a subtraction. On other architectures, it doesn’t.</div></article></main>